// COMPAT //
const worker = self
let workerWindow = worker

global = workerWindow;
global.utility = {
    log: (e)=>{console.log("[LOG]",e)}
}
workerWindow.process = {
    env: {},
    argv: []
};
// MULTIPLAYER //
const userSockets = new Map()
const bannedPlayers = [];

worker.onmessage = function(msgEvent){
  const data = msgEvent.data
  //roomManager = new WebSocket("wss://eternia-room-manager.glitch.me")
  switch(data.type){
    case "startServer":
      worker.postMessage({type:"serverStartText", text:"Loading definitions...", tip:"This usually takes time because Eternia has LOTS of tanks. (If this takes more than 30 seconds, refresh the page and try again)"})
      /*fetch("./definitions.js").then((res)=>{
        if(!res.ok){
          worker.postMessage({type:"serverStartText", text:"Error loading definitons", tip:"Please reload the page and try again"})
          console.error(res)
          return;
        }
        return res.text()
      }).then((defData)=>{
        eval(defData)
        worker.postMessage({type:"serverStartText", text:"Starting server...", tip:"The game will start shortly"})
        startServer(data.server.suffix, data.server.gamemode, defExports)
      }).catch((err)=>{
        console.error(err)
        worker.postMessage({type:"serverStartText", text:"Error loading definitons", tip:"Please reload the page and try again"})
      })*/
      import("./definitions.js").then((res)=>{
        worker.postMessage({type:"serverStartText", text:"Starting server...", tip:"The game will start shortly"})
        global.initExportCode = res.initExportCode
        startServer(data.server.suffix, data.server.gamemode, res.defExports)
      }).catch((err)=>{
        console.error(err)
        worker.postMessage({type:"serverStartText", text:"Error loading definitons", tip:"Please reload the page and try again"})
      })
    break;
    /*case "startServer":
      worker.postMessage({type:"serverStartText", text:"Loading definitions...", tip:"This usually takes time because Eternia has LOTS of tanks"})
      roomManager = new WebSocket("wss://eternia-room-manager.glitch.me")
      roomManager.onopen = ()=>{
        roomManager.binaryType = "arraybuffer"
        let data = new Uint8Array(2);
        data[0] = 1;
        data[1] = 5;
        console.log("Opened WebSocket")
        setTimeout(()=>{roomManager.send(data)
        console.log("Sent Definitions Request...")}, 1000)
      }
      roomManager.onmessage = (ea) => {
          let [type, subType, e] = workerWindow.getMetaData(ea.data);
          defData = workerWindow.ftDecode(e);
          eval(defData[0])
          worker.postMessage({type:"serverStartText", text:"Starting server...", tip:"The game will start shortly"})
          startServer(data.server.suffix, data.server.gamemode, defExports)
        }
      worker.roomManager = roomManager
      
    break;
    case "oldStartServer":
      worker.postMessage({type:"serverStartText", text:"Loading definitions...", tip:"This usually takes time because Eternia has LOTS of tanks"})
      fetch("https://eternia-room-manager.glitch.me/definitions.js", {
        mode: 'no-cors'
      }).then((res)=>{
        if(!res.ok){
          worker.postMessage({type:"serverStartText", text:"Error loading definitons", tip:"Please reload the page and try again"})
          console.error(res)
          return;
        }
        return res.text()
      }).then((defData)=>{
        eval(defData)
        worker.postMessage({type:"serverStartText", text:"Starting server...", tip:"The game will start shortly"})
        startServer(data.server.suffix, data.server.gamemode, defExports)
      }).catch((err)=>{
        console.error(err)
        worker.postMessage({type:"serverStartText", text:"Error loading definitons", tip:"Please reload the page and try again"})
      })
    break;*/
    case "serverMessage":
      userSockets.get(data.data.shift()).onmessage(data.data[0])
    break;
    case "playerJoin":
      workerWindow.sockets.connect(data.playerId)
    break;
    case "playerDc":
      userSockets.get(data.playerId).close()
      userSockets.delete(data.playerId)
    break;
    case "playerToken":
      if (!c.NO_TOKENS) {
      let player = userSockets.get(data.playerId)
      player.betaData.permissions = data.token
      }
    break;
  }
}

function userSocket(playerId){
  return {
    on: (type, funct) => {
      if(type === "message"){
         userSockets.get(playerId).onmessage = funct
      }
    },
    send: (e)=>{
      worker.postMessage({type:"clientMessage", playerId:playerId, data:e})
    }
  }
};

(function(){
const u32 = new Uint32Array(1),
    c32 = new Uint8Array(u32.buffer),
    f32 = new Float32Array(u32.buffer),
    u16 = new Uint16Array(1),
    c16 = new Uint8Array(u16.buffer);
/*let getMetaData = function(u8arr){
    u8arr = new Uint8Array(u8arr);
    if(u8arr[1] === 255){
      let str = "";
      let i = 2;
      while(u8arr[i] !== 0){
        str += String.fromCharCode(u8arr[i++]);
      }
      return [u8arr[0], str, u8arr.slice(i+1)]
    }
    return [u8arr[0], u8arr[1], u8arr.slice(2)]
  }*/
let encode = function(message) {
    let headers = [],
        headerCodes = [],
        contentSize = 0,
        lastTypeCode = 0b1111,
        repeatTypeCount = 0;
    for (let block of message) {
        let typeCode = 0;
        if (block === 0 || block === false) typeCode = 0b0000;
        else if (block === 1 || block === true) typeCode = 0b0001;
        else if (typeof block === "number") {
            if (!Number.isInteger(block) || block < -0x100000000 || block >= 0x100000000) {
                typeCode = 0b1000;
                contentSize += 4;
            } else if (block >= 0) {
                if (block < 0x100) {
                    typeCode = 0b0010;
                    contentSize++;
                } else if (block < 0x10000) {
                    typeCode = 0b0100;
                    contentSize += 2;
                } else if (block < 0x100000000) {
                    typeCode = 0b0110;
                    contentSize += 4;
                }
            } else {
                if (block >= -0x100) {
                    typeCode = 0b0011;
                    contentSize++;
                } else if (block >= -0x10000) {
                    typeCode = 0b0101;
                    contentSize += 2;
                } else if (block >= -0x100000000) {
                    typeCode = 0b0111;
                    contentSize += 4;
                }
            }
        } else if (typeof block === "string") {
            let hasUnicode = false;
            for (let i = 0; i < block.length; i++) {
                if (block.charAt(i) > "\xff") hasUnicode = true;
                else if (block.charAt(i) === "\x00") {
                    console.error("Null containing string!", block);
                    throw new Error("Null containing string!");
                }
            }
            if (!hasUnicode && block.length <= 1) {
                typeCode = 0b1001;
                contentSize++;
            } else if (hasUnicode) {
                typeCode = 0b1011;
                contentSize += block.length * 2 + 2;
            } else {
                typeCode = 0b1010;
                contentSize += block.length + 1;
            }
        } else {
            console.error("Unencodable data type!", block);
            console.log(JSON.stringify(message), message.indexOf(block))
            throw new Error("Unencodable data type!");
        }
        headers.push(typeCode);
        if (typeCode === lastTypeCode) repeatTypeCount++;
        else {
            headerCodes.push(lastTypeCode);
            if (repeatTypeCount >= 1) {
                while (repeatTypeCount > 19) {
                    headerCodes.push(0b1110);
                    headerCodes.push(15);
                    repeatTypeCount -= 19;
                }
                if (repeatTypeCount === 1) headerCodes.push(lastTypeCode);
                else if (repeatTypeCount === 2) headerCodes.push(0b1100);
                else if (repeatTypeCount === 3) headerCodes.push(0b1101);
                else if (repeatTypeCount < 20) {
                    headerCodes.push(0b1110);
                    headerCodes.push(repeatTypeCount - 4);
                }
            }
            repeatTypeCount = 0;
            lastTypeCode = typeCode;
        }
    }
    headerCodes.push(lastTypeCode);
    if (repeatTypeCount >= 1) {
        while (repeatTypeCount > 19) {
            headerCodes.push(0b1110);
            headerCodes.push(15);
            repeatTypeCount -= 19;
        }
        if (repeatTypeCount === 1) headerCodes.push(lastTypeCode);
        else if (repeatTypeCount === 2) headerCodes.push(0b1100);
        else if (repeatTypeCount === 3) headerCodes.push(0b1101);
        else if (repeatTypeCount < 20) {
            headerCodes.push(0b1110);
            headerCodes.push(repeatTypeCount - 4);
        }
    }
    headerCodes.push(0b1111);
    if (headerCodes.length % 2 === 1) headerCodes.push(0b1111);
    let output = new Uint8Array((headerCodes.length >> 1) + contentSize);
    for (let i = 0; i < headerCodes.length; i += 2) {
        let upper = headerCodes[i],
            lower = headerCodes[i + 1];
        output[i >> 1] = (upper << 4) | lower;
    }
    let index = headerCodes.length >> 1;
    for (let i = 0; i < headers.length; i++) {
        let block = message[i];
        switch (headers[i]) {
            case 0b0000:
            case 0b0001:
                break;
            case 0b0010:
            case 0b0011:
                output[index++] = block;
                break;
            case 0b0100:
            case 0b0101:
                u16[0] = block;
                output.set(c16, index);
                index += 2;
                break;
            case 0b0110:
            case 0b0111:
                u32[0] = block;
                output.set(c32, index);
                index += 4;
                break;
            case 0b1000:
                f32[0] = block;
                output.set(c32, index);
                index += 4;
                break;
            case 0b1001: {
                let byte = block.length === 0 ? 0 : block.charCodeAt(0);
                output[index++] = byte;
            }
            break;
            case 0b1010:
                for (let i = 0; i < block.length; i++) output[index++] = block.charCodeAt(i);
                output[index++] = 0;
                break;
            case 0b1011:
                for (let i = 0; i < block.length; i++) {
                    let charCode = block.charCodeAt(i);
                    output[index++] = charCode & 0xff;
                    output[index++] = charCode >> 8;
                }
                output[index++] = 0;
                output[index++] = 0;
                break;
        }
    }
    return output;
};
let decode = function(packet) {
    let data = new Uint8Array(packet);
    if (data[0] >> 4 !== 0b1111) return null;
    let headers = [],
        lastTypeCode = 0b1111,
        index = 0,
        consumedHalf = true;
    while (true) {
        if (index >= data.length) return null;
        let typeCode = data[index];
        if (consumedHalf) {
            typeCode &= 0b1111;
            index++;
        } else typeCode >>= 4;
        consumedHalf = !consumedHalf;
        if ((typeCode & 0b1100) === 0b1100) {
            if (typeCode === 0b1111) {
                if (consumedHalf) index++;
                break;
            }
            let repeat = typeCode - 10;
            if (typeCode === 0b1110) {
                if (index >= data.length) return null;
                let repeatCode = data[index];
                if (consumedHalf) {
                    repeatCode &= 0b1111;
                    index++;
                } else repeatCode >>= 4;
                consumedHalf = !consumedHalf;
                repeat += repeatCode;
            }
            for (let i = 0; i < repeat; i++) headers.push(lastTypeCode);
        } else {
            headers.push(typeCode);
            lastTypeCode = typeCode;
        }
    }
    let output = [];
    for (let header of headers) {
        switch (header) {
            case 0b0000:
                output.push(0);
                break;
            case 0b0001:
                output.push(1);
                break;
            case 0b0010:
                output.push(data[index++]);
                break;
            case 0b0011:
                output.push(data[index++] - 0x100);
                break;
            case 0b0100:
                c16[0] = data[index++];
                c16[1] = data[index++];
                output.push(u16[0]);
                break;
            case 0b0101:
                c16[0] = data[index++];
                c16[1] = data[index++];
                output.push(u16[0] - 0x10000);
                break;
            case 0b0110:
                c32[0] = data[index++];
                c32[1] = data[index++];
                c32[2] = data[index++];
                c32[3] = data[index++];
                output.push(u32[0]);
                break;
            case 0b0111:
                c32[0] = data[index++];
                c32[1] = data[index++];
                c32[2] = data[index++];
                c32[3] = data[index++];
                output.push(u32[0] - 0x100000000);
                break;
            case 0b1000:
                c32[0] = data[index++];
                c32[1] = data[index++];
                c32[2] = data[index++];
                c32[3] = data[index++];
                output.push(f32[0]);
                break;
            case 0b1001: {
                let byte = data[index++];
                output.push(byte === 0 ? "" : String.fromCharCode(byte));
            }
            break;
            case 0b1010: {
                let string = "",
                    byte = 0;
                while ((byte = data[index++])) string += String.fromCharCode(byte);
                output.push(string);
            }
            break;
            case 0b1011: {
                let string = "",
                    byte = 0;
                while ((byte = data[index++] | (data[index++] << 8))) string += String.fromCharCode(byte);
                output.push(string);
            }
            break;
        }
    }
    return output;
};
workerWindow.ftEncode = encode;
workerWindow.ftDecode = decode;
//workerWindow.getMetaData = getMetaData;
})();





// MORE COMPAT //
function oddify(number, multiplier = 1) {
  return number + ((number % 2) * multiplier);
}
workerWindow.mapConfig = {
    getBaseShuffling: function (teams, max = 5) {
        const output = [];
        for (let i = 1; i < max; i++) {
            output.push(i > teams ? 0 : i);
        }
        return output.sort(function () {
            return .5 - Math.random();
        });
    },

    id: function (i, level = true, norm = false) {
        if (i) {
            return !!level ? `n_b${i}` : `bas${i}`;
        } else if (norm) {
            return "norm";
        } else {
            const list = ["rock", "rock", "roid", "norm", "norm"];
            return list[Math.floor(Math.random() * list.length)];
        }
    },

    oddify: oddify,

    setup: function (options = {}) {
        if (options.width == null) options.width = 18;
        if (options.height == null) options.height = 18;
        if (options.nestWidth == null) options.nestWidth = Math.floor(options.width / 4) + (options.width % 2 === 0) - (1 + (options.width % 2 === 0));
        if (options.nestHeight == null) options.nestHeight = Math.floor(options.height / 4) + (options.height % 2 === 0) - (1 + (options.width % 2 === 0));
        if (options.rockScatter == null) options.rockScatter = .175;
        options.rockScatter = 1 - options.rockScatter;
        const output = [];
        const nest = {
            sx: oddify(Math.floor(options.width / 2 - options.nestWidth / 2), -1 * ((options.width % 2 === 0) && Math.floor(options.width / 2) % 2 === 1)),
            sy: oddify(Math.floor(options.height / 2 - options.nestHeight / 2), -1 * ((options.height % 2 === 0) && Math.floor(options.height / 2) % 2 === 1)),
            ex: Math.floor(options.width / 2 - options.nestWidth / 2) + options.nestWidth,
            ey: Math.floor(options.height / 2 - options.nestHeight / 2) + options.nestHeight
        };

        function testIsNest(x, y) {
            if (options.nestWidth == 0 || options.nestHeight == 0) {
                return false;
            }
            if (x >= nest.sx && x <= nest.ex) {
                if (y >= nest.sy && y <= nest.ey) {
                    return true;
                }
            }
            return false;
        }
        for (let i = 0; i < options.height; i++) {
            const row = [];
            for (let j = 0; j < options.width; j++) {
                row.push(testIsNest(j, i) ? "nest" : Math.random() > options.rockScatter ? Math.random() > .5 ? "roid" : "rock" : "norm");
            }
            output.push(row);
        }
        return output;
    }
}

workerWindow.require = function(thing){
    switch(thing){
        case "../../lib/util.js":
        case "./util.js":
        case "./lib/util":
            let angleDifference = (() => {
                    let mod = function(a, n) {
                        return (a % n + n) % n;
                    };
                    return (sourceA, targetA) => {
                        let a = targetA - sourceA;
                        return mod(a + Math.PI, 2 * Math.PI) - Math.PI;
                    };
                })()
            let deepClone = (obj, hash = new WeakMap()) => {
                    let result;
                    // Do not try to clone primitives or functions
                    if (Object(obj) !== obj || obj instanceof Function) return obj;
                    if (hash.has(obj)) return hash.get(obj); // Cyclic reference
                    try { // Try to run constructor (without arguments, as we don't know them)
                        result = new obj.constructor();
                    } catch (e) { // Constructor failed, create object without running the constructor
                        result = Object.create(Object.getPrototypeOf(obj));
                    }
                    // Optional: support for some standard constructors (extend as desired)
                    if (obj instanceof Map) Array.from(obj, ([key, val]) => result.set(deepClone(key, hash), deepClone(val, hash)));
                    else if (obj instanceof Set) Array.from(obj, (key) => result.add(deepClone(key, hash)));
                    // Register in hash
                    hash.set(obj, result);
                    // Clone and assign enumerable own properties recursively
                    return Object.assign(result, ...Object.keys(obj).map(key => ({
                        [key]: deepClone(obj[key], hash)
                    })));
                }
            let time = () => {
                    return Date.now() - serverStartTime;
                }
            let formatTime = x => Math.floor(x / (1000 * 60 * 60)) + " hours, " + Math.floor(x / (1000 * 60)) % 60 + " minutes and " + Math.floor(x / 1000) % 60 + " seconds"
            let getLogTime = () => (time() / 1000).toFixed(3)
            let serverStartTime = Date.now();
            let formatDate = function(date = new Date()) {
                    function pad2(n) {
                        return (n < 10 ? '0' : '') + n;
                    }
                    var month = pad2(date.getMonth() + 1);
                    var day = pad2(date.getDate());
                    var year = date.getFullYear();
                    return [month, day, year].join("/");
                }
            return {
                addArticle: function(string, cap = false) {
                    let output = (/[aeiouAEIOU]/.test(string[0])) ? 'an ' + string : 'a ' + string;
                    if (cap) {
                        output = output.split("");
                        output[0] = output[0].toUpperCase();
                        output = output.join("");
                    }
                    return output;
                },
                getLongestEdge: function getLongestEdge(x1, y1, x2, y2) {
                    let diffX = Math.abs(x2 - x1),
                        diffY = Math.abs(y2 - y1);
                    return diffX > diffY ? diffX : diffY;
                },
                getDistance: function(vec1, vec2) {
                    const x = vec2.x - vec1.x;
                    const y = vec2.y - vec1.y;
                    return Math.sqrt(x * x + y * y);
                },
                getDirection: function(p1, p2) {
                    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
                },
                clamp: function(value, min, max) {
                    return value > max ? max : value < min ? min : value;
                },
                lerp: (a, b, x) => a + x * (b - a),
                angleDifference: angleDifference,
                loopSmooth: (angle, desired, slowness) => {
                    return angleDifference(angle, desired) / slowness;
                },
                deepClone: deepClone,
                averageArray: arr => {
                    if (!arr.length) return 0;
                    var sum = arr.reduce((a, b) => {
                        return a + b;
                    });
                    return sum / arr.length;
                },
                sumArray: arr => {
                    if (!arr.length) return 0;
                    var sum = arr.reduce((a, b) => {
                        return a + b;
                    });
                    return sum;
                },
                signedSqrt: x => {
                    return Math.sign(x) * Math.sqrt(Math.abs(x));
                },
                getJackpot: x => {
                    return (x > 26300 * 1.5) ? Math.pow(x - 26300, 0.85) + 26300 : x / 1.5;
                },
                serverStartTime: serverStartTime,
                time: time,
                formatTime: formatTime,
                getLogTime: getLogTime,
                log: text => {
                    console.log('[' + getLogTime() + ']: ' + text);
                },
                info: text => {
                    console.log('[' + getLogTime() + ']: ' + text);
                },
                spawn: text => {
                    console.log('[' + getLogTime() + ']: ' + text);
                },
                warn: text => {
                    console.log('[' + getLogTime() + ']: ' + '[WARNING] ' + text);
                },
                error: text => {
                    console.log('[' + getLogTime() + ']: ' + '[ERROR] ' + text);
                },
                remove: (array, index) => {
                    // there is more than one object in the container
                    if (index === array.length - 1) {
                        // special case if the obj is the newest in the container
                        return array.pop();
                    } else {
                        let o = array[index];
                        array[index] = array.pop();
                        return o;
                    }
                },
                removeID: function remove(arr, i) {
                    const index = arr.findIndex(e => e.id === i);
                    if (index === -1) {
                        return arr;
                    }
                    if (index === 0) return arr.shift();
                    if (index === arr.length - 1) return arr.pop();
                    return arr.splice(index, 1);
                },
                formatLargeNumber: x => {
                    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                },
                timeForHumans: x => {
                    // ought to be in seconds
                    let seconds = x % 60;
                    x /= 60;
                    x = Math.floor(x);
                    let minutes = x % 60;
                    x /= 60;
                    x = Math.floor(x);
                    let hours = x % 24;
                    x /= 24;
                    x = Math.floor(x);
                    let days = x;
                    let y = '';
                    function weh(z, text) {
                        if (z) {
                            y = y + ((y === '') ? '' : ', ') + z + ' ' + text + ((z > 1) ? 's' : '');
                        }
                    }
                    weh(days, 'day');
                    weh(hours, 'hour');
                    weh(minutes, 'minute');
                    weh(seconds, 'second');
                    if (y === '') {
                        y = 'less than a second';
                    }
                    return y;
                },
                
                formatDate: formatDate,
                
                constructDateWithYear: function(month = (new Date()).getMonth() + 1, day = (new Date()).getDate(), year = (new Date()).getFullYear()) {
                    function pad2(n) {
                        return (n < 10 ? '0' : '') + n;
                    }
                    month = pad2(month);
                    day = pad2(day);
                    year = year;
                    return [month, day, year].join("/");
                },
                
                dateCheck: function(from, to, check = formatDate()) {
                    var fDate, lDate, cDate;
                    fDate = Date.parse(from);
                    lDate = Date.parse(to);
                    cDate = Date.parse(check);
                    return cDate <= lDate && cDate >= fDate;
                },
                
                cleanString: (string, length = -1) => {
                    if (typeof string !== "string") {
                        return "";
                    }
                    string = string.replace(/[\u0000\uFDFD\u202E\uD809\uDC2B\x00\x01\u200b\u200e\u200f\u202a-\u202e\ufdfd\ufffd-\uffff]/g, "").trim();
                    if (length > -1) {
                        string = string.slice(0, length);
                    }
                    return string;
                }
            }
        break;
        case "./lib/random":
            const names = ["%t better than Cudgel FR","1/2143 You find me you lucky", "𝕴 𝓵𝓲𝓴𝓮 ʇxǝʇ 𝕗𝕠𝕟𝕥𝕤", "waddafak", "FakePlayer", "Did I ever tell you what the definition of insanity is?", "uhhhhhhhhhhh idfk anymore", "Very Innocent Bot", "wat", "A nameless player", "trust me I don't kill you","1 is equal to 2","0 AM = 12 PM","No idea.","That one guy","The Speedster","Imfastasfboi","I can solo a pentagon.","Die and retry me.","thanks 4 free score.","Redkystribustion","Red, don't read this.","const names = []","Eternals are eternal?","Eternia is Eternal?","What is reality?","Bet you don't know who I am","I can do 1+1","You kill me = me sad :c","I misstupe averything","I ate too much burgers","Tactical Fat Nuke","Social Political Enconomical Threat.","its Big brain time","life is not hard if you're dead","give me money.","I dodge everything","Deutshe qualität server","Yes, Milk!","German Homeworks","Ich liebe les pommes","./lib/random","Je parle français mec","If you ever see a %t in the wild you know its me","kill me = me die","eat_those_bullets","spamspamspamspam","How play","Rickroll'd","Satan","Air Conditioner","avg lifetime = 3secs","/pkill AI","Ryo","I can revenge.","Deeply Good Person.","My aim is godly.","I have 2% battery","Supermen","I am SUPERMAN","You that read wrong.","You forgot to breathe.","I can't breathe","%t demo","FBI Spy","I speak only UK","mine englishs are goud","Skill Issue in plural","Baguette 🥖🇫🇷","Musikale 🎵","🐢","Stay with me or else...","Musicalement => ._.","Advanced Bot","I had 1B NOOOOO","Your Cat","%t","~ñ~","Who uses %t in 2024?","plz pet me","I am mighty.","I can choose a long name if I want because I am a bot LOL so I do so heheh. :p","1/1253 I am named like that","sugar cane","No one can beat me XDXD","So, You read this huh?","This is a joke.","ChatGPS","We live in a simulation","Blueky","Reeeedky","Musikale","UnderratedBot","Not a %t","Eternia","POV: you missclick %t","%t spam gang","%t on top!","%t is underrated","%t it 2 weak","Eat my bullet","I was born with %t so idk","That Guyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy", "SOMEONE", "꧁༺𝓘𝓷𝓼𝓪𝓷𝓲𝓽𝔂༻꧂", "🅸 🅰🅼 🅶🅾🅳", "I", "jaffa calling", "Ill Tear your eyes out..", "Me-arac", "Aniketos", "🌌Miñe🌌", "ℭ𝔬𝔣𝔣𝔢𝔢", "Akilina", "Mythical", "exc", "=", "o o o o o o o o", "!!!", "Lixeiro do mal", "Thanks M8", "Frost? Mobile", "Dream", "We Do A Little Trolling", "earth", "NightFire", "Free to insult", "dino", "AMOGUS??????????????", "bruh", "No Surviors", "<[AXS]> RASHOT", "Pizza Bread", "[lag]Armando", "Gay Overlord", "willim", "Everything RAM Mobile", "General", "H̵͊̕ė̵̮l̷͎̈́l̵̅͛ơ̸͊", "{WOF} Nightwing", "footeloka", "[⚔️wiki]₵₳V₳ⱠłɆⱤ", "Jes;/;ter", "Team Boom", "🖤ISAAC🖤", "naruto", "занято42/Busybody42", "A+", "Raul39", "team protect", "i will troll :D", "heroy_105", "[FBI]Σvi₺ℭℏἏ❀₴#1628", "BigBadBoom", "nope", "glurip", "ffk the desrtroy", "Spin=Team", "comrade", "Alkali", "Impact of TY-77", "😈Stormys Domain😈", "YOUR BAD = YOUR DEAD!!!", "pushmetothe sancuary", "Im not a tank", "Snow", "Hm", "DanceTillYou'reDead", "gmonster", "Die!!!", "developer", "noob", "zX-TwinChilla-Xz", "[BK] [XC] PAKISTAN", "Bryson", "Musa♗ - The Shipwrecker", "bob", "Mothership Drone", "t-rex vs raptor", "mai", "Arisu", "gamer.io", "RİKKET FAN", "FOLLOW ME OCTO TANKS", "XP_Toxic_CJS", "TV", "constructor", "among us", "jkl", "XP_Toxic_CST", "d", "I love nahu", "Spade", "XxNicolas GamerxX", "xAd_rian", "FabianTu", "Eminx", "max", "OOOOOOOOFfffffffffffffff", "WalleeE", " KA2", "MIKE", "pedro :(", "BEDROCK", "Frostbite#6915", "koishi", "eu tenho a melhor mae^-^", "asdfghjkl;:]@ouytrewq", "😎👿david988😎👿", "Zaphkiel", "tryhard mode on !!!!!!!", "⚰️🔥👻WITNESS ME👻🔥⚰️", "[Σϰ][Ωϰ] ...", "That Guy", "Aniketos", "Play wommy-arras.io", "ARMADA", "// jAX", "🔱Ƒιяєωσяк🚫", "DEATH TO TEAMERS", "Milan", "your worst lightmare", "XxshadowxX Ilove u", "Alkaios", " 🥧π🥧", "🔱 𝓽𝓲𝓶𝓮𝓽𝓸𝓭𝓲𝓮 🚫", "Can u see me? :D", "Apollon", "ok", "Crazyattacker9YT", "XtremeJoan", "cz sk", "give me your butt dude", "[🌀]Brain𝐼nHalf", "Hexagon Temple", "-_-", "You", "CACA", "Athena", "Artemis", "DOEBLE TOP!", "the only one", "hi (original)", "SOMEONE", "can you beat me smashey", "s7ㅋㅋㅋ", "pika :P", "Fallen", "Big Papa", "m̸̐̽ᵃ𝔭ʟₑ౪🌸🎀🌺🌷🩰🧁", "GONIALS", "прівіт", "lnwZa007", "🐸🐌【HapPy】", "Daluns the one?", "CAMALEON", "factory not op :(", "/BIG BOYRockety", "circus of the dead", "𝒮𝔭00𝔡𝔢𝔯𝔪𝔞𝔫", "hackercool", "🔱⨊ $؋₲₥₳🚫", "Go Away", "Protector Of Worlds", "me", "vn", "RAHAN", "........................", "Soviet Union", "Flash", "❰𝞑𝞡𝞣❱ 𝝙𝝼𝝴𝝶𝘂𝝴", "🌌Miñe🌌", "King Pikachu", "EzzeKiel", "h", "Homeless man", "Asdfghjkjjhgfdsdfghjhgfd", "Felchas", "starwarrior", "Spin=Team", "TERA BAAP✿AYA★💓Bhagwanmr noob", "Dream", "DIEGO", "Lagmat YT = 🎷 channel", "be dum like me", "lagg", "APplayer113", "tiky", "🇧🇷HUE🇧🇷", "am low, I Need Backup!", "Thunder(Tapenty)", "Beeg Yoshi Squad", "reeeeeeee", ";]", "Arena Closer", "abd lhalim", "Badaracco", "emir", "Türk  polisi", "Paladin", "stop plz", "d", "[AI] Kidell", "dan", "I am milk", "Türk'ün Gücü Adına🌸", "҉s҉h҉u҉n҉a҉", "Teuge", "Dave", "abbi_alin", "im a joke", "huy vn :D", "🌊🦈🌊", "scortt reach 1m friend", "ET", "vlasta", "𝒰𝒞ℋİℋ𝒜", "Nyroca", "German", "[ɨƙ]ɳøʘɗɫɚ", "I'm so lag(sinbadx)", "🇸🇦", "asdf", "X℘ExͥplͣoͫຮᎥveﾂ✔", "Apollon", "^^", "I", "natasha", "no me mates amigos", "dáwsda", "FEWWW....", "lol", "A team with 💚 is doomed", "Raul39", "Noob AC", "ddqdqwdqw", "[MG] GLITCH TR", "LemonTea", "Party_CZE", "Diep_daodan", "What?", "kuro", "cute pet", "demon", "ALEXANDER👑💎", "Cursed", "copy The tank", "", "dsa.", "Vinh HD", "Mago", "hi bestie", "avn", "d", "naruto", "ARRASMONSTER KILLYOUha5x", "MICAH", "Jotaro", "king vn", "𝕰𝖓𝖊𝖒𝖞_𝕯𝖔𝖌", "Raoof", "Leviathan", "SUN", "❬☬❭  ⚜️Ð𝐙𝕐 ッ 〜 🌷", "FALLEN SWORD", "🇧🇷HUE🇧🇷", "BoyFriend [FnF]", "motherhip", "𝓼𝓮𝓻𝓲𝓸𝓾𝓼𝓵𝔂", "lolera", "Dark Devil", "press F", "Detective Conan", "Pet", "MAICROFT", "Holy", "IXGAMËSS", "h", "umm,dab?", "Ihavelocty", "ewqasd2021vinicius", "[🇻🇳] Hùng", "I Love you", "Healer", "hacker lololololol", "boooster.io", "dscem", "bibi", "TEAM POLICE", "", "jj", "SHARK", "arena closer", "•长ąϮëąℓ⁀ᶜᵘᵗᵉ╰ ‿ ╯ ☂", "Weяw𝕖𝐑ώ€я𝓺q2️⃣prankeo", "nani?", "OTTOMAN EMPİRE", "------------------------", "kr9ssy", "not P", "winnner", "friendly",
             "genocide BBB", "HI", "I'm poor:(fortnine duo", "JSABJSAB", "jmanplays", "starwarrior", "were", "PLAYER", "mothership protrector 1", "Gamer🎮", "6109", "PRO", "enr", "_____P___E___N___E______", "annialator", "kaio", "(bro)", "Arras.io", "...", "Denied", "Paladin", "Zaphkiel", "Pikachu ^~^", "Steve", "{<:Void", "AƓ Aηgєℓ#Use AƓ  Tag", "Amyntas", "⁄•⁄ω⁄•⁄卡比獸🖤", "poui", "PH - r҉a҉i҉n҉", "A M O U G U S", "idk bro", "Artemis", "Hey team", "b T規RㄩIes矩W ˋ*ˊd", "한국 Lime Lemon", "phong fan vn!", "me fan valt shu lui free", "Mobile no work", "Hi 香港😘> pls don't kill�", "[/G]/O1D SL/Y3R", "mil leches", "Major Meowzer YT", "Providence", "Lore", "ОХОТНИК", "vordt", "Linghtning McQueen", "Pentagon Nest Miner", "꧁☬☬😈꧁꧂ ☠HARSH ☠꧁꧂😈 ☬☬꧂", "vovotthh", "Nope :))", "||||||||||||||||||||||||", " ꧁ℤ𝕖𝔱𝔥𝔢𝔯𝔫𝕚𝕒꧂", "CTRL+W=godmode(viet nam)", "🔱LordΛภ𝓰𝖑Ɇ🚫", "1 + 1 = 3", "XYZ", "[PFF][|| ı'ɱ ცąცყ||]", "Boop", "RAPTURE", "o", "/.//.[]", "", "Roskarya", "no. 9", "Lost MvP#7777", "Jon", "🔱Saint LilY⚜🚫", "Green.grey.purple.blue.", ":P", "C - 4 Spank Spank", "VN", "Snapwingfriendstriker007", "overlord is:):)", " pluss亗", "[Repsaj]ĎąŗĸMãştɛɾ", "Phoenix_Gamer", "Relatively Harmless Tonk", "Array.io", "Spin=Team", "I am your shield :)", "j", "1", "TheBasil", "【The L1litle One】", "X.Clamator .YT", "ENDERMÉN", "CC", "BEST", "Among Us", "lobo", "asky", "Opan Come Go Note Yeah", "Bowler", "ad", "haha bowler no 1M", "Tin", "[GZ]GESETA", "woomy arras.io", "Remuru Tempest", "PvPok", "Scarlet Rage(mobile)", "nam", "STRIKER007", "[VN] MeltedGirl", "100000000000000000000000", "eee", "Q", "mắm tôm", "REVENGE✨", "Achi", "AC Perú", "bvnfgh", "hi", "Cutee Pet", "little bitch", "khang", "lets be freinds guys!!!!", "sans pro", "phantanduy", "[AC] VGamerZ", "StevenUniverseFan", "azen", "Waffles", "jesian", "Ⱬł₭Ɽł₮₳Ӿ", "Gay Overlord", "pikachuboi124", "mundo x bomb", "ducky", "🌀DESTROYER🌀", "Stupid Overlord", "++", "phantantri", "VoteOutRacists", "Denied", "floof", "Bowler", "Sinbadx", "🎈IT🎈 APOCOLYPSE", "ExpectMe2BeDeadCuzOfLag", "Damage", "Aniketos", "⨝∑₮ξ₹ͶΛL⨝", "Artemis", "_", "Archimedes", "♪KING♫♕-dev#3917", "no", "Doofus", "MINI defender", "꧁✯[🕋]MÂRSHMÆLLØW 𖣘✯꧂", "Alkaios", "(・ω・＼)i am(/・ω・)/pinch!", "Việt Cường 2A5", "I Love you", "fdsmn", "!", "R", "you shall not pass!!", "harmless shower", "lol", "Mythical", "oath sign", "finland", "bob", "hetman666", "lio", "VN~I LoVe You Chu Ca Mo", "Your mom", "Friendly", "the protector", "leave me alone pls", "Grill my flippen butt", "n o i c e", "bo", "onsen", "._.", "Frostbite#6915", "💞", "CTRL+W=godmode", "noob", "ad", "Soviet Union", "be freind", "   HCM MUÔN NĂM", ":P", "FALLEN SWORD", "anh tuấn anh nè tôm", "fnf is a poop", "Zp r oZ", "꧁҈$ꫀꪖ  ,҉ℭն𝚌մꪑ𝜷ꫀ᥅ ༻", "VN:P", "margaret thatcha", "[VN]Ảo Vãi Lồn🤔", "ㅋㅋㄹㅃㅃ", "pin h 3", "Vỹ đẹp zai", "Snapwingfriendstriker007", "everybodybecomespike", "a", "1", "vyde", "Mothership Drone", "op", "click 'F'", "Noob", "🐰chiro🐰", "PJfd13", "CELESTIAL", "Team", "Cute Tortoise", "FeZTiVAL", "anime", "t", "C - 4 Spank Spank", "Rockety", "Valley", "Im New,dont kill me pls", "Friends?", "하이루", "KILL ME I DARE YOU", "pet basic -(======>", "pet", "♕ ❤VIỆT NAM ❤♕", "team ?", "꧁༒☬✞😈VîLLãñ😈✞☬༒ ꧂", "Công", "Opan Come Go Note Yeah", "1 + 1 = 3", "Elite Knigh*", "vn{CHP}", "Dasher8162", "Xlo-250", "under_gamer092", "VN", "Mtp tv tiktoker", "Denied", "Paladin", "『YT』Just𝕸𝖟𝖆𝖍ヅ", "shame", "Corrupt Y", "spin= team", "Please no more Y team", "Syringe", "Pickerel Frog", "Bitter Dill", "Your Triggering Me 🤬", "117", "FleRex", "Archimedes", "Neonlights", "🌌Miñe🌌", "〖-9999〗-҉R҉e҉X҉x҉X҉x҉X҉", "FEWWW....", "bob", "0800 fighter¯_(ツ)_/¯", "◯ . ◯⃨̅", "𝕁𝕖𝕤𝕥𝕖𝕣", "Apollon", "Ɓṏṙḕd Ṗläÿệŕ {✨}", "i never bin 1 mill", "残念な人", "KillerTMSJ", "Дракон", "[VN]Ảo Vãi Lồn🤔", "😎", "warrion", "ARMADA", "asd", "alr-ight", "AAAAAAAAAAAAAAAAAAAAAAAA", "♣☆  ⓂⒶ𝓻s𝐇Ⓜ𝔼𝕝ᒪσω  ☯♚", "FREJEA CELESTIAL 1.48MXyn", "poker 567", "C", "4tomiX", "meliodas", "Việt Cường 2A5", "(ZV) foricor", "", "Marxtu", "me?? 😢", "m̸̐̽ᵃ𝔭ʟₑ౪🌸🎀🌺🌷🩰🧁", "PeaceKeeper", "Eeeeeeva", "diện", "[MM]  Ⓕ𝓸𝓻𝓫𝓲𝓭𝓭𝓮𝓷", "Doofus", "TS/RRRR", "Nothing.", "🐶(X)~pit¥🐺te matare jajaja", "⌿⏃⋏⎅⏃", "go", "[PFF][|| ı'ɱ ცąცყ||]", "hola", "polyagon", "Galactic slush", "9999999999999999999999dx", "zaphkiel celestial", "noob", "$$$%$la plaga$%$$$", "Sorry broh", "Roberto", "EHSY BAAA", "Nnmnnnmmmnmmmm", "use fighter plsss :)", "Mini", "spitandsteelfriend", ";)", "lol", "Mobile player", "the ultimate multitool", "i vow to protect", "oofania", "hi", "why am i here", "H̵͊̕ė̵̮l̷͎̈́l̵̅͛ơ̸͊", "A.L.", "Hi", "ONE SHOT", "luis", "saitan", "Felchas", "Im gonna knock you out", "Aquiles TEAM LOVE", "qwertyuiop", ";-;","diep.io", "invisible drones", "team plz:(", "DIONAX", "again and again", "100000000000000000000000", "nicolas123", "JESUS E AMOR", "Alice", "Bob", "Carmen", "David", "Edith", "Freddy", "Gustav", "Helga", "Janet", "Lorenzo", "Mary", "Nora", "Olivia", "Peter", "Queen", "Roger", "Suzanne", "Tommy", "Ursula", "Vincent", "Wilhelm", "Xerxes", "Yvonne", "Zachary", "Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Hotel", "India", "Juliet", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-Ray", "Yankee", "Zulu", "The Bron Jame", "[MG] Team", "team??!", "trump", "facu++", "TEST", "Jake", "PEST_YT", "GOKU", "big me!", "arras > diep", "k", "[MG] PRO TEAM",
             "Solomon", "novice", "noob", "Angel", "😈", "max", "Allah Is King", "dont touch me", "leonardo", "colombia", "", "Friends ? ", "✈", "Kim Jong-Un", "1", "An unnamed player", "agar.io", "road to 1m", "FEED ME", "DOGE", "GABE", "boi", "[GZ] team", "buff arena closer", ".", "Ramen", "SPICY RAMEN", "Jera", "[insert creative name]", "Rake", "arras.io", "KOA", "die", "king of diep", "Hagalaz", "Ehwaz", "Dagaz", "Berkanan", "Algiz", "Blank", "Mango", "TOUCAN", "Bee", "Honey Bee", "oof", "Toast", "Captian", "Alexis", "FeZTiVAl", "kitten", "Derp", "Gabogc", "U S A", "name", "[IX] clan", "LOL", "ur mom", "llego el pro!", "Impeach Trump", "luka modric", "bob", "MATRIX", "no", "e", "kek", "read and u gay", "Decagon?", "take this L", "mm", "Aleph Null", "summoner", "T-REX", "buff basic", "stink", "jumla", "no team Kill", "pet", "V", "Broccoli", "toon", "Sinx", "JTG", "Hammer", " ", "Basic", "Discord", "NO WITCH-HUNTING", "salty", "CJ", "angel", "a salty discord kid", "satan", "NoCopyrightSounds", "Am I Sinbadx?", "AHHHHHH!", "rush", "squirt", "AMIGOS", "Windows 98", "FeZTivAL", "illuminati", "Fallen Bot", "Anonymous", "koala", "iXPLODE", ":D", "BrOBer The Prod", "Oh W", "O_O", "I am just pixels", "Alpha", "TheFatRat", "kokak", "D:", "YouRIP", "WOOT", "𝕯𝖆𝖙 𝕺𝖓𝖊 𝕭𝖔𝖎", "hell", "Y", "why", "Lucas", "LOCO", "FeZTi Fan", "0", "AK-47", "Friend pls", "cool", "NO U", "hmst", "Sub 2 Pewdiepie", "T-Gay", "t-series succs", "Balloon", "CX Fan", "The Nameless", "What?", "Our World of Tanks", "Real AI", "Totally Not A Bot", "...", "Fallen AI", "green square", "Dagaz 2.0", "Internet Explorer", "teamplz", "Paradox", "Fallen Nothing", "developer", "ruler of tanks", "IRS", "king slayer", "sael savage", "Zplit", "CUCK", "Popo", "¡AY PAPI!", "Vogelaj", "Ruthless", "BOMBS AWAY", "im new", "best", ".-.", "dont feed me", "rIsKy", "Brian", "Angel", "Knoz", "Caesar", "Baller", "¿Equipo?", "¡Vamos!", "Road To 10m", "Real Hellcat", "Real Kitty!", "Canada > USA", "A named player", "Tyson", "Slayer", "666", "Nooblet", "M8", "Trans Rights", "Bar Milk", "Jambi", "Elmo is gone", "The Grudge", "Rosetta Stoned", "Lateralus", "Fourty-Six & 2", "Vicarious", "Judith", "Give Me Wings", "The Pot", "look behind you", "Bruh Momentum", "Sucko mode", "ArenaC", "!foO", "Lateralus", "Disposition", "Reflection", "Triad", "Mantra", "The Patient", "Real CreepyDaPolyplanet", "Real Despacit.io", "Mew", "Magikarp", "Real Dark Knight", "ok boomer", "PP Tank", "COPPA Sucks", "meme", "Womp Womp", "W = Team", "Real CX", "Neo", "crasher", "Minecrafter", "King of Pros", "Vanze", "Have mercy...", "Im scary", "cookie", "Liberty Prime", "bruh moment", "Rubrub", "Banarama", "poyo", "Nova", "Creeper, Aw Man", "Theory of Everything", "DJVI", "jotaro kujo", "Faaip de Oiad", "MrBeast", "ForeverBound", "Are you okay?", "BUSTER WOLF", "MJK", "F-777", "Dex Arson", "alpharad", "ORA ORA ORA", "Waterflame", "DJ-Nate", "penguinz0", "#teamtrees", "Electrodynamix", "brogle", "im beef", "Salsa Verde", "The Audacity of this tank", "Joe Mamma", "Red Hot Chili Pepper", "Halal Certified Tank", "Coronavirus", "The Common Cold", "The Flu", "Ight Bro", "Little Red Rocket", "Bruh Monument", "Bruh Monumentum", "Spree", "KING CRIMSON!", "THE WORLD!", "ZA WARUDO!", "taal volcano", "Synth", "Brotherhood of Steel", "Railroad", "A Settlement Needs Your Help", "final destination, fox only", "food", "fezti fan", "FeZtiVaL", "CATS", "Careenervirus", "Dumb", "[AI]", "Insanity", "Steven Universe", "MrBeast Rules", "Oswald Veblen", "how to get testbed?", "Mahlo Cardinal?", "mf=r", "dragons go mlem", "丹†eÐiuϻbee††ℓy†", "TωorᴍaͥHoͣrͫnet", "NoͥteͣwͫoℝthyCสtHeสt", "ᴴᵃⁿʸᵐᵖᶜᵘᵗᵉᴾᵃⁿᵗˢ", "Oᶠectบสlsereedl", "CℓeDⱥiryVⱥiͥήtͣeͫℓ✨", "EyeCⱥnᖙyᖘunᖙeseg", "Witψภclคi", "⫷PนℝeMiͥℝeͣyͫ⫸", "𝓕𝓸𝓵𝓿𝓮𝓞𝓵𝓭𝓳𝓸𝓴𝓮⚔", "⦃φօʂìէìѵҽԱʂէìէմąɾ⦄", "🎻Hiקle𝔶lutקuᖙiѕh", "✐ЯΣΛ爪ΛПΣЦЯΣ", "∉Eᴍiภeภ†Miภa多iho∌", "[M๏ℝec𝔥Muy𝔊๏rᖙØ]", "やlachaҜ𝔢d๖ۣ•҉", "FicบℝneCบʝo", "Jame∂iͥPaͣtͫtψMeℓt", "PℝoͥfuͣsͫeOftsΐ", "Hiภⱥls†MiAlmⱥ", "Cสneͥຮeͣfͫight", "Ŧฬeͥirͣoͫ͢͢͢Tฬin🅺les😎", "VenomoบຮNorτnear", "🎲๖ۣۜƤⱥranAsian𐌁øyz", "StͥedͣiͫรDilrubⱥ", "ᖘiͥŇgͣeͫsτri", "Ac𐍉͢͢͢ᵐᵐSiรcuᵐMum🌼", "⫷EᴍiήentOffec☢ne⫸", "Evalingђteᖙseᖙi", "FoบຮervͥᎥdͣeͫ", "⪓Offigeร℘er⪔", "Vuͥldͣrͫatediesio", "⁅🆂🅴🅽🆂🅸🅱🅻🅴🅰🅽🆃🅴🅽🆂🅸🅾⁆", "Houℝgͥΐcͣaͫr︾", "Doe£🆄lMψSo🆄l😬", "Ǥrel𐍉resit", "𐄡𝒫𝑜𝓉𝑒𝓃𝓉𝒯𝒾𝑒𝓃𐄪", "୨𝔄𝔟𝔫𝔬𝔯𝔪𝔞𝔩𝔄𝔫𝔫𝔞𝔩𝔤𝔞𝔱⪑", "ElfuภΐBΐBαr͢͢͢rel", "Liͥveͣrͫiภgบi", "𝕆𝕗𝕗𝕠𝕦𝕝𝕕𝕠𝕨𝕚𝕥𝕚𝕝⚡", "Na†eℝaŇiŇgs⚠", "𝓗𝓪𝓭𝓭𝓚𝓱𝓪𝓷𝔃𝓲𝓻", "Partℽ𝓌𝔥ᎥꜱᎥภ∂บc", "Aήสℓroseℓ♛", "Aຮiaτinga", "⑉Elͥegͣeͫήτreα⑉", "Inͥ∂eͣlͫψຮtr", "CoϻpePregy", "〖Grͥetͣyͫdrest〗", "⑉S☢mp☢รpͥGuͣmͫp⑉", "丹pสτheτᎥcṨømpⱥthⱥ", "⁣𓆩NօthΣurΣeŇtment", "Ofͥ†eͣnͫcheye", "「FℓuͥttͣeͫriήgItingenv」", "😻SƤ𝔯iήgy🅼orkingɭ", "〖ṨoftOftwTนft〗", "GℝegⱥℝiouຮMeⱥℝee☂", "🏄", "😌CømiภgPoթcorn", "MossfนlthapeᖙyŇ☘", "๖ۣۜ山☢uͥsiͣaͫℓℓeﾂ", "A𝖙hedi🆁on", "✰QนestaΐŇgl✰", "Wⱥsͥ†iͣoͫnfℝou", "｟VoℓคtᎥℓeAtentᎥⱥt｠", "Arninℓץie", "★彡[๖ۣۜƊreคᖙ͢͢͢๖ۣۜƊeωᖙrop]彡★", "JบicץJบnᖙen", "Öµł†µÐï†ê§", "「Ate∂iͥDiͣlͫly๖ۣۜßØo」", "〖Aήthent฿ⱥdbreⱥth〗", "🎹ͲօցìօղժƓմղժ", "᚛VerรeᖙTurรeᖙΐe᚜", "Sקityℝicђe", "❅Camedΐℝ๖ۣۜƊℝedd❅", "IŇeττivie♛", "﹄𝔇𝔬𝔫𝔨𝔢𝔶𝔒𝔠𝔨𝔢𝔡𝔲﹃", "Dousermⱥi∂ﾂ", "彡ΛЯᄂƧΣᄃΛ彡", "⁣𓆩🅰🅳🅼͢͢͢🅸🅽🅴🆆🅴🆁🅴🅽🆃", "AŇergeNeesคnค", "💤Fสή†สຮ†icͥAfͣfͫic", "⌁NaτemacτᎥ⌁", "LΐvͥesͣeͫsChΐℓΐ", "íɑʍOภຮgrⱥigน", "𝓟𝓻𝓸𝓰𝓷𝓲𝔁𝓽𝓾𝓻", "😶ＧｕｔｔｕｒａｌＰｕｔｈｅｒｉｐ", "Ϛageร𐍉HϚ𐍉ℓ☢😇", "𝕹͢͢͢𐍉τempℓeᴀɾ😠", "🚣AՇitℽสrDสrͥinͣgͫ", "༺Hⱥrm๏ni๏us๖ۣۜ山ermisty༻", "CoͥŇeͣrͫŇizαr⚔", "Tormaภτmerΐcaภg", "⦇ƑⱥℓiKi𝖒多๏Ṩℓice⦈", "⚡Uppontork⚡", "C𝓪ge¥W𝓪gencie︾", "彡Ri๏ภt͢͢͢αhαbigiv彡", "😐🅲🆄🆁🅽🅰🅽🅱🅾🅽🅰🅵🅸🅳🅴", "ShⱥŇdΐDΐŇyͥerͣoͫ❥", "EήthHⱥlfPint", "𝕴ภc☢meMสch☢mคn🏀", "๖ۣۜ山Øozץ๖ۣۜ山ome♛",
              "J𐍉viαℓC𐍉vi𐍉", "Exͥamͣiͫckร☢ή", "🌰🆂🅴🅽🅸🅽🅶🅻🆂🅸🆁🅴🅽🅸🆃🅰", "⑉Officђ𐍉uττi⑉", "❅Ju͢͢͢diciøusᖘheสdjur❅", "Ｗｅｄｉｓｐｉｃｈａｖｉｔ▒", "▥Jeสncies†i?", "JohŇiteƤⱥ", "𐐚ewil∂ere∂Ne∂iภ", "ñê§łê§þê🐨", "Rᴇsp☢ήsΐvᴇC☢ήsi", "〖Is†rͥสlͣlͫץpe〗", "L𐍉veCaภdψMaͥภdͣeͫra✨", "F๏นghτsere", "𝕃𝕠𝕘͢͢͢𝕖𝕕𝕦𝕒𝕝𝕚𝕒", "☁Ofเrethe☢", "Aᖙeth☢☢LØυᖙmØυth💌", "CyͥniͣcͫalIntudynt", "CoภsนdBeสภs", "TheͥℝvͣeͫᖙS†aℝveᖙ", "Iτedeຮeded", "♐OfficebᵒℽOffee", "︽CӨ🅽𝔞ℓsoᴍe𝔱tee", "🐯ᎠⱥrlΐภgArҜs🅱ⱥt", "Heͥstͣsͫookerinec", "TaleήtedEήtiรa⚔", "S๏ñcͥifͣeͫ͢͢͢Mนñchie🎤", "JeͥcrͣeͫสCleʝerrℽ", "❅ᴛᴏᴀꜱᴛʏᴀꜱɪᴏɴᴅꜱᴛ❅", "թг๏Ɔoupsoɹʇɥ", "HeaຮΉ𐍉ducҜᴸᴵᶠᴱ", "⁅๖ۣۜƤoeτicViτhic⁆", "S𝒽ⁱlⁱŇgบre", "IfΐeรeŇUŇΐverรe", "Offᖙ🅰𝔶botᴳᵒ", "𝓟𝓸𝓻𝓮𝓽𝔂𝓷𝓽𝓼𝔰𝔲𝔭𝔢𝔯", "𝓗𝓮𝔂𝓸𝓗𝓸𝓷𝓮𝔂𝓬𝓪𝓴𝓮🎨", "ƤlคץรChⱥή∂☢ese", "Awes๏meStanψt๏m", "FαcͥτoͣrͫyInτorτ", "≪Nummiຮ๖ۣۜ山his𝔱l͢͢͢er≫", "IssℓαtSℓoͥppͣyͫ", "PђeαlαHitcђeภ", "ⱮօղѵҠօմҟӀąʍօմ", "🎮丹թթєɐli𝓃gQuɐli𝓃gє", "「Grǝacklψeτ」", "IήesนrͥŇeͣmͫ", "≋Beήτic͢͢͢ediή≋", "Meͥภeͣqͫuสles♦️", "😦UnwielᖙℽNexק", "WateᖙeToℝ℘eᖙo", "Veℝ∂สntͥSiͣmͫสntสc", "「ƤสrigͥCoͣrͫriᖙor」", "Anͥkeͣnͫtscru", "⪨Äภioภ§Jสภeman⪩", "ᴵᴬᴹDaͥzzͣlͫᎥŇgWᎥlieรτi", "Naΐgͥΐcͣaͫℓℓef", "『WสψstℝWสt🅲hfส🅲e』", "🐅Exקreαrfer", "OfͥfeͣcͫKΐck𐍉ff", "☽乃ץՇ๏קץՇђ๏ภ☾", "ṨuήnyAuserสny", "Meℝaͥ∂lͣyͫקen⚠", "ͲąղէìçմҍӀ", "Se∂iสCสucสsiสŇ", "OfͥfeͣcͫelŦec†𐍉", "He∂uαlrigive", "⧼Deͥpsͣeͫᄂfarg⧽", "AήixecemØcultiή", "Ŧollicuรectior", "W๏rͥteͣsͫSᴍartie", "丹ภefFคภgs", "Ot☢☢sℓคwคℓtede", "❅WђizคJคckWђi†e❅", "Heɭɭ฿☢ᴿåbo", "「Abi∂iŇgDicaŇℽ」", "Isͥheͣrͫΐτaℓes", "᚛Θficຮoภeຮ᚜", "๖ۣۜᖘⱥuͥncͣhͫyCⱥustiᴍ", "🚊Ӌeสτenͥτrͣiͫ͢͢͢n", "𝔗ec†iga†eechersҜ♐", "⚡U†eͥreͣvͫe∂a⚡", "𐄡ɢlaήsaรailØrM͢͢͢aή𐄪", "ⲘสysτᎥnⲘᎥnou😌", "°”Ṩi𝓭ityethicl”°", "J๏ѵiaℓP𝓇iaℓ", "๖ۣۜℜevⱥsนpSⱥssⱥfrⱥs", "M☢tivͥαtͣiͫngB☢nαtiff", "༺Thøuɾnᵃnꜱt༻", "I๓թe𝒸cąbℓeMusper☘", "✰Aאָiͥcaͣpͫђeℓ✰", "ᶠ͢͢͢ᵉⁱᵍⁿᵉᵈᴸᵉˢˢᵃᵐᵉᵈ", "𝒞𐍉nl𝖞r𐍉𝖇s", "Grαcΐ๏uຮCaͥ๏uͣnͫc", "Mสmm☢τhT☢τh☢ldi", "𓊈卄ανσ͢͢͢ℓ丂αναє𓊉", "✰W☢☢ℓutte∂espect✰", "⁣𓆩ⱮմʂʂҽąⱮմʂէąçհҽ", "Ofͥerͣsͫやr𐍉fess𐍉r", "๖ۣۜ฿uͥ†sͣiͫ多Mu††er", "SⱥτBigPØτⱥτØ✪", "Inf𝔞M𐍉nFr𝔞ΐรe", "〖IŇviŇci多leAdeŇƤual〗", "🐯Hคndy͢͢͢Hคtiɭity", "ˢᵐᵒᵘᵗᵉᵐᵃᶜᴳᵒᵈ", "Ofͥteͣdͫΐe฿edbeⱥuty", "⦃ExtegสExtℝ𝒶H☢t⦄", "Orͥ∂sͣmͫนcessน⚔", "Y𐍉utђr𐍉uภ", "✰Tђℝ☢titsc✰", "íɑʍ≋AℓtŁiℓŦ𝓇Øℓl≋", "FiήgtFiggץ⚔", "ScieήtificPสti", "GrͥesͣsͫB𐍉sslคdψ", "Mⱥภumbℝip", "T๏iͥndͣeͫLⱥcewing", "★Shͥouͣlͫ∂en∂ieve★", "Suallizatiᴍe", "♐P͢͢͢herstst☢", "I†iͥonͣgͫingeℝna⚠", "Ofͥfeͣdͫg๖ۣۜßαllØfFαt❥", "๖ۣۜℜaͥnsͣtͫredu", "MØcipParรήip", "Se∂iͥรhͣiͫmส∂", "𝔚𝔥𝔞𝔫𝔡𝔢𝔱𝔉𝔞𝔫𝔞𝔱𝔦𝔠⇜", "๖ۣۜOffeℝtBαffy", "AttentiveFornate", "Faͥveͣrͫnext", "UnusuⱥʟFrøungdø", "Geຮຮionͥຮtͣaͫ", "୨丹𝓃d𝓼e๖ۣۜƤⱥ𝓃cⱥce𝓼⪑", "ร๏ɭɭร๏ภɭץ", "S℘iяiᵗe∂Pie🅽t💦", "L𐍉𐍉ภψSi𐍉ภaͥlsͣeͫ❥", "🎮𝕊ecτolαrץຮτ", "◤NorNoRegαrᖙ◢", "DeͥℓiͣgͫhτfuℓAnᖙeg", "Rec†scess", "✫Itͥคlͣlͫsømme", "⧼ᴀภqͥ𝕦eͣsͫτeds⧽", "๖ۣۜ山angຮᎥRagຮ", "HeͥᴍaͣdͫeDelᎥ𝖗Ꭵum😇", "⫷M🆄ɔtsΐ𝕓lest⫸", "Iภge†eͥℝeͣdͫu", "🐥IภêℝtAshtaℝt", "Pieceℓᴮøøkie🌺", "Ƒrͥedͣeͫτw☢u", "Imק𝔯essi𝕧eや𝔯iτs", "Reͥivͣiͫ๖ۣۜᗯeiner", "ReήsecoEnglishRose", "᚛UήisliήBigHuήk᚜", "TΐrelessToήdessΐ", "Sµccessfµ͢͢͢𝖑Toccesse", "HⱥŇceIcepicҜ❥", "Trͥitͣeͫ丹ภtຮeภtr", "AlสrᴍingSђerᴍ", "୨Fei𝓈tyLexte∂i𝓈⪑", "⚡H☢sH☢neͥℽbͣuͫn⚡", "🍃𝕲rคᎥŇคÈlคᎥs", "CℝectͥℓiͣgͫŇe", "Sollℽstriongst", "⦇¢aphօℓօSnappy⦈", "◤𝓟𝓲𝓰𝓰𝔂𝓒𝓸𝓾𝓰𝓰𝓵𝓲𝓼୧", "⚡Abͥ☢nͣdͫynᎠynสm☢⚡", "∉Gℽmͥnaͣsͫт🅸𝖈丹terΐamn∌", "▥ƆouƆouʌıɔʇıou¿", "𐐚ץƬuƬtepØω", "OffeรeรSugαrͥᖘuͣfͫf♛", "【Çðñêð₥͢͢͢å¢ïł】", "Aгti𝒸ulateUภtalaภ", "🆆🅷🅴🆂🅿🅸🆂🅷🅰🅳🅾🌗", "★AbͥreͣcͫuℓCuթieDoℓℓ★", "∉𝕾nappʸ𝓝alꜱ๏∌", "Fℓน††eriή𝓰T๏ήce͢͢͢∂in", "PeℝfectIteήeℝ⚔", "😋𐌁𝔯αήgsτ𐌁ruddah", "🌳H𐍉Ňe͢͢͢st𝓘Ňew", "ℓเττℓєA𝕤𝒾𝕤͢͢͢ul🅰natedes", "Agͥreͣeͫⱥ多leCⱥ多liรรi☂", "◤AŇdสtMสŇŇeͥℚuͣiͫŇ◢", "CaภdefJefe", "Neττeຮ℘andaττr", "Ofτeᖙบree", "Ƥ𝕣αlØ𝔫scallᴳᵒᵈ", "✰Habi†ualΘn∂ingua✰", "【EaℝŇestͥIsͣtͫaŇdne】", "ArΐsVΐssψ✨", "฿eenGoatees⚔", "Atereatha", "Θffi多ℓoTrou多ℓe", "GraվรⁱRนgraτ🌻", "𝕴ñⱥτ🅸vScrⱥtchy🐆", "AƤeͥndͣiͫMonLaƤຮin", "StͥunͣnͫingAndin", "⩻๖ۣۜᗯorl𝒹ly๖ۣۜᗯonsi𝕥u⩼", "Men†e∂eem", "〖CoℝdsђWaℝdoŇ〗", "🐫PønΛctiαrsenaℓ", "ᴴᵃⁿᶜᵉˢʰᵃⁿᵍᵒ▒", "PℝocͥRoͣbͫotobαmα", "BℝeͥncͣyͫtRสncoℝ", "▓TreήdץTrคm", "𝕻𝖑𝖆𝖙𝖎𝖘𝖊𝖓𝖙𝖙єค๓", "๖ۣۜBloαtyAnat͢͢͢e", "【Cบrruτiv𝖊͢͢͢ภ】", "✰VΐcͥtoͣrͫΐousStor∂eส✰", "✹Shΐll๖ۣۜᗯildfire", "Noωαselli", "Guͥΐlͣtͫless𐐚otlץsΐs", "RⱥyRⱥyDisђirⱥƤ", "𝔚hΐ†eℽWhΐm", "「Ciaℓiͥᖘhͣoͫbia」", "𐐚eeͥᖙgͣeͫήve", "千lu🆃🆃er𝕚𝓃gṨαu🆃e🏂", "᚛BℝαzenBℝeα᚜", "CoήMonƑrสise", "๖ۣۜ山iͥggͣlͫץ๖ۣۜ山ing⇜", "FeͥllͣsͫoϻƤlo",
              "㍶𝕎𝕠𝕟𝕕𝕖𝕣𝕗𝕦𝕝𝕍𝕖𝕣𝕗𝕠𝕣", "Sτiᵛeʀmin〽️", "Rilαtoℝyᴍ⚔", "₧Anสτ͢͢͢Rสτit☢", "Wสs†eGℽmⲘสs†eℝ", "PlaภtøƤee", "⚾ꜱcrค℘℘yIsτraℓΐf", "DittØήSqͥuaͣtͫty", "⚡O多ʝecτiveDeco⚡", "TสiͥsiͣgͫerƤsץmend☘", "OrryᎥeรᎥ๏", "Ƒuͥℓdͣsͫhinec", "ThaͥŇkͣfͫulChaℝᴍis", "íɑʍIsτʀᴇթ๏sᴇτ", "★Θfferencesթece★", "Ar†h☢uldre🅽diส▤", "ForgivingForn", "N𐍉ᴍbec𐍉ήts✨", "๔เгєςՇгє๔เς🐵", "〖Oภvest𐍉pΐ〗", "⫷Ofteภ𐍉Gift⫸", "🚣ᴅʀɪᴠᴇɴᴇᴠᴇʀʀ", "RⱥsƤberrψ๖ۣۜ山heriesi", "Affeuredi", "MⱥiήτFunͥτoͣnͫ", "ΘffireKhⱥήzir", "Meͥdeͣmͫeήdiήgeή", "★I†uℝFuͥℝmͣuͫzzℓe★", "⫷FⱥrϻbØyFⱥϻb⫸", "Itarᖙรcreϻa", "⋉Direllooductຮe⋊", "TreαNeαt𐍉", "SuթerBoℽAvetℽթe", "°”φմէէҽԱէʂվβìէʂվ”°", "Oⁿeรsitedit⚠", "⸔Ṩaΐηg↻haΐ͢͢͢nຮ⸕", "I𝓃gMøn🅰nge", "A∂aptableやapti☢ng", "〖WⱥsτrSτⱥbͥbeͣrͫ〗", "ཌInͥgeͣdͫighØ𝓊ndད", "█▬█ █ ▀█▀Asser†iveSegingin", "Ofteᖙucee︾", "CђⱥrᴍingPⱥcerᴍⱥr♛", "฿eͥirͣoͫᴍeŇclo", "∂яα¢σηιαη卄αη∂яє∂υ", "EthΐcαlͥHoͣdͫyetre⚠", "〖Tiͥสnͣyͫouℓthom〗", "AbrasiveBrivilly", "InceirKissyFace", "Ittelitingly", "SomentsSoul", "Wooksommen", "UnizPizzawife", "FersoPowerpuff", "MelodicDell", "SoftyOffee", "Joidaskin", "WhowerHotsnap", "PassionateLasiste", "ProbseVinDiesel", "ForessiKisses", "DawbufBunrose", "JudensPendulum", "DayeSaySay", "Watertitur", "AntilkMilkman", "Magaltyea", "Houstsibl", "IngheoAngon", "Byribibeg", "Gingentray", "Hichicapho", "ResoluteAntardso", "Andivedyngstims", "BeautifulToldif", "HostilityBustay", "IngiShinyGaze", "Anytimple", "NowSnookie", "WereituAtum", "Gortaitic", "ImposingVelsical", "Witionsips", "WhiteyWhati", "Grabourch", "ToastyImpaspen", "SensibleAlsem", "Enendscandspip", "Itycomplandshor", "VictoriousWousi", "OfteOfficeboy", "Phoodyeang", "BeneficentTocen", "ItisBityarani", "Hourabony", "Autooligue", "IngenScrooge", "YoulloDulhaniya", "CoolguySkinqu", "Itiattive", "CambessCupcakes", "Oferbelogr", "Ofewposicu", "JockyAckn", "HumptyImpelic", "ComptsBaldyDom", "Whaviatte", "SoftOffel", "Werediand", "RegralPlegasus", "ReacPokerface", "OffingeCoffy", "Beedaltyo", "ConsistentOffortsi", "AstoundingEst", "Onquentabliate", "AwesomeTomostur", "DullDozyLemodu", "EsionlyGillygum", "OptimisticPtinknew", "VoluntaryRary", "SublimeItsubi", "ModestEctoormo", "AnglysSilly", "AmetionMinion", "MentMedusa", "Rompleseral", "AxiomaticMantr", "Arsecritom", "WarleffBuffalo", "YieldingForier", "Maternize", "PerfectWeregife", "Beganiateds", "EvesevStSteve", "InsibilWinkyDink", "OndoingDomino", "ProgetcBucket", "SairaciElais", "RectProject", "ObservantLarbsedi", "EthicalPriametr", "Nowerstope", "OutitiTooti", "BeautifulFoutes", "MilwaspChiliPepper", "FessoPissant", "SedoFirebred", "WasedlaTiddles", "AliveKelichap", "PuringiTinyBoo", "LincystColestah", "CentoodDoobie", "ScratchyScra", "Ityretuddynt", "Offeckert", "GymGuyMgbil", "FireBerryBethindi", "CrankyBanc", "Shitislonesp", "Whowediff", "WervidVivitar", "CarthaHatred", "EminentKinteeni", "Phystudeat", "Aneumenctr", "DiplomaticBerat", "ItyansSugarBuns", "ZealousMovereat", "MelodicOloodpor", "Fookeyedep", "BooBooKittyRettlyst", "BeirstHairBall", "IngmerRhino", "Gelsouldi", "Ingdpoici", "Ingledible", "PrettyProessi", "WherviKicker", "DalikTikku", "IninFeint", "Aestudireastal", "LumpyNemples", "SmokeyMorsiall", "Founititag", "FrownyTownswe", "AntionFunTime", "Keestingko", "AltruisticFaric", "MyonlyDestrion", "Herrionati", "Adyintred", "DevoutItlereve", "IngshiDingo", "Wormserld", "OfficeboyFillan", "PositiveNovermal", "UldfuBaldman", "Diedinsto", "CosseaPoppyseed", "Meashichem", "EtionSeatides", "KissableDontrisd", "WaysidKidSister", "AborTurboMan", "Encipansoncla", "BlueJayJaimingi", "Hissiodustomer", "Eponesibadedge", "SincereAnce", "Forightse", "Peraddiesphic", "MookyPorPooh", "Paideliti", "UnpunUnoShoten", "Elegirionvedr", "InguDerange", "Offermang", "TorClaymore", "VengefulPentse", "PrincenHitchen", "Medeconlyme", "『sʜʀᴋ』•ᴮᴬᴰʙᴏʏツ", "꧁༺₦Ї₦ℑ₳༻꧂", "༄ᶦᶰᵈ᭄✿Gᴀᴍᴇʀ࿐", "×͜×", "Sᴋ᭄Sᴀʙɪʀᴮᴼˢˢ", "亗", "꧁༒☬sunny☬༒꧂", "𝓑𝓻𝓸𝓴𝓮𝓷 𝓗𝓮𝓪𝓻𝓽♡", "༄ᶦᶰᵈ᭄✿Gᴀᴍᴇʀ࿐", "×͜×ㅤ𝙰𝙻𝙾𝙽𝙴ㅤ𝙱𝙾𝚈", "꧁▪ ＲคᎥនтαʀ ࿐", "꧁༒☬ᤂℌ໔ℜ؏ৡ☬༒꧂", "Ⓥ", "メ", "꧁༺J꙰O꙰K꙰E꙰R꙰༻꧂", "░B░O░S░S░", "Sᴋ᭄Sᴀʙɪʀᴮᴼˢˢ", "꧁༺ ₦Ї₦ℑ₳ ƤℜɆĐ₳₮Øℜ ༻꧂", "✿ • Q U E E N✿ᴳᴵᴿᴸ࿐", "🅑🅛🅐🅒🅚🅟🅐🅝🅣🅗🅔🅡", "༺Leͥgeͣnͫd༻ᴳᵒᵈ", "🌻ｓｕｎｆｌｏｗｅｒ🌻", "꧁ঔৣ☬✞𝓓𝖔𝖓✞☬ঔৣ꧂", "꧁☬⋆ТᎻᎬ༒ᏦᎥᏁᏳ⋆☬꧂", "ᴹᴿメY a h M a t i ☂️", "꧁༒Ǥ₳₦ǤֆƬᏋЯ༒꧂", "ϟ", "༄ᶦᶰᵈ᭄✿Gᴀᴍᴇʀ࿐", "ꨄ", "𝕯𝖆𝖗𝖐 𝕬𝖓𝖌𝖊𝖑", "꧁⁣༒𓆩₦ł₦ℑ₳𓆪༒꧂", "Sᴋ᭄Sᴀʙɪʀᴮᴼˢˢ", "꧁༒☬ᤂℌ໔ℜ؏ৡ☬༒꧂", "Dɪᴏ፝֟sᴀღ᭄", "⸙", "ＦＺㅤＯＦＩＣＩＡＬ亗", "Aɴᴋᴜsʜ ᶠᶠ", "Lixツ", "♔〘Ł€Ꮆ€ŇĐ〙♔", "꧁H҉A҉C҉K҉E҉R҉꧂", "OPㅤㅤVICENZO√", "𖣘ᴰᵃʳᴋ᭄ꮯꮎᏼꭱꭺ🐲࿐", "『sᴛʀᴋ』ᴷᴺᴵᴳᴴᵀ༒࿐", "ꔪ", "『ƬƘ』 ƬƦΘレ乇メ", "Ꭺɴᴋᴜꜱʜㅤᶠᶠ", "꧁☯ℙ么ℕⅅ么☯꧂\ufeff", "Ꭵ°᭄ᶫᵒᵛᵉᵧₒᵤ࿐♥", "•`🍓Valerie xavier axelelyn🍥", "αиgєℓ _ℓιfє ❤️🥀", "ㅤㅤㅤㅤㅤ", "ᴛᴜʀᴜ ᴅᴇκ友", "━━╬٨ـﮩﮩ❤٨ـﮩﮩـ╬━❤️❥❥═══👑ľøvē👑 ═", "×͜×ㅤ𝙰𝙻𝙾𝙽𝙴ㅤ𝙱𝙾𝚈", "ᴛᴜʀᴜ ᴅᴇκ友", "『sʜʀᴋ』•ᴮᴬᴰʙᴏʏツ", "ᴶᴬᴳᴼᴬᴺ・𝙀𝙢𝙖𝙠友", "BSK・L E G E N Dᵀᵒᴾ", "亗", "꧁ঔৣ☬✞𝓓𝖔𝖓✞☬ঔৣ꧂", "BSK・L i e e Eᵀᵒᴾ", "BSK • ＫＩＬＬＥＲ亗", "ᴶᴬᴳᴼᴬᴺ 𝚃𝚞𝚛𝚞友", "🍎", "꧁༺༒〖°ⓅⓇⓄ°〗༒༻꧂", "꧁༺₦Ї₦ℑ₳༻꧂", "ᴶᴬᴳᴼᴬᴺ・Bocil 友", "꧁☆☬κɪɴɢ☬☆꧂", "꧁༺nickname༻꧂", "★彡[ᴅᴇᴀᴅ ᴋɪʟʟᴇʀ]彡★", "『Ѕʜʀ』• ℑℴƙℯℛᴾᴿᴼシ", "☯︎Ꭱ Ｏ Ƴ Ꭺ Ꮮ 亗 ×͜×", "", "matao", "kkkkkkkkkkkkkkkkkkkk", "Hiiiiiiiiiiiiiiiiiiii", "Emmett", "spencer", "copy my tank", "all i know 2x", "RATATATATATATATATATATA", "Thisislie", "jungleman", "austinz", "Austinz", "ur nub", "why yall so bad", "mi(mobile)", "awesome soccer(pog)", "2377285 auto triangle", "THE NEW BOSS", "hawaii", "M.", "turaco", "Neo", "S8NF-EB3J-FHEI-N264BR3KJ", "5555555", "ur mom", "2+3=5", "one piece", "Fallen Boss", "Roomb 2.0", "earth = sphere", "Roomba 2.0",
               "Dulanka", "i dont know", "Aith", "I'm your son", "TaKE LOl god shoot", "2+2=4", "Fenrir", "bewear GX", "Kalashnikov", "hey sister", "Sup :)", "wall hallo", "I stand for Liberty", ".", "OliwierQ Chojnacki", "MetatronXY", "Arcturus", "OP", "teste", "ink sans", "ropell", "PLL", "Solaris", ":v", "OBL", "teach me", "-_____________-", "rwegwerg", "n to level up", "thiago", "FAST", "This is far", "jojo", "Anak why u solo", "Lunatic", "sin", "nate", "popa peg", "Sssssssssssss", "Meepet", "hose man", "Beast", "angel", "}{eonyao", "minty fresh", "Evil }{eonyao", "Tango", "turtle", "knbg", "underverse delta sans", "fallen booster", "COMMAND.Z ANTI BOOSTER", "ANZAI", " manu", "lawless", "I don't even care", "Tesea", "Oh", "tree'lean", "Your Drones Will Lose", "Geo", "fotosintesis", "Floofa", "Pro", "h8u", "adreszek", "JOSEF", "Waiting on a Miracle", "Jain", "ReignOfTerror", "kakyus222f", "fdgxcgvx", "DPS!!", "Cute Sentry", "oh im noob", "Math you", "twilight", "Soccer", "ikandoit", "RopeSteel", "no-one", "omni", "kkk", "putre", "value1", "Fart", "REEEEEEE", "{AI} Bot", "xdnha", "Ni", "sheild", "CrAsH", "play", "Shadow closer", "Fire", "Actual Pro", "ATK_X", "Unravel", "PSYCHO", "Yrneh!", "chop", "aa", "This is the tale of Me", "ChRiS", "GABRIEL", "power", "force feild", "Drabbleasur", "JokaDa", "Pet tank", "primos bros proo", "You were so mine", "Railgun", "ARENA CLOSEA", "Force field", "duck", "X.ALEXANDER.X", "Wolfgang", "baited!?!", "PERU", "force field", "Aespa", "copy my tank pls", "ns", "64M3R_999", "Fartington", "Yimo", "Stand For Ukraine", "hi.", "This", "Lena", "A TANK", "AA01blue", "Winterblade", "AndoKing", "alejo XD", "%Weeping_God%", "tribe", "Auto 4", "It's a lie", "bye jax", "tkdarkdomain", "Eydan ツ", "jax sucks", "Nerd", "Q8238q", "Zer0", "The cLe@nER", "Protect", "JSjs", "Angela", "neep", "", "@- @", "ducky", "bo", "_hewo", "Raganrok", "Christofer", "Saturn", "Nintendo Memes", "{RUNER}", "PUPTO", "ku", "Enter Me", "AWESOMENATEXD", "rf", "TankTankTankTankTank", "Someone", "turbo bros", "Yelloboi", "Nothing to lose Tank", "Thriller", "BING CHILLING", "xDD", "CDU No.30", "lenin12", "junhu", ",,", "super stinker", "Base", "pro", "oreo", "ggking", "GiGa LEN", "PH|Player!", "Weakest woomy player:", "Jekyllean", "TaKE LOl :D", "The Tanky", "Phong", "$shark buger$", "g  ergd", "bobbb", "your son", "das", "Guardian", "Wherly", "David Sanchez", "surprise", "comma verga", "LorcaExE", "loz.", "Mobile sucks", "Karen-SpeakToYourManager", "noir", "press n to level up", "GZGESETA", "Debreo", "Parzival", "muhahaha", "Fotosintesis", "tiler bolck man 456", "EternalMakaush", "hi8addas", "Hehehe", "reeeeeeee", "~", "yuan(hi)", "King_plays", "1 hand only", "bb", "UpdDAR3", "Music man", "RISK RISK RISK RISK RISK", "QWERTY", "12345678910", "6", "kk", "q__o__h", "USA", "NOOD --_--", "Giggity", "Kristoffer", "Nerblet", "gdfaaa", ";jl", "100000000", "drone users are weird", "Xenon", "not Devin real bruh meme", "MeepMweep", "oa", "RavenXL", "where are you fern", "AnyMore", "I", "huy vn :D", "jk", "bosss?", "Loop", "farmer's tan", "Until next time", "KK", "Ultra", "?????", "Tt", "Tal", "dddd", "998", "jUst TrolLinG aRouNd", "MK", "Don't Make Me Mad", "minh vn", "Dragon ,You Dead", "hWE", "HORRIBLE LAG i'm pacific", "You Made Me Mad!", "00", "DEMON", "Thor 4/10 :(((((", "Giant Justice", "crgine", "vnnnnnn", "Finally, 3 m on siegers", "FBI", "huy", "-  k    i    n    g  -", "ciganoit", "waste of time", "i'm a sadboiz (joke)", "imagine being nub", "solo 1v1!!!!!", "leonardo YT", "nobodynoticedyouweregone", "jack.vn", "Evan", "(:", "Astral Java", "Me n You", " hihihihuhihihihhiihhihi", "hara", "B", "Nooby", "EZ", "MrYoungSir", "manne", "Ragnarok", "Truchenco", "m", "LEGEND", "SINBADX", "let me farm alone", "Friendly /j", "bye error i gtg", "Pollo", "7/11/22", "jimmy", "Guilherme", "meb", "victor", "I use handphone", "PEGA(SUS)", "Mort", "the j", "yang", "go", "Very dangerous", "I'm harmless! -Press N", "brayan el proxd", "mateo", "back pain", "nnnnnnnnnnnnnnnnnnn nnnn", "CraZy III", "2-3-40", "Yeeeyee", "car go tornado", "hehe!", "taco", "@@@", ".v", "Roronoa Zoro +++", "yyyyyyyyyyyy", "Tki", "Siege weapon", "BDO", "bcd", "100k speedrun", "Shoot gun pls join", "random tank", "virtual machine", "Destroyer only", "DEAD", "vn <>????", "Ma$t3R", "R", "Justa_Noob", "Ma$t3R lucky", "Kaboom", "mystery", "pro vn", "YOUR JORDANS ARE FAAAAKE", "147 toxic", "e xin thua", "ew", "mega monster!", "NATHAN", "pe players be like:", "yess", "wait", "dunt kell meh plas", "FEZTIVAL", "Blyat", "wake up", "Rainforest", "duos",
               "PB123", "go sleep", "nieeieeeeecceeeeeeeeceee", "Eren slenderman", "rtt", "ssss", "press n = score", "Around", "1m plez", "im the best", "asdasdasd", "race me!!!!!!!!!!!!!!!!!", "lp lithium", "queue", "ttjjl", "heyy!!", "Yuck", "sus destroyer", "silent", "47/107 :(", "miIk", "water", "Sas", "The Destroyer", "Ff", "Master", "asd", "k", "dk", "Exotrezy", "qp", "3+3=6", "nreferif", "blitzburger", "Mr Shorts", "iuiui", "yu", "Mem mem", "8787", "adymin", "oooooooooooooooooooooooo", "Bots Drovtend", "Panzershreck", "nyac", "ccf", "Mh?", "joshs", "beep", "hsg is sb", "404 Not Found", "Michael", "thinh", "ABC", "ggwz", "Indo", "THE King", "Nagi", "Pato Lime", "aaeaeae", "BUGEN", "Area closer", "Unbalanced Build", "//", "nnw'", "Door", "Matias", "ky", ";", "Gavin", "Lucy", "Kitzuneko", "This is the tale ofn", "Hank", "hiiiiiii", "^---------^", "screw", "LSV-005", "Hiary", "jonh real", "Nothing overlord", "Portaun", "20240123", "ggs you are good drone", "NoU", "mcbeef", "sg ez", "Chase", "it's a lie it's a lie", "qwertyqwerty", "LEGENDARY (VN)", "NATH", "backrooms", "Daffa", "MATHUEL", "vn luffy", "HAHAHAHAHAHA", "Oofed", "Hung dayy", "noob vn", "Sensor", "Marco the great", "Ghgft", "unscientific", "EnemyTracker (LookAtMap)", "yeey", "oh, dear", "Anderson", ":> hi", "redhood", "Volderet", "Harry Styles", "WINNER", "r u dangewus", "odo", "maksim", "eryweufhw8r46yq3782edtqf", "Katya", "Unlucky", "Maga", "BASE MAKER", "td", "sure sure sure", "Zarma", "octavo", "evan", "U  N  K  N  O  W  N", "jbc", "exc (real)", "sonick12", "exc (fake)", "~A~", "shadow", "Yoriichi Tsugikuni", "p1", "Hanumanumani", "bob the builder", "BLITZKRIEG STRAT", "sus", "India", "Oof", "kiyo", "Toopy&Binoo", "I'm Innocent", "GujiGuji", "SANS", "LoSTcar", "UNGA BUNGA", "add me", "Meeps", "afafafafafaffalafel", "........................", "Vladmir Poutine", "EEEEEEEEEEEEEEEEEEEEEEEE", "SIEGE  lhaahahahahahah", "TCO (The Chosen One)", "Daizole", "BASE", "wibu king", "rainbowmonochrome", "Vincent Ling", "BruhBruhBruh", "Eternal(VN)", "sss", "testbed B", "Yeeter", "Oi", "ooooohhhhhhhhhhhhhhhhhhh", "Ardenll54", "$$$", "S", "nat", "Sheep", "Imagine", "ScoutTF2", "Saking", "Hahaha", "poppy", "skitlies", "Fallen Overlord red", "Relosa", "pacifist cant help sry", "fk demon", "Idk...", "D=EMON$ do u know?", "sinx (fk demon)", "Fruits", "Hehe", "Fallen Overlord", "Faster", "BulutMobile", "Awzcdr", "mega", "General", "Winner", "=)))))", "..............", "DEFEND", "Hiary4", "Eye", "Merdka!", "Just watching", "zeke", "boojawzee", "DESTROYER (VN)", "754", "hehe", "HACKER", "bugo", "RRO", "wltjdwns836", "Shadow", "JUIHAN", "66", "monke", "hi vn 1", "wltjdwns234", "GHASH", "3310", "undecidable", "10xyz", "V&N", "LintanGG", "ak", "Arena   Closer", ">", "TF2 Heavy", "feztival", "Ragnarok-eternal", "Revenge", "Ficli", "baos", "{ HEALER } +", "Ian6000", "Shhh!", "loxc", "Banned from seige?", "1457", "666", "deezs", "nn", "Use me as a shield", "Yocto To Yotta", "Dorcelessness.", "3+4=6", "superium.", "are the dominators blind", "3+4=7", "Pew", "=))) (10%streng)", "Carsonxet", "X11 | Nebuqa", "look llllllll", "kkkkkk", "Sorry!", "thebestofthebest", "god fighter", "mafia", "My Music:)", "no u", "Begone (1v1", "HAH LOLX)", "skull emoji", "free fire  max", "No Player", "Imaginary", "Yep.", "| AL | ChillOut |", "mini boss", "yayayayayan", "Huggy wuggy", "Divine", "Mumo", "No", "Pyrolysis", "narutouzumaki", "THE", "TR", " PRO", "178965", "Comeme Soy Dulceeeee ;:(", "either", "Maze Cops", "give beta tester", "-.......", "i need score", "nm00{", "you are my father", "DDDDDD", "6666666666666666666666", "AUTO 555", "me best", "Crozo", "longest run", "blood for the blood god", "i m a protector", "q", ":(eu tou triste", "Sheeps", "i asia so 300ms", "not an easy target", "MyLittlePony", "little one", "oo", "cool kid", " BUB", "TTroll", "Onyx, The Fall of Hero's", "ツ", "ba", "Josh", "revenge:(", "La meilleure", "The leader", "n level up", "}{ello", " vikas", "Alpha Fart", "Matt", "fisch", "guy", "Cozy.", "Preku", "stuff", "friend to all", "Inverse", "no ;)", "Souper?", "):)                  ???", "Update", "down", "protectn", "Radiant", "gang gang", "Deadlord", "dude", "Asesinooooooooooooooo", "lucho", "Pounder | aaaaaaaaaa", "Hoping", "def", " sans", "LazuLight", "Pounder | pain.", "WHERED MY RELOAD GO", "eh", "RP", "wat?", "ehwhylag", "OFN tank", "Fundy", "how to stack fighter", "Hugo", "Ice Breaker", "Pew Pew Pew", "I eat dirt", "bla", "blue octos useless", "HAHAHAHAHAA", "Min", "Fatty", "Begone", "blue octos __", "willlddd", "what is this?", "Aleph", "Demon", "Error 505", "Horizon", "The Tale Of Tanks", "1+1=3", "sdddd", "ven", "Yujin_05", "99999999", "dead", "Flight", "ma ta", "anime", "cyan", "wreck", "Uh what", "APE", "Through the Rain", "no pew and paw here", "idol askib", "2...00++++", "jjjjj", "firework", "Jacob gomez _ Jadenian", "I'M CHILLIN", "yoavmal", "eternal.exe", "Bye :)", "no plz", "REVEnGE__+=!!!!!!!!!!!!!", "NEMDT REEEEEEEEEEEEEEEEE", "Abdurahman", "Boost", "hehehehaw", "fdb", "stay all over me", "maida", "thingy", "error", "jhh", "support tank", "HighFenrir", "B I G V I E W", "YYYYYYYYYYYYYOOOOOOOOOO", "fov", "OverGod", "Reaper", "Tanky", "Arena Close", "PPguy", "casa", "bruuur", "FALLEN. BOOSTER", "troll", "a polygon", "1st", "Abdule lah", "Fk", "can", "NUKE H", "Gutey", "42", "nobby", " //", "press n to levle up", "Pulter",
                "om nom nom", "+", "auto", "downside 930", "7888", "ium", "super idoi", "blessing", "Tricky", "BUILDERS!!", "Barry", "sandbox", "Y U NO?", "Let me free", "ME", "hacker", "a duck=", "Er0  VN", "legend", "zz", "epic nokia", "Gr8", "Sinx", "Hugh", "inverse square law", "Bodyguard", "Maximaths", "INDIA", "SPAXDE", "A - E - T - H - E - R", "K.I.L.L", "raoofOverlords for noobs", "seesaw", "zombie", "hhh", "The death", "im a yoututoer", "Brujh", "juan", "CCC", "Hint :D", "FnF", "uyuy", "fg", "friend of mo", "Blue are dumb players", "THE LOADROJOZ", "Test", "no plis", "HenHen", "HenHennnn", "COMEDORDEMAE", "TaserBlazer", "rococdc", "AHOI", "cocorito XD", "Yeet", "kendyl", "Adnan", "World", "THE GOD!++", "DOMINON", "sanic", "NitroX", "sonofgrits", "me noob", "dumb", "joe", "yesbody believs a lair", "Bocow", "nnnnns", "15", "kevin", "fshwel", "milena", "i see fire", "", "lopi", "over", "edan", "cats>dogs", "sedat emir", "not -_-", "motik_kotik", "Troll", "Angle", "sheeeesh", "Rigged", "pablo", "droldaed", "JokaDa: how incremente s", "Hinote", "7/11", "Arena Closer", "newae mobile", "THE SUN IS BURSTING", "o farinha SUS", "daniel zZ", "jj", "destroyah", "5664", "graumops", "Green will win", "acidre", "eutimato your bad", "kermit the frog", "jared2.0", "jjuanto", "beep boop", "tomas", "wee woo", "IwantLegs", "theres so much sercets", "da duck", "Flace_25", "Promax", "Asesino", "Manoel Rafael", "Mcmaster64", "nnn", "Dont away, noob", "zad5", "sdsd", "retard", "Add update for chat", "Bruh", "SWAT", "Vakvak", "Juan B)", "raoof", "DarkStorm3", "F-35", "Mr.Tank", "LA2T", "me no u(u know me)", "Pokey thingy", "huggi wagi", "godzilla", "Loki", "Hybrid", "Gusfin3  :)", "mAX", "Arena Closer", "Don't bother me", "Ok, Boomer", "perra el que me mate", "Mobile player", "This is the tale of you", "ducko", "Tubby", "your mom is watching you", "segurity 2", "lll", "Jr.Greeen", "Dddd", "rid", "aaaaargh", "stegosaurus", "Free Points? Nuh-Uh!", "a nuisance", "Poseidon", "Turbo Valtryek", "vz", "bryan  stichn", "urfwend", "Yodin", "hooray", "RENFORCEMENCE", "M163 SPAA", "Xant", "ayyy", "Randomness", "destroyer", "GB", "IMAXI", "F7", "twotales", "Gurmaan THE PRO", "Ayo peace", "hi ツ", "Scrub Exterminator >:D", "xia", "1{1}1", "DD", "Just Luke", "jose digma", "LORD X", "what's reload???", "AL|Air", "non't", "TryMe: DodgeBot2.0", "HexaDecagon(I grind)", "TryMe:360NoScope", "Error 404", "EDP445", "rsn.", "GEESER", "help me", "rotten punk", "solo vs 3", "all monsters", "ari", "Lore", "&__.._._:-:-:-.&", "Kalijia", "Rusty", "GUGUn", "hi :)", "truper", "goofy ah single", "ServentOfDeath", "J.L", "THUGGER", "ARKE:D", "The beep  duo", ">>>", "im bad", "Qscxz5", "CSDulce  Legend stop ._.", "poo", "StormX", "mafer bad DX", "Adymin", "FIFA", "GBQQ", "Wow that is not sure", "the 501st", "idonthavaccount", "baited??!", "Orn20", "theCityCR", "healersruseless", "Sin (watch my videos).", "list of noobs:", "extrextrehomiscopihobia", "N", "TOP X", "A3145", "letsbuildawall", "fev", "No one", "Guillotine", "Octavius", "This is the tale of a", "pain", "bgs", "auto gunner", "Necro", "antrax", "demon xd", "THe Emperor", "Stealth Jet Delta", "jace", "praca", "Arena Closer", "26.26k", "milky will eat your toes", "-K-", "TIE/IN", "u", "dez noits", "zx 33q", "heyyyy", "vvvvvvvvvvvvvvvvvvvvvvvv", "Multibot", "9999", "xan", "adelson", "1235434638968792345", "gruby", "EZNT", "cheap tank", "aaaaaaaaaa", "ryheghjt", "Celestik", "Pork", "Naruto", "GOMU GOMU NOOOOOOOOOOO", "apple", "somebody", "The gun on the wall!!!", "JK+", "starmie", "XD", "drakeredwind01", "This Is Nobody", "Arena Closer", "@ace", "Scoped", "Kazzbro", "348562347862349254127651", ".....", "NO MORE OVERLORDS!!!!!!!", "no c-", "Buzzy", "mom", "Chekks", "HAHA HEHE HUHU MOBILE", "bert", "leader Slayer", "na", "ZACHARY", " Iv", "Dogs On Mars", "Aquiner_ouo", "Thinh", "gas", "lautaro", "I also helping blue", "pet(XD)", "wow", "hj", "CraZy II", "laranon br", "XDDDDDDDDDdDDDDDDDDDDDDD", "eaeaeaeaeaeaeaeaeaeaeaea", "You", "zero to hero", ":D", "Lux", "magic_cheese", "good morning", "HAHA HEHE HUHU", "Red is best", "JK", "not onyxd", "help", "But you keep on breaking", "huttutu", "jjj", "hansith", "mds", "goofytank", "Korone Chan", "el pendejo", "razenezyou", "voltic", "qoh", "KL", " jeje", "asdfjkl", "Daisy", "zarity", "NobleSkele", "shhhhhhhhhhhhhhheeeeeesh", "kevynz", "Pewpew", "Star Ender", "Copy my tank ok pls", "JOIN THE PENTA PARTY", "bob AT", "basic", "jesus proooooooooooooooo", "um", "q00000", "adljsaknckjas", "OOOOOOOOOOOOOOOOOOOOOOOF", "TallStop", "Ops...", "underated tank?", "get error to 1mil",
                "999", "Comeme Soy Dulceee aaaaa", "Dangerous", "hyperbolica", "F-898", "Bubbles", "Mobile", "Arena Closer", "Darius", "123456", "Dev_Bs", "get rekt", "joker", "Mateus", "hvdhh", "Arcturus mobile", "PeNtaLOL", "Mr. Porridge", "go jax!", "E?", "Pew!", "BLAST", "level", "Vunda = Mythical", "Hi Levi!", "Hi Travis!", "Onyx", "T-T", "MiningMiner27", "laugh_laff", "UPdAE", "air", "C-7", "Hallo", "gonzalo whathat", "WHAT!", "NORMAL DAY", "Hi bruh guy", "VN chose machine gunner", "press N", "lets 1 v 1 bra", "rat", "asia", "HeNrY", "alp", "bayzid", "(LM)The Unknow", "aru", "DanZo", "Hii", "eeee", "nayc", "Maze", "ummm..... ok", "~Real_K~", "phong", "Support", "<1.5 is not enough", "=Z~", "Ban she", "comm ander", "Sei", "vcl", "Dapa", "T.Khang", "maikesito", "hihihi", "Dyaranhi", "W a t e r", "Fluffy", "223", "!ARNA LOSER !", "leave me alone!", "i use hacks", "EEEEEEEEE", "Always not alway kid", "GX .ver", "pro_noob", "Woomy", "boring survivor", "snaper", "val", "vex", "zander", "SPILKE", "as", "ok fine", "jimmy", "D19", "Nobody", "Paw Patrol", "pup", "eliza2", "plus points", "Egg tart", "Lava Perros", "ah, but u dont see me", "1K Followers lol", "nnnnn", "aaron", "minecraft", "I'm in school", "Necromuncher", ";v", "IW", "bruhhh", "453 sfafd", "adefe", "SUPSPRIES!!!", "messi", "Neonneosh", "spadzz", "gofra", "glacieronfire", "gal", "Ifarm", "hihi", "Sea urchin", ":')", " im crying do to U!", "dragonfruit", "FIGHT", " Friend with me", "GxngW", "Galax", "hiro", "Master Noob: Bruhhhhhhhh", "Nerdy Ball", "kumar jeremy", "wendy imposter is sus", "CAL", "Manic|Eraser|Cat110", "hara dont trust me", "its me! the", "sinx", "Dr.Tool", "pro cart pusher", "casyle on the hill", "hi im one", "Tristan", ":p", "monica", "one floofy boi", "YinYang", "supraaaaaaaaaaaaaaaaaaaa", "{ 0 _ 0 } IM Agry!!!!!!", "Jolo", "antontrygubO_o", "Leo hacker", "lakalaka", "1nFerN0 - 1 mil?", "UPdArE", "Tembito", "yvyg", ":(=)", "heh", "jonh", "GIGA SHRIMP", "Sky_Good", "poyo poyo", "The Beep 3", "Mine is Mine", "Yurin", "Your Pet", "7U9ukhlehpwhowiwiijji29:", "orphan destroyer", "BA.2.75 Omicron", "Astagfirulla", "Fallen Spiddy", "lee77", "ghg", "PretendToBeANoob", "zuesa", "The Void", "rdagonfruit icy", "time too tryhard", "democrats SUCK", "erro 1mil im so bad:(", " {}?{}{}{}{}{}{}{}{}{}{}", "get error to 1m", "why is anni overrated", "kakyus222", "Have you seen me", "Arena Closer", "hiiiiiiiiiiiiii", "im noob", "Tattletale", " GoodLuck", "bazooka", "FFOx", "wellerman", "dont trust anyone", "eng pa", "Summoner boss", "kostas friends ? greece", "V:", "CorruptedSpectro", "hohohoimsanta", "1M ????", "BOOSTER AIRSTRIKE ORELSE", "nashe", "Algi", "(vn) go with me pls", "FPT", "2020 im new", "Player", "jkhhgg", "Cody", "Eiffel Tower", "BEST", "EVERYONE BE DESTROYER", "Pray for Ukrainian ppl", "prb", "Attacker", "RACE", "Yael", "Q Checked These Names", "(W!) Solo w!", "111111111111111111111", "GiantJustice-", "Nate", "Can pls be your friend", "Cxrrupted", "yourself", "you(VN)", "khoa fake:)))", "1VS2?", "IDK", "plplpl", "minh7cvn", "hehe boi vn", "Sinbadx", "One.", "Q is Awesome.", "laco", "RPs", "meris", "Harder Demon", "Florentino", "Well", "jerry", "Hut", "Pet bird (eat triangles)", "mustfarm", "I bet you never", "FeZTivAL", "Kid", "ABC", "PH", "Starlight", "MOONLIGHT", "STARLIGHT", "drift", "vilad", "MURIQI 03", "The Light", "cat", "DRUNK DRIFTER", "WHy", "mmm", "arR", "FINz'D", "aaaaaaaaaaaaaaaaaaaaaaaa", "biba338", ".chao", "HNY", "$$$$", "cat o' nine tails", "Block Craft 3D", "BRUH", "-vn-", "Azra", "bin huhu", "00123", "CN Tower", "t143", "Te", "Gun", "Sans", "Fggf8ytr ftrfbtruf7rtfru", "Ryuu", "overlord king x", "emir", "empire", "Player 1", "NAtZac1424", "BOT-342465", "Hdujdb", "We_peace_farm", "tuan", "A1D2J3", "323f", "MYJ", "bbebebebe", "T", "peace_farm", "hoang118", "lol2", "lol1", "gtegnugnbdbdtui", "the guy", "sang", "/SUP Maths", "_-zErO_-", " Gaurdian", "5C", "DJT", "silvally 1v1 me pls", "Arena Closer", ">:))", "valer", "G,bdx m", "|A", "No Ski||s", "Etz", "The Comeback of 0800", "sinbadx", "QWEr", "I need 3 1m more", "Njayy", "NOBDY w", "Sh |             _", "xs", "Jet(pet)", "INDIAN", "The Immune System", "TATICAL NUKE INCOMING!!!", "bigmac", "jjjj", "woi", "protecter_of_free", "bye", "WZ_120", "let me protect u my lord", "IMAGINE DRONE IN TDM", "wewewe", "Max", "Nothin", "uh", "Ancient", "NNNNNNNNNNNNNNNNNNNNNNNN", "MAXICHIBROS", "Belowaver", "trboo", "T^2", "Carpyular", "e04", "turbo", "Sei", "trbo trbo trbo", "Hymness", "red sun in the sky", "maze goblin", "Wojak R FuNNy", "Cloudless", "Hey!", "stacked", "sudu", "Launchers no buff no gg", "Sh | cc_", "Xentnya~", "Xjso", "Void", "nobody", "Pop", ":) cavite", "ja", "THEIA CELESTIAL RULE 34", "2 0 2 2", "i Saw LimeinSoccer penta", "WatchMeDestroyYou", "the new era", "osuer", "NOOB VN", "aleph", "cjccsqb", "lusy", "uudsibfhb", "ssdd", "trying out factory", "bo ckick R", ":b", "DarkHeart", "sd", "Bi", "ax", "23", "Ht", "rest area", "korne", "Around Calm", "duo octo", "Know", "Bruh player", "huh", "LintanR", "all my friends are cool", "lth", "Ilikefarming", "mie", "yo racingboi", "Kylaura", "HI!", "Leonard", "None", "ya", "Evaden K", "AZU", "Eating Fighter ^Silvy^", "Jeff", "elecgance", "667ifjfjijfo", "Necromancer Pet", "Vakst", "Forgor", "The Sliding Door Com", "Nest Keeper", "ka boom", "niitrooooooooooooooooooo", "mada fking", "Inside Out!", "healer", "Average DPS enjoyer", "i'm friendly", "Pablo", "Necromancer",
                 "saffy", "Manager", "nmnmn", "Leon", "(vn)TTT", "NucelAR", "benni", "-1", "proo..", "chicken wing", "Zasriel", "Ground", "Fairy", "='))", "KSA", "DOMINATOR", "packy", "rrrrrrr", "xyz", "Gianan", "=", "VEISEL", "space", "bibi a", "Koi Fishes", "600k is how far ive got", "u POO", "dfhdhgsdgf", "pighati", "BT_O", "3w3f9", "@@@@@@@@@@@@@@@@@@@@@@@@", "rain and fezti", "Arena Closer", "Sara", "b b/", "MG Post", "Rock", "The Truth Untold", "FireStorm", "chew 5 gum", "EreN0", "", "AI", "netherlands", "la couronne", "stone", "bello", "SUS", " OVERLORD HEROBRINE", "Chaini", "nhi015042012", "meo & sup", "tomnguha123", "uoivhhfgrryttyhj", "tyty", "taem?", "Nividimmka", "I use underrated tanks", "u stupid", "ferrari", "", "thearch.hmmmm it lurks", "i won't let it end", "college sucks", "color", "l7er max", "Duy Lee", "ugok", "Booster race :D", "im a joke", "ms tang", "ssssssssusssssssssssssss", "Elson", "BILL WIN", "Root", "el pogero momento", "I'm Friendly", "huggy wuggy 2", "wibu", "Griffy", "solo1 -1", "Like crashers", "wispy", "nice", "BUB", "X-BOX", "Gregoryelproo", "NEYONSTANK", "Closeyoureyes", "Utilisateur", "1% Power...", "SillyPantalones", "over 'GOD'", "First Time Play", "Arena Closer", "BoW", "Data Expunged", "Sped demon", "JOKER", "SIRENHEADYTs lost pet", "ggs", "hfski", "Taklao", "hack", "hi!", "karol43", "Aaa", "My struggle", "Italok", "Ghi", "Phycron", "fkdla", "dinogis", "HxD", "Battle Tank", "rt", "kral kaan", "leo!", "ndn", "222222222222222222222222", "leo! hel", "lumity", "kha", "552", "V VAG", "Windows 8.1", "'>'", "888", "mwr_csqb", "ANTI OCTO TANK", "mwrtql", "2022 SUPORT UKRANIE(2)", "thomas tank engine meme", "johnrobin", "Lostvayne", "ck to la roseanne", "Guard", "Bartek", "ww3", "doomsday bunker", "Hydra", "REVIVAL:", "Gggg", "Rick Astley", " HEROBRINE", "AFK", "BaLu...", "fux", "yes", "Raul39", " Sinbadx", "SAENG", "TAIWAN protector", "bird said the n word", "me(duh)", "19$ fortnite card", "use this tank with me", "got 3m og save cant use", "sheesh", "Override", "Xiggy", "Saika", "jeb", "sant the sant the sant t", "uYu", "Panzer", "steeg", "Arena Closer", "i go UP and DOWN", "i like walls cuz round", "azuris lol", "HMMMMMMMMMMM you are L", "Murdock", "Optimus Prime", "Sleak Override", "ridah", "ballistic 2.0 fnf", "pulp", "u really like to hide", "ltbc", "when the", "Gangsters_Paradise", "Cochon", "Just Having Fun", "kavin", "Good Job Chicken", "0____0", "25m", "im poppin' off", "koral", "peace :D", "Medium tank", "dark:)", "kiet", "The One", "tilvlad", "Superchad factory", "meids", "the ruler of eveything", "GetRekt", "Nothing", "h1h4", "FOLLOW ME TO VICTORY!", "ciken", "this is the tale of", "Lera", "-heix-", "insta: 'brn.o.z'", "lena", "Ur4ny4n", "Byakugan!", "Lx1000000000000000000000", "turtle", "what tis going on here??", "Comeme Soy Dulceeeee xd", "Arena Closer ", "uirouri", "bruno", "Kaiju spacegodzilla", "haiw", "Heandy", "78d", "S. Liza Yt", "I don't need a Partner.", "CS Dulce oh ok -_-", "ninja", "CS Dulce i some tired-_-", "| AL | ChillOut | WWS++", "dragonfruit icy 1212 X4", "CS Dulce u no are friend", "i like cheese too", "Don't touch me", "look llllllll kkkkkkkkkk", "Dogs On Mars | no N", "box", "super", "CSDulce  .      _      .", "hope i dont dc", "A A A", "im your pet", "venom", "Hlp my ky r brokn", "ok la :)", "ffdf", "soccer", "(-)", "Mikasa Ackerman", "peasant", "get better bozo", "CARELESS(I care less)", "xz", "MARY", "DVS|| BuiltKIDD", "|AL|ChillOut|", "jajajaj", "Yimo (Friendly forces)", "HECool", "Just Spinning", "KermitHasAGlock", "AL| JustICE-theresaclone", "Sean", "ezzzezezezezezeze", "-Corrupt3d-", "Greg the Hunter", "hypertone", "eRAnnnnnnnnnnnnnnnnnnnnn", "mafer im sad 3<", "Nageron", "Eric.  The. Unstoppable", "Earth is Super Cool", "annoying tank", "ovMasted", "Turt Talks to Much.", "tanvik", "Here Were Dragons", "Cheese and Perfect RNG", "Mega :)", "Betelguese is Super", "error error error error", "Boomer Humor", "Violin is Interesting.", "Elite Celestial", "PROFIN try's 1m scores", "Big Poppa", "BUGEN+", "Saika/Na2/500ms+", "devil", "JACKSON", "Masher", "shuna no 6m", "YOU NAAASTY", "yahhhh", "Zephr is Mod???", "$1,000,000", "Rk", "1010", "idrk", "Calob", "It's all okay.", "fr0z3n", "TRASH", "Abrar", "c@rt3r", "pwease?", "thearchy", "Zort", "pwease lemme get 1m :D", "shush cat", "Mr lord have mercy on me", "xDer", "tennis", "ZEN", "multibxersin2tdm", "Bisax", "hhhhhhhhhhhhhhhhhhhhhhhh", "Arena Opener", "This is a Laser tank", "GOTTA SWEEP SWEEP SWEEP", "167", "Rusher", "bcj8721yt", "awa", "Ron_scratch", "Ahmad", "highh", "(O.<)b", "Op", "Tenzo", "Xlemargg", "hghg", "Legend", "PewPew", "Auto factory 19187944889", "Taha and Sardar", "Cc", "Wheaple the great", "VT", "LEGENDARY BEST", "Rd h", "GX", "maxi", "Doanh: basic win vn :)??", "bb8", "breaden", "1 cannon only chall", "Kino", "quang", "FRIENDS TO ENEMY", "NB", "hoang", "Inevitable X", "say cheese", "Anken", "gun boll", "soy sauce", "PUNSIHMENT", "Domain YT mobile player", "badog", "longvn racing boiz", "nicola", "race", "RJ", "eloxus", "kjiegu835946793", "Level  fun", "Purple2", "Hmm", "vicrouss", "GIGA CHAD", "Auto factory 37448936323", "NO ONE", "cai chua", "Spring Bonnie", "ALPHA CHAD OF CHADISTAN", "ajajajjaja", "dustnine22", "let's begin....", "DuckBatmann", "125   mn", "giraia", "Shoot double", "Spawner > Factory", "Fade", "Pat", "Kol", "max", "njs", "1+1+1+1=4 OK!!!!!", "POU 2", "morbius", "Sven.", "Prm", "Arena Closer",
                  "no teem", "forest", "Im friendri your order", "(Tank) snowy! (Tank)", "Ur momma's", "rowan", "boknoy", "Shide", "redrealm", "lor", "-CN-", "yup", "Ahmet", "-CN- ", "JUMP ROPE 10 TIME IN ROW", "YOTTA CHAD", ".ium expanDeR!", "elecgance4", "fix performanz, devz plz", "UrBadLOL", "suffer", "Destroyer", "ZZZ", "IM AWESOME", "tHE great king", "Nafi", "micsodaaaaaaaaaaa", "Raid", "W1lleZz", "saibou", "That_Thing", "hexagonal", "Koala", "NEVER GONNA GIVE YOU UP", "simba", "Crush Limit", "No pp for u", "Arthur", "kiriloid", "AZERBAYCAN  TURK", "Arena Closer", "thien5011", "Raymond bince", "not  tifo", "THE FAT RAT", "greedy", "lightz squad", "64t", "Tri Angel-Booster", "sanesytp", "wasd", "Ryland", "Fallen", "PUSH ME", "dgfdgr", "Booster join", "Dorcelessness", "obed", "soy noob :,(", "Triangle Gang", "Dont pee on the floor", "Good!", "Andy", "ccc", "Gee, thanks", "WHATS UP BOI", "aronnax", "Person", "Annie", "Mellow", "TU VIEJA", "ace", "WoW", "friendn", "kirilloid", "meme", "sacapak", "Ethad", "Da boss", "XLF", "abominacja", "doge", "I'm Real", "sprotto", "Polandbanner oo", "brazen", "QUESO Y TORTILLA", "EDI", "A tank", "bvaietd?!?!", "eda", "I don't know", "badda", "threuagnduirx 1234567890", "gabi", "pastry king", "Ball", "gab", "Catalyst", "sssssssssssssuuuuuussss", "Healer", "put Factory", "Funky Fresh", "XRECS", "mlk", "3-D Julie Cat", "Elite Crasher", "Nina", "One Floofy Boi", "Tailred", "raindog", "SPEEEEEEEED", "unikit", "adrik", "Fallen Factory", "Caca", "orange", "Cj", "carlitos pro", "ghostly_zsh", "poly :/", "imagine spinning", "kom", "austo asa", "0 helpful blues lol", "Sandwich", "The Influence", "F for Froot Loops", "Machine Gun", "Director", "ChEeSe", "Mud Muppet", "RSN", "5th base = best base", "A Poisonous Egg", "'CADO ON THE 'BOARD", "blue suck XD", "lumos - kms", "blue suck so bad XD", "Lifeless..", "igh", "<<< Saved by Grace >>>", "agdgdgdr", "youencounterHIM!yourDEAD", "dinmor", "Jess", "La-BareTTA", "Aim(^-^)Bot", "78d pounder op", "Update me", "Comeme Soy Dulce wateer", "Ainnim Loof", ":)           (:", "Windows8.1 Pro Build9600", "a spinner", "FAIRY", "Better Than U", "Eesti", "sssss", "Friendly Elite Crasher", "MAICK", "EIDOLON", "cx", "YO what? bro im out...", "Rest", "TheHero383", "Swohmee", "Swohmee: HowDidIDoThat!?", "pet brick", "houses", "SIUUUUUUUUUUUUUU", "S45vn steel op", "Astrageldon", "ijklmnop", "afk leave me alone", "Anti-Hax", "protec me pls", "Gonials > Bird", "Jachris", "Aj is dumb", "code master", "MONTER", "kase", "JaredTheHirdoryGod", "devon", "kase is good", "spider .,,.", "lily the pad", "Arena Closer", "Gorilla gang", "Alejandro 22", "botanical torture", "Egg Spawner", "ghhhhhhhhhhhtoast", "Chungus B.", "Maksim", "Enderian Overlord", "eef freefzz", "Little Timmy", "Flashbacks", "dread", "ffa till 1m!!!", "wuzz buzz chuzz", "percy", "Space", "kraken", "BR PARADO", "Sry m8", "Chobblesome", "yee", "gtrr56e4e5eerer", "ELITE", "Krystal110607", "Survivalist", "Kalijia GG", "Kalijia Let's Peace", "eeeeeeeeeeeeeeeeeeeeeehh", "coriander", "Mat (Bocow)", "SIUUU", "bro doesnt have a life", "your tail", "eeeeeee", "<call me", "Numb The Pain", "hi ;)", "pierre", "the quiet kid", "nom nomnomonm", "ggggg", "Adventure", "notable", "777 ////. ./. /./-.---77", "PowerPoint", "FALLEN BOOSTER", "Ecxel", "ye", "LIBE", "bukaka", "notlazar", "errora", "ManiaC", "NobodyIsReaching500K>:(", "pescah", "fvha", "pesca", "Innkeeper Worm", "Blarg", "=ZZZ Bannanas Are Yuky =", "GRRR", "Try Thalasin Today!", "Thalasin OH GOD HELP NO", "SILIKA", "Fallen Auto-Tank", "SYSTEM", "is op on siege mode", "G vytvyv", "guardian", "ya mom", "Lorain", "A br stranded", "matew", "matatoe", "dante", "Maize", "Arena Closer", "Ouake", "khe", "i only farm", "DESTRUYE SQUADS", "let's go!", "no pressure", "Manoso G", "Indeed", "Lets be frands", "Bunzo", "vyn", "ok so...", "haha", "cooooooooool", "Ye boi", "Quest", "GOAT", "kool", "8hu", "bryan", "Aadhy", "Basic", "Eleanor", "OXZ", "speed", "az", "ura bot", "78d 714k bruh", "Partisan", "eli", "frend", "Death", "Azerty", "Stalk Is Actual Pain", "fdfdf", "extreme hapiness noise", "begone", "Apex", "Wynder", "oof", "im watching you", "chill", "p", "-heix-", "Savage xD discord?", "crocty gets 1M first", "iv vs 3", "im bored", "ERROR windows xp", "(B) Wehrmacht", "FRNDL", "Lonely :/", "The N2R", "qqqqqqqqqqqqqqqqqqqqqqqq", "sven", "phi", "P", "Mushroom", "1MiL", "stinky/ gg jax!", "bay sorry.", "ツSpazeツ", "Mine craft", "nob", "/:", "Legendary", "vinh", "Moragull is JOHN CENA", "A-K 8000", "CorruptedPenguin", "C@t has C@p", "Stealth Tank Delta (STD)", "I WANT A HIGH SCORE", "tim", "UltraOmega", "PPPIIIGGG", "shark bait", "nek minet", "g'day mate :)", ":_:mx", ">=<", "run", "fire exe", "The Best Player", "susicoi", "Nerdy Ball :)", "cor", "Defender", "SlowKnife", "1+1=11", "my", "HUNG", "Deep", "Emilnines", "lol:):):):)", "Orca", "the legend hero", "/donotello/raider/", "YT=GLITCHER TM", "Jagdtiger", "On mobile", "The General Lee 01", "TeSt", "The Palidin Tank", "DaRk", "0jgojettreedew089", "ghost", "213", "twan", "Spectator:)", "uywu", "{}{}ALEX{}{}", "daniel", "Sol Blaze", "poly gone :D", "im 100 years old", "Re Fachero", "Blumin", "jhonny", "supreme", "D0M1NAT1NG++", "SAS", "Nailguns HELP!!!!!!!!!!!", "Arena Closer", "darwin", "djbd65", "JustLurkin", "im sorry", "race with me!", "on de xd", "Paladin-Celestial", "russia", "CHN fed", "sj", "13isaluckynumber",
                   "i suck", "ah, but u cant see me", "a mongoose", "rae", "Z", "323f54", "lev", "Ultimate Dominator", "WWZZX", "Goku drill", "laffy taffy", "good luck", "EpsiCron", "Eye Of The Sahara = City", "Shields and Guns", "Tester BT", "outrun my gun", "invincible man", "Necromonkey", "HENRY      ANOS7", "TailQZ", "PPANG", "Tester", "a sentilen", "Jhon the nub", "arrowz", "Annihilhator bravo 1m po", "just boone", "hybrid", "gg gmzin", "we do i little trolling", "Jorge", "NgocAnVNA", "Sh l", "DUO MONETER", "Coapc", "timi po", "Why Buff Factory?It's OP", "Storm King", "Enter to the Dungeon", "frrrrrr????", "shutgun", "debris", "NOE BODY", "Dr pizza eyes", "Protect me", "How to get you", "sit", "Caracal", "trashmxnn", "Cat", "Angel", "baLu is kinda cool", "Tanky's 30th 1mil?", "i need a pee", "josh", "ggs (1m!)", "fed", "(Ai) bot", "hijo de su putisima madr", "slowpoke", "NO IDEA", ">_>O_O<_<4567", "hi saya", "ryuuddddddd", "Random Guy", "vn nha", "Just a Spectre", "manoso", "joshkidkid", "sg", "TON | 618", "mogerath", "vc landmine", "worst impact", "Ma$t3R=No Ski||s", "aajlrtgtrtty", "korea no academy", "Behemoth", "VN TOXIC", "dh_hniV", "no vn", "bruhhh (vn)", "1M=100M", "frrrrrrr???", "ggh", "lakf", "imscared", "Wow", "(<(:)>)", "STOP", "Tale", "Leo", "!^_^D0M1N4T1NG^_^!", "vortex", "blue", "Sr. GT", "eat my bullet", "fudgg", "RATA INSANA :/", "Find Me", "PHRENTINO", "bro follow me", "Xyx Wdtcfgzezgk", "fencer add me on disc", "super shock", "GGui", "Rafael", "moblie 1.37m siege woo!", "Surprise Surprise", "king pug", "Emily", "Hm", "Marchin Through Georgia", "Aha!", "huff", "jummer", "bixent boo", "Bao", "AAAAAAAA2A22222222222222", "uhyi", "press u", "HI Yoou", "aaaaaaa1", "LMGshooter", "1922", "-KONZ-", "Waloh", ":(((((((((((((((((((((((", "obyness", "BaLu", "Zod", "spin=friend", "Ashes", "the UNTIMATE DESTROYERb", "MYLEFTBALLHURTS", "Xh", "ravi", "sorry sorry", "ZasrielDreemurr", ": )", ":?", "TaKE LOl EPIC auto 4", "Shankerith", "Hunker down", "!!!", "being afk", "TienBach", "fun.", "Zzz", "Annoying", "Juna", "new player", "Xander", "duda", "ppoppoppo", "One of your pets", "kolibri", "panzershreck", "EwE", "Deus ex Machina", "Pilav", "berd", "NO your mom", "1e+999", "Cristay", "nuiw", "UHF", "insert handsome face", "PandaNa", "nnnnnnn", "Energized", "Cirrus5707", "Ferge", "not boster", "shuna wakuwaku", "Rongomatane", "press n to level up", "bubble shooter", "Turret", "super pro prot 4 you", "45453", "Despair", "Ho Ho Ho", "Y.S", "Arena Closer", "john", "96", "Auto's power", "2 Booster = Fun :D", "Press C+E: Octotank", "you were so mad", "Sky", "need protector", "Great Bydgoszcz Reich", "superman", "ridge", "hahaha!!!", "HELO GUYS", "vyey", "Vinaphone", "hiiii", "ZERO", "el epepep", "T   W   I   N", "5252525", "121", "iar", "avex", "Taboo", "since 1986", "meow", "AUUUUUUGH!", "xtrw", "On Mobile", "PRO123123123123123123123", "Kira", "gray", "eeeeeeeeeeeeeeeeeeeeeeee", "StUfFy_ChEeZe", "????????", "4th Form", ": ) ha ha", "OL Impossible On Mobile", "1v1", "BBoRRaBBiDDo", "hu", "pp", "slow but friendly", "vn", "loler", "Atumkj.", "fast boi", "MYRIGHTBALLHURTS", "1111WW", "odszdc", "Withering", "eafscx", "eeeee", "Sudu", " sub to", "T-Chan 13", "|^Robo-Birb^|^Silvy^|", "Korea :D", "Sidewinder-firebolt", "asdasd", "Agent Sauce", "vinud", "1 + 1 =1", "Xqaris", "WatchMeDestroyYou ol 1v1", "builder", "nnnnncaptiann", "Gawr Gura", "WatsonKong", "yx", "aewrsd", "Mmmm", "...VN", "REVENGE", "Mwoon", "turbo bro", "Hiu VN", "FF9JesT", "Fallen E", "hgdgt", "Fallen Hybrid", "SORRY..I'M..(vn)im so :(", "yaaaaaaaaaaaaaaaaaaaaaa", "supperlenny123", "The Underspeeder", "Anime", "AntsAreCool", "king of ...", "ghgh", "arslan", "I see", "chicken", "dkd", "777", "Engineering", "Push me for barrier", "oop zeros", "Mini moving safe zone", "goku", "fgg", "Jagdpanzer IV", "()UTi6", "zaq", "USSR(Russian)", "Stocxk_", "the things we do to surv", "asd fake", "HHH", "Swooper", "ayo", "hara ...", "ya YYYYYYEEEEEEEETTTTT", "Kyrie o.O", "Updog. Dying Breath. 2", "WHYANDWHY     Y_N_Y", "hara )))=", "I'm Q", "-Monster-", "Anak", "Mine says hi fake anak", "the sky", "Master Noobpet", "Viva", "maze", "oompa loompa", "Egg'in", "f(x)=k", "go to 10 mil record", "Trying to be peaceful", "Tunnel Wanderer", "Boop skdoo bep", "The Beep MAD>:(", "Speeedrun 200k plss", "The Boop", "Kaiju you", "dragon sleep no brakezzz", "kracc bacc", "24686872678", ":", "OnovonO", "Arena Defender", "Arena Closer", "naga", "asdfasdfasdfasdfasdfasdf", "Ace", "Pkao", "insta 'brn.o.z'", "aswon", "sodbazar", "The Hybrid", "aswon(ur bad)", "Troller", " nothing", "IKEA Box", "Vaskrano", "Si", "A+", "the beep !!!", "A+ Yeah spin", "Dr J.I.D eyer", "xijinping", "shheshhh", "pRo LiFe", "AZERBAYCAN  TURKIYE", "Just Existing", "3.14, 1.61, 1.41", "Ozymandias", "ok i pull up", "funnylemon", "TURK", "1212", "Learn with pibby", "LUKI", "Seer", "mkZZZ", "niwa niwa", "nhan", "1223332111111111112321", "Arahana", "The Robot Kid", "vokki8skand", "Turret LV 1", "AQEEL", "AnA", "yahya", "ninjin", "Soulless", "EMO", "1010971", "pokemon", "VN 3", "alright buddy", "FR|Fajro", "Walorried-TR", "abuk", "Dead server", "Arena Closer", "zae", "zeraora", "imnew", "elecgance404", "heck", "Tomi", "SPAS-12", "tran duc hieu", "GGuisa", "viwpo", "BERD", "Blocker", "bcr", "come with me guys", "ehehe", "rule.txt", "big chungus", "t. food bc why", "lk;k", "SERIES 113 JAPAN", "sir bobybop", "G1019_t", "grendel", "andria", "VousyX", "LAINofLAIN", "ferge",
                    "vilad pro!!!!!! :)", "Ali", "xzxz", "This is the tale of FFA", "MIKKEL ", "knjbfhiu", "Raknar", "free fire", "The Unknown", "Motar2K", "drifting", "OrangeCat", "Ddddd", "hi long tri", "some random oreo", "WEEEEEEEEEEEEEE", "speedrun", "DatBoi", "Michel", "71", "jacquie", "Exendern", "Jack Daniel", "Bob le bricoleur", "=W=W==", "ft. Karmatoken", "Arena Closer", "stfutduy", "vaboski", "HAAAAAAAAAAAAAAAAAAAAAAA", "alsterercrak", "The Big One", "Sorry", "JzF", "ZZZ ZZZ ZZZ!", "hey moskau!! moskau !!", "EL TRUENO PRO", "tokar6", "nho", "Dusk Defender", "ooooooooooooiygf,fss';", "Wa Sans ashinenguna!", "aeaea", "nothing's", "the  best PEOPLE IN THE", "4/4/6/6/6/6/5/4/1/0", "Kazakhstan", "starlight!thunder!", "Mr D", "protected", "Uncle Iroh", "><II  gg", "dssfb sk", "Roly poly player", "jonyy0814", "KOREA", "1 min", "Winter", "zaid x", "Will join me?", " lucas", "MATI", "xDer MY FiRST 1M", "Seig", "oopsie", "nhat", "DAN GYUL", "Claire", "567", "stalker", "kotetsu", "124", "DraXsaurus", "My 10th life", "bhosdike", "sjw", "Karthik", "hhhh53535", "ciao", "sumoga", "brrrrrrrrrrrrrrrrrrrrruh", "jony0814", "rubyslime", "Yuvyyuy vyu", "Sppooky", "THIS IS INSANE!", "Bozo", "hex", "EJIT", "+S", "RENGAR!!!", "Nelly", "sadf", "UNKNOWN LEGEND(UL)", "hi im friendly :)", "llllllm", "Jekyll Why", "AL | 2 Week No Play", "Protector", "toothpaste", "sasukeuchiha", "ricegrain", "Deed", "vikitor", "fIrEbOt", "Machine gunOP", "mini", "Nice~", "quant2345677", "Oxylit", "totie", "hhhhh", "scx", "Ayrton", "LETS GOO", "Izumi-san (VN)", "Panther", "meckazAN", "men treibe", "never gonna give u up", "never gonna let you down", "never gonna turn around", "Arena Closer", "never gonna let u down", "yeahs", "Ruan=_= ", "Panzerfaust", "emp", "Tiny", "THE BIG ONE", "The Ranger", "DuckBatman", "Hatsune Miku", "Basic Enjoyers", "hhfggddfdf", "The Mind Flayer", "Dance", "Ar 15", "XSET", "Milton Friedman", "Mr KaRbS", "Duong 20712", "playeur", "<======Lasi======>", "Mardi 1", "Ethan", "fellen 0", "Venom", "-_-Aigle Royal 72-_-", "Alt+f4", "swrmur op", "Bean Man", "atomic", "Annoying drones", "Colors all around me", "okey", "GIANNIS ANTETOKUMPP", "it's a lie", "hy", "pc", "mustard the rohirrim!", "Kingdom Hearts", "Mebh", "Dr. Eggman", "Choose otto we stronger", "protectsage", "pov:u need 5 prot for 1m", "TR Angela", "MadCroc", "sage", "robo cop", " weirdo", "Shiny Triangle!?!?!?!?!?", "Gem!?!?!?!?!?!?!?!?!?!?!", "blon td siix", ":: Saved by Grace ::", "maze runner", "MadCroc 1.21mToday", "be free", "Carry", "I JUST SUCK", "gemgemgemgemgemgemgemgem", "ur all bAAAAAAAAD", "Spin = Free Protector", "HELPE ME FOR HELP YOU", "Rosenrotteneggs", "Mr. Lord", "PFC|| KEVYNZ", "Hybalixa", "hows your day", "b I protected u before", "awootube", "there", "Julia", "seve", "Arena Closer", "hguyuthg", "hop", "i go high", "the return of chewy pie", "Jerry", "mf yeezys", "King Hans", "sven drop", "I Voyage Around Map", "biggest noob", "dog", "IM SUPER RETARDED!!!!!!!", "The End!", "Engineer Army", "lolnub", "Salt", "MOAR OCTO TANKS!", "KN-23", "nothing", "sonic", "Nirviar", "asw", "dom is easz", "sghhgsfhgsfghsffhshg", "Jerry - LOL", "server", "D4C", "BigBrain Time", "player 8483", "Turkey", "Deve", "LintanG", "STPSPMMNGSNPR 64M3R_999", "PaX|A1ma|YT", "kaan", "afes", "ly", "ulan", "Purple", "Hahahahahahahahaha", "fahrradsattel", ":('", "he", "NoSpeak", " lu", "Fugitivo BR", "Crossboi", "Noob", "Gabriel8", "pinkie pie", "Wowkoks", "Zweilous", "oui oui", "asian kid", "top mozis xd", "Kofolka", "AcidRain", "a shield", "glitch tale", "Crong crong crong", "!!!!!!really happy!!!!?", "(vn) :p", "udhe7f", "phil", "Mort (pc)", "askib", "jygghhjj", "Last remote", "tttttttttttttttttttttttt", "asddasda", "LIGHTNING DRAGON X 96", "Minimal", "jelly", "Your Mom", "Peaceful", "respect women", "Darius_575Pro", "csabi", "7859", "tenk", "rayyan", "Fei", "Pango", "eeebot", "giranha", "spirit of the forest", "dark", "pro player", "Yeat", " %<AzEr<%", "notPickle", "Reflex", "Me", "Stalker Army", "Qin", "Predator Army", "NYADRA'ZATHA", "Roaster and Toaster", "CSDulce im boring :=", "Szymon", "es ta la vida que toca", "@RAFAEI  PR0", "$:$gc", "Suomi", "spankthemonkey", "KANG OF WAKANDA", "Ark", "tiny ones my friends", "op xd", "fence", "III", "GPA", "Bonaventure", "witherrrr", "mahiru shiina??", "(B) THE RISE OF THE FALL", "mahiru", "May I Fuq You?", "ID", "trying for world record", "75882310770", "PressNToLevelUp", "Dont TaLk 2 mE", "Do Not Disturb (oops)", "Wyd_Josh", "Pentagon protector", "tri-angle is paccific", "Good", "Do Not Touch Im AFK", "WiFi-Kun", "Bullet Bill", "pentagon protector", "%<AzEr<%", "PROOO", "ice tea for free", "Waiting", "busco pareja7w7", "agabaga", "SOLO AGO MI TRABAJO", "necro pet", "Kael", "Trash Anni", "Sev", "wypk", "G.A.P(MG)", "nokia", "Twin-Twin", "bronzzy", "Guy", "Ytt", "Ayman", "Zyiad", "Ahmed", "the general lee", "a littl' bad", "Bonk?", "SEBASTIAN.", "aIIan y sonic", "bigchad", "N05O7G", "Tengen Uzui", "Prees N", "tree", "SPILL THE BEANS BRO", "Escort Carrier", "HEEHEE", "X_DROP", "XboxUser", "55564", "porscheHUB", "Tenth Circle", "Spectator (dont attack)", "summoner2", "sentry", "The Covenant", "Storm", "itachi", "Only 1 Factory Can Stand", "TOBI MARCH", "Come Back Here!", "Spider cochon", "Crash And Burn-Dayseeker", "Clearing shapes...", "BOONE!!!", "tr ndxd", "lurker", "SONIC GO FAST!!!!!!!!!!!", "Covid 19", "tar tar teha tar sal-t", "Ray of doom!!!!!!!!!!!!!",
                     "lautayo", "Herobrine", "let u know", "Peace and Unity", "kelly", "wingarr", "aIIan", "SEBASTIAN", "Sonic.EXE", "fghjijb", "the all seeing eye", "blitzburger is pro", "trust me do this", "Beans", "qwerty", "lucas", "Domb", "Kronos - Eternal", "45a,i", "unavaliable", "happe", "Racing?", "Buyandeho", "Mobile Not As GOod", "Arena Closer", "Ok Ur Done.", "alex", "Siren", "Defenders of The south.", "Ok Ur Done. Again", "ssad", "SAGAGH", "dwada", "Says Overlord in Green", "Wolf272", "Sry had to go afk", "WerestLuck", "press t", "corner base trust me", "nah i", "FIGHTONTHEHIGHTS", "jaxon", "Dark Pheonix", "porfavor venganxcadddddd", "Toxic", "iurgitues", "lolstar", "harnesto", "koby", "Shiny Beta Pentagon!?!?!", "Everyone Go MachGunner", "hi I'm pixels", "GREEN Barricade", "oo i m friend", "ASKED", "Xtrem", "NopeTurtle", "porfavor vengan", "Chompy610", "Drones are gae", "Penta takeover", "one of the players", "Avenger!", "Sleeping Quadrilith", "dewfew", "king bob", "one of the newbies", "Spectator", "Fistandantilus 39 AC", "BIG POPPA", "diana <pleayr>", "Really:D", "Kenobi!!!!", "arias", "Arkaic", "i have sponks :)", "jor", "Arena CloserSinx :)", "ALL GO BENT", "Evades 2", "freee", "76...", "rigeeS", "Arena Closer", "ZEB", "koten-", "green", "little one :D", "Factory Takeover", "PRODIGGY", "Scratch", "1% Power", "Thank you", "OTD", "pet lvl 30", "world's best anni", " DONCRAK", "gnghfiukfhfj", "MASTER", "mi(moblie)", "let be friend", "defenders", "father landmine", "overlord takeover", "Bloop", "ayy", "Fighter", "W.A.R", "robococ", "TEQUILA!", "As lc", "ezz", "xQD", "AGUST-D", "USS Enterprise", "Visitor", "Wolfy_11_BR", "jonas", "Takeover", "Fall Guys", "momo", "ChickyNuggyCat", "today is christmas", "NotThebest", "NO ONE", "secks", "Overdrive", "Seb", "Machine Gunner =best", "Yevery1BetrayME:(", "Nathan_1", "Tickflung", "323f54", "boone", "ALAN PAPI", "Jikang", "lenin pro", "hydro", "Toxic sugar", "M.D", "gart", "wall", "Arena Closer", "grandmas ashes", "Eat my Doritos!", "No no!", "mr.cola", "Tundra cat", "AR", "david", "nnnnnnnnnnn", "study yo orgo (chem)", "Death Is inevitable", "Stuck", "dragon", "droplet", "HI  you mom is here", "Zeezees", "necro", "luchi", "rp - on mobile", "bored rn", "Pandrian.", "master", "Lightning", "CLEAN", "arisen", "raaaaaaaaaaaaaaaaaaaaa", "3k", "qusimocho", "Trolling Me :(", "weak tank", "HunggVn", "Touriat", "use adblock please", "Q", "Arena Closer", "I'm_Chris", "fvdr5", "bman", "skrill", "royce", "Star", "QQQ", "MONDAY", "armtumroom", "Ssunseer", "duji", "ryy", "sanggggggg", "hai", "oty", "148 toxic", "no mouse", "232523", "h..hi :S", "vvn", "sire soral", "frost", "btw", "lqkf", "Senator Armstrong", "Vn hi", "Fake.Fake.Fake", "molkin", "lEFF", "notsudon", "korean", "Henrystickcmans", "crongemaster", " dyllan", "A Goat", "TaKE LOl EPIC factory", "TaKE LOl EPIC machinegun", "Tiny Celestel", "asdfasdf", "BF An", "cooper", "Unwelcome School", "EtRNInja", "supernintendo meme", "15 fps player", "Day, day, da-da-da-da-", "i will download osu", "asdfasdfasdf", ".jpg", "Arena Closer", "kkj", "pet XD", "matias", "MAY BE HAPPEN", "heeeeeeelo", "BIG BRAIN TIME", "Koronoe Chan", "BOOOOOOOOOOOOOOOOOMM", "not the guy you just saw", "shark", "The Ghost", "get in wall", "o.o", "hara vi", " ElguerreroHastaElfinal", "literally the changelog", "top", "Minul", "Trutch", "Eternal Guardian", "JOSHUA", "End", "TANK", "531714", "senbonzakura kageyoshi", "minhhihi", "LUMBRE", "HEy Im frendly ;)", "just joe", "BonaventureVT", " i look into ur soul", "Teddybear", "Overload King", "alone", "peter", "Russo-Baltique Vodka", "Don't Let's Start", "nice one", "I Will Give U My Points", "toeless_monkey", "GANG", "0=IQ", "super booster", "seperate", "Prograde", "what does reload do", "Kevin Heckart", "CAVE- CE", "happy day", "Void Fighter", "I'm protecting you! Sort", "Peacekeeper", "stares into ur soul", "Can I help you today?", "fdf", "Friend", "AYOOO", "odin <:)20", "Arena Closer", "Respect", "DontJudgeABookByItsCover", "OAO", "3vs2Ol", "Trinity", "yuan(A PENTAGON DDDDD:<)", "NO TIMMING", "wait in doing some work", "New", "Spin=peace", "retnuH", "Wall Protecter", "MUSTAFA/TR", "the deep", "CAN", "definitely not mq", "imbad", "Huy ;-;", "Gosu General", "Klair", "Ugly Beautifulness", "Dexter playz", "All Dead", "run  {ANGRY}", "VN.HM", "555 }{", "foon", "WHERE ARE THE DOORS", "toilet destroyer jordan", "No doors no fun", "Rico", "Giann", "SSS", "floppa", "Dominador", "ttttaaa", "ltester2000", "roberto", "Directors are Overused", "OverBrain", "Celestial", "HUH?", "Deepr", "Steve", "mathias", "1410065404", "ShinyG", "miguel", "yoyo", "subin", "Pega(SUS)", "cracked", "Arena Closer", "NO BAD WORDS", "PORT", "tale", "triangle drones = nolife", "TargetLocked", "Directors Are Overused", "(GG)", "qwe", "DUMB", "crocty poo", "creeper", "i just want shiny shapes", "Tommy Gun", "Your Mom is overused", "Overused Vibes", " jeje.2", "SONIC.EXE", "Planet", "-.-Razoix+?>", "Happe", "exc", "seensan", "cronge", "overused is overused", "Give Me Underused Vibes", "Extreme Speed", "j bert", "PARA", "Alan", "Friends?", "git gud", "Giant Justice YT", "yOU HAD YOUR CHANCE", "Jacob gomez_Jadenian", "mega monster", "Giant Justice YT - GG", "schrodinger = loser", "reaper of souls", "111111111111111111111111", "hostile", "ryuudddddddddwdw", "nononononononononononono", "Rocket shooter", "TTCBernard", "you deserve this", "raku", "why me???", "Rose", "top 1",
                      "-KhangWasBroken-", "Uouuuuaju", "Fighter tank", "Solar Fighter", "sqrt_-1", "(<(?)>)", "du hund", "Ben", "A polygon", "AVIRA", "A.T. Beerful", "QER", ".exe", "GHHGR'986452|", "ck to la roseannenn.", "Orxan487", "zzx", "Clink", "popoi", "reicardo avocasde", "Doraemon", "Bandu", "oofoomode", "Sneaky annileatter", "Lofi", "Cancel Those Directors", "LeaderboardAllDirectors.", "1M + StormMachinegunner", "DR. BEEEEEEEESSSS!!!!!!!", "BH_FireFreezer", "frjhjhvt", "The Beast", "S u p e r", "Nice:))", "kdk", "Legacy", "jz", "ded", "yuco", "like", "rei", "atleast spare me till 1m", "Arena Closer", "Burning eye ;(", "Petsalt VN :)", "~|{boss fight}|~", "Reb", "mahluktakkasatmata", "EEEEEEEEEEE", "LowKey", "Praying for Winter", "tinh vn", "Phat", "AditGA", "cats nya nya ;)", "On the day you left me", "into my head", "CThanhYT", "NgontoL", "spin = friends", "Expand: 8(5y+88)", "Baroydroyd", "fewillos", "poper", "149 toxic", "The _________", "rsg23", "mwmwmwmwmwmwmwmwmmwmwmwm", "msalqm", "thx ", "150 toxic", "crescent", "dark karma link:wc2100", "NobleCrafter3219", "egvda", "dark karma link:wc2118", "Gemma", "link ...", "DANGG", "This is the tale off", "Heeh", "The Fire Club", "c.ew.11.1.11.1.11.1.1.11", "pro is nood", "Random Tank", ":P", "Super Sonic", "Thai dark", "dfdfdf", "syron!!!", "strong tank", "main menu", "oblitereight 1000 ms", "its me pekola", "plungebob", ":(:(:(:(:(:(:(:(:((:(:(:", "ssd", ";kooo", "Kozuki Momonosuke", "SDASD", "Ha...Get Rekt", "be", "Wew", "321", "}{ex", "via", "Save The J'S", "ms. cold person", "FwgKing", "AnythonJS", "Theo", "BOB", "Mustafa", "dm", "Cgfsd", "Help", "{CHICK}", ",mnji", "<op>1", "SharkBuger$", "ATM", "Nining", "NEO ROY NEYEAH NAH", "Haunted", "Fireworks!?!?!?!?!?!?!?!", "Minhaaal", "Bobro", "YUU", "bob xllnnnnn", "Ailoki", "exu boi", "XYZ", "sus.", "star kirby", "Machine Gunners, unite!", "5min+5 overdrive", "Newsletter", "Meletiscool/", "allmyfriend.aretoxic VN", "Pet", "ivoree", "Twin Pro 3/3/4/7/7/7/7/4", "ka yawa", "SIUUUUUUUUUUUUUUUUUUUUUU", "ClosePro 2/2/4/7/8/7/6/6", "Snap ( Peace)", "???(vn)", "noob123", "Militant", "Banana", "fffffftt", "Hoi", "Ready For Another?", "Bossy", "ewltjdwns3673", "sa", "Don't worry I'm harmless", "freakshow :)", "aeaeae", "falc", "king4a", "ddt", "bangladesh", "Exterminate", "vIVIVgREYdOVE", "105050", "HI Youvn", "how? what? why?", "sdasda", "PYTHON", "lo hoc hanh", "who want race", "Arena Closer", "Xiao-Ling", "top 1000s", "A_C_L", "A flower tank", "Jash", "KRYZ", "Speed Build", "Tia", "Ha!Get Rekt", "hiboiXD", "Pro of ............", "vvv", "Rare", "draco", "Disaew", "Let's work together!", "iar chary", "Aqua", "Tgvy", "Ihv2010", "ASDUA", "Arena Closer", "chase him", "Nothing here", "Schwerer Gustav", "Dedeeeee", "Firnas", "yolo", "Psychic", "PLSSSSS FA", "mercy pls", "ur Being Fed", "FedEx Box", " not anak", "spinnnn", "proo...", "nn0", "the drones do not hurt", "Evil AliExpress Box", "pls Im friendly :)", "ldldl", "Like dat", "ytwjeit6tty", "UrBoringTbhLikeWhatsUrPt", "B(sian)", "bandit", "UnKnOwN", "TechnoBlade", "alien", "1934", "YoXieO", "why maze", "/donotello/", "Corrupt and dead.", "MAUS THE LEGEND", "WHYANDWHY     Y_N_Y", "GET MORE PEOPLE", "Bong Bong won't help you", "Pock", "CROSSIANT", "piece treaty with newbie", "too fast dident even get", "D A N I E L  bad...", " ryh'lrfh", "LEOPARD 1 WILD", "ya nos cargo la chingada", "Rainbow", "sssssssssssssssssssola", "lol darth vader noob", "AL| JustICE- sry luna", "Social Experiment Part 1", "Mercy", "take your time", "HI GONIALS", "i see who you are", "Cz Player", "Jap", "yeah yeah yeah yeah yeah", "Red Just Bled", "pounder", "eagle T", "Pet :D", "here to make friends :D", "Derniere Danse", "(Huggy wuggy) im nice", "PT5 | 03-04", "A Cat", "Skull", "PANZER VIII MAUS", "super perfect hexagon", "Rice", "protect perfert heha gon", "erf", "cable!!!", "PT5 | Tezerr", "Hi ._.", "WAAAAAAAAAAAAAAAAAAAAAA!", "xtrem", "eben", "1354", "far", "SOOOOKA", "alcatras", "mini boss spawner", "Arena Closer", "Eauletemps", "Aik", "BLITZ", "sinbadzx :)))))", "press n", "boom", "le tank", "dc yok bend", "Shay", "Solo :>", "Thunder", "best sentry", "dumdum", "Patterns", "R M", "FGDERTY", ":>PTM...''", "melee is better", "tmi 88>:?", "oooooooooo", "ffhfghu", "uuuu", "llol", "(vn)", "Zombie", "jellybEab", "4TDM", "pet", "ae vn", "Green Defender", "COME TO PLAY FLORR", "kr", "da", "dai", "USS Vella Gulf", "No One", "hus", "Let's work together!  N", "UNKNOW", "w r e c k", "Pobbrose", "belal abbasi", "Charles 18th", "Sir Theodore", "Arena Closer", "Hey What Happened?", "Mr.sod", "Graziani", "Ricsae", "'/;", "Anti celestial tank", "quandle dingle", "Eren noob you", "have fun crying eren hah", "MaiLotVNN", "A  l X back!!!!!", "np", "eeeeeeeee", "KHOA", "(:cai chua:)", "yulzzang", "boop", "Crazy", "MEGA MSC", "lyxn", "KarmaToken", "youssef", "LazerLOL", "HI  Five", "vvva", "GoGe", "Skawich", "Pixeljumper", "GALAXY", "Ppp", "crasher", "Min ye", "Arena Closer", "zen keon", "nzhtl1477777777", "Be Sidewinder press khh", "Indo Kok gk pro", "_blank_", "7151", "just", "tjplayz", "halo", "e5 y5gcv", "ds", "sdasdsssssssssssssssssss", "super tank", "BJ", "||H|E|L|L|O||", "swwsH", "||P|L|A|S|M|A||", "Blob", "Destructor92A", "catch me", "Coke cola espuma", "t. this green is glitch", "nhatbun", "You saw nothin", "cool dude", "Mr King", "THE PHONG", "Peace Dog", "DARRREN1407", ";D", "trust me", "2345678", "Apfel Saft", "new up :D", "Minerva",
                       "12iiw", "Just aj", "UBER_TANK", "patata", "Minecraft", "Master of dying", "mommy long legsq", "Eauletemps why?=(", "sfdgfsgsfg", "U.A", "ze", "Eauletemps 4V1=noobs", "Qwerty", "doublade better", "sunkee", "MINI ON A LAPTOP", "snorp", "TOGESH", "GWiz", "sinx7", "Mon A", "Kartoffel", "t. green is glitch", "Nxoh", "Michael Jordan", "technically octo tank", "thick", ":cai chua:)", "Gabe Itches", "you can't see me", "TOXIC", "neph", "honesty Spectator", "Injoro", "E1", "your mum", "everyone sucks", "Charge with me/defender", "try me", "pheo", "uwj", "floofa", "Getnoobed", "test septa", "", "Pizza", "U Only Run To Ur Base?", "seb", "Maddog", "huy vn :D nhu loz", "Arena Closer", "Chicken KenChicken ken", ",l,l,l", "Comet", "Zhynt", "christopher", "The Mandalorian", "TomaToh", "tntman", "Tim", "spayer time", "piffermon", "Spectactor", "yyyyyyyyyyyyn", "left for dead", "iiiiiiiiiiiiiiiiiiiiiiii", "Pog", "BV", "burh", "ralsei with a BLUNT", "PROFIN 1000", "my guy", "Life is good", "pe11", "qqwqe", "0-=", "opp", "Panz3r of the Lake", "train", "furan", "Flawless_", "FourNAX", "Es3et", "Clorat suotn", "UNKNOWN LEGEND (UL)", "DEFENSE", "Rykav", "TYRONE GONZALEZ", "KarMaN", "urgh", "deffer in tanks", "rick astley", "BERSER", "WHY ARE YOU RUNNING", "booo", "WEST SLAVA UKRAINIA", "yups", "DEMIAN932", "THEBESTPLAYER", "8man", "Use machinegunner to win", "26317125   gff", "Joe Biden", "Nv Proxy", "Ethan david fernandez", "kbshlong", "wren", "(Very) Dangerous Pet", "police", "NEMDT playing shmart", "HEXDECA", "run.", "W", "sad", "try harder", " -_-", "a little bit of fun :)", "kendyl 1", "Ar-15", "Ha Ha Boo", "zay", "Rrennitten", "Monsia", "agus", "you dumb", "dino run", "Blood // Water", "Paradisal", ":O", "gulbos gulbos gulbos", "Dernier Danse", "La Espada", "Into the Light", "Planetoid", "...    ????", "swimsuit", "HEYYYYYYYYYYYYYYYYYYYYYY", "Q_us", "nom", "sentry strats", "josh how play?", "TheMadLad", "TheMadLad dylan strats", "THE LEADER GOES OUTSIDE?", "Eauletemps spin=screen", "Out of the Dark", "Lotus", "defender V2", "mmmmmmmmmmmmmmm", "TImmy", "ICBM", "animal", "Tezer", "Zver", "sindBax", "U2882JHS", "781", "Zorroooo", "I'm not bad", "IM WITH STUPID =>", "Miggy?", "sophia :)", "ImNew", "YoXieO_YX", "a pet", "TBB", "AICIAGOGH", "YANLUI", "facts", "XL", "DragonGOD64", "eys", "To Bee Keep", "VENOM", "pvto si lo lees", "grace.", "Speed", "289j", "A player", "cocomelon :P", "build wall :)", "Deino", "9902774653772", "Timmy, do your homework!", "elite basic lvl. 45", "MSI", "Make circle with Tri twi", "M4a1", "heist3", "Big Beep", "i like cheese", "Im weakest tank", "utifi", "jsohi", "cheese the best", "DOG", "cope", "F  A  M  I", "Zoro", "DarthBader", "Mr.W", "Darth Vader's Slave", "Chroma", "demon xd:alone in life:(", "Luffy", "DOOR nr.1", "pancake", "TTroll_NEW MOUSE", "ubad", "NO MERCY", "peaceful farmer", "kokun", "This is the tale of:", "Best", "Square generator", "Corrupt Z", "angry?", "Aaaaa revenge", "DEFENDER AL FRIENDS", "partially illiterate", "Napoleon", "i destroy destroyers", "not pro", "Mr.Chaos", "god is good", "Homing_Pigeon", "MazeDominator", "PM4037", "hehe car go vroom vroom", "gg partially you loser!", "'~Darkfiren~'", "La CFE me quito la luz", "nub7155 (Mobile)", "Chalicocerate - hu", "pew pew Gun", "yuma che3", "THOMAS crowded saturado", "TvT{ Thanh }TvT", "pentagon clean-up", "Go to Church", "Emi 10 ra ge hatag", "Im a landmine pls nohurt", "weird", "sorry Cheese", "dumpdump", "Rust", "Godzilla", "MEGAPIX", "demon:solo protejomihijo", "Your Bad :(", "a sweaty no lifer", "protecter crocty", "Caballo - horse", "my fists...", "playing from month", "trfhgyjhuiju8765t", "!emergencia!-!emergency!", "SIREN HEAD", "Yang", "pacific islander", "lucky", "MARK", "ALAN PAP", "nnnnnn", "dn", "Speedrun", "tre", "rocket", "B1 battle droid", "0,01%", "B2 super battle droid", "Your mum", "Goubekson", "Meti", "Wasap Papa", "tatut h", "LEADER = BANNED PLAYER", "shield", "afk ~30mins - stalker", "UHS23", "AlexDav", "!Hi!", "LOL ONYXD", "manager is just better", "Flying", "- - - - - - - - - - - -", "Roy", "Dank", "CrownPrincennnnn", "Gudmman", "CHAARGE", "GO TO DA TARGET STOEEE", "migel  papi", "Se", "PineapplEJuice", "lorain", "delta", "Jonk", "Endoy", "yeffri1", "luis daniel el pro", "Qpling", "An Endless Rise", "nerf", "8w329h", "Newb", "thicc", "just duo", "hahaa u noob", ";o", "xddd", "OSJJSJ", "Prime Chalicocerate - hu", "ilikemen", "IvanGG", "Ruwen", "moises", "jordan(:", "igoty", "vn exe", "TOGESH TOGESH", "Aprendo.en casa", "i only spectate", "DI", "deez", "Devourer Of Gods", "murt", "cocomelon- r u AA", "Polyhex", "KING OF DRONES", "POUNDER UPGRADER", "z54", "trees", "You show the lights", "Kirbo", "Turbo Bros", "stop me turn to stone", "Senseless", "You show the lights that", "T U R R E T", "uma delicia", "dohownik", "DESTINY PRO", "jory", "LITTLE GUY", "THE TERMINATOR", "hub", "GRAY STILL PLAYS", "Supsup", "Tedd", "Sup", "JUIDNDI", "ewres", "turu", "ffffffffffffffffffffffff", "soy susanaoria", "happy!", "Avarice", "im a cat", "protect me for 1m maby", "KEMUEL667", "Flowey723", "The shadow of none", "mebic", "Wsai12", "ALO", "oooo", "Hurricane", "i suck at bosses", "cv v", "ch.m", "Ovalsun", "rays", "naydanang bale!!!!!!! 1m", "poo face", "Akira bck!!!", "Arena Closer", "i believe in jesus", "SOFIA", "Yyfk", "Gigachad", "BANZAI", ">:v", "SUPRISE", "G l i t c h e d", "el mujahideen", "Soundwave", "torry", "AscendedCataBath", "The King", "Zac is best", "WBL", "Wait What?", "allmyfriend.aretoxic", "FNF Thorns", "L4r9", "Zzz Zzz Zzz:-)", "No Disturbing", "go away", "db", "P-Nice", "Duo", "nova", "hey vn;d", "DANCE", ":D hi", "dr.ninja", "Susana Oria", "arg", "7131", "Arena Closer", "SkuTsu\t", "Oh no Pathetic", "xeno", "y=ax+b", "Robleis", "Info?", "%t is the worst tank", "i hate %t", "%t sucks", "fallen %t", "Fallen %t", "%t", "%t is OP", "%t moment", "buff %t", "buff %t please", "nerf %t", "nerf %t please", "pet %t", "i looove %t", "green sunfish", "noew", "Dogatorix", "Charlemagne", "Drako Hyena", "long nameeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"];
            const randomRange = (min, max) => {
                    return Math.random() * (max - min) + min;
                }
            const gauss = (mean, deviation) => {
                    let x1, x2, w;
                    let i = 5;
                    do {
                        x1 = 2 * Math.random() - 1;
                        x2 = 2 * Math.random() - 1;
                        w = x1 * x1 + x2 * x2;
                        i--;
                    } while ((0 == w || w >= 1) && i > 0);
                
                    w = Math.sqrt(-2 * Math.log(w) / w);
                    return mean + deviation * x1 * w;
                }
            const random = x => {
                    return x * Math.random();
                }
            const irandom = i => {
                    let max = Math.floor(i);
                    return Math.floor(Math.random() * (max + 1)); //Inclusive
                }
            const fy = (a,b,c,d) => {
                    c = a.length;
                    while (c) {
                        b = Math.random() * (--c + 1) | 0;
                        d = a[c];
                        a[c] = a[b];
                        a[b] = d;
                    }
                }
            const chooseN = (arr, n) => {
                    let o = [];
                    for (let i = 0; i < n; i++) {
                        o.push(arr.splice(irandom(arr.length - 1), 1)[0]);
                    }
                    return o;
                }
            const choose = arr => {
                    return arr[irandom(arr.length - 1)];
                }
            return {
                random: random,

                randomAngle: () => {
                    return Math.PI * 2 * Math.random();
                },

                randomRange: randomRange,
                biasedRandomRange: (min, max, bias) => {
                    let mix = Math.random() * bias;
                    return randomRange(min, max) * (1 - mix) + max * mix;
                },

                irandom: irandom,

                irandomRange: (min, max) => {
                    min = Math.ceil(min);
                    max = Math.floor(max);
                    return Math.floor(Math.random() * (max - min + 1)) + min; //Inclusive
                },

                gauss: gauss,

                gaussInverse: (min, max, clustering) => {
                    let range = max - min;
                    let output = gauss(0, range / clustering);
                    let i = 3;
                    while (output < 0 && i > 0) {
                        output += range;
                        i--;
                    }
                    i = 3;
                    while (output > range && i > 0) {
                        output -= range;
                        i--;
                    }
                
                    return output + min;
                },

                gaussRing: (radius, clustering) => {
                    let r = random(Math.PI * 2);
                    let d = gauss(radius, radius * clustering);
                    return {
                        x: d * Math.cos(r),
                        y: d * Math.sin(r),
                    };
                },

                chance: prob => {
                    return random(1) < prob;
                },

                dice: sides => {
                    return random(sides) < 1;
                },

                choose: choose,

                chooseN: chooseN,

                chooseChance: (...arg) => {
                    let totalProb = 0;
                    arg.forEach(function (value) { totalProb += value; });
                    let answer = random(totalProb);
                    for (let i = 0; i < arg.length; i++) {
                        if (answer < arg[i]) return i;
                        answer -= arg[i];
                    }
                },

                fy: fy,

                chooseBotName: (function () {
                    let q = [];
                    return () => {
                        if (!q.length) {
                            fy(names);
                            q = [...names];
                        };
                        return q.shift();
                    };
                })(),

                chooseBossName: (code, n) => {
                    switch (code) {
                        case 'a':
                            return chooseN([
                                "Archimedes",
                                "Akilina",
                                "Anastasios",
                                "Athena",
                                "Alkaios",
                                "Amyntas",
                                "Aniketos",
                                "Artemis",
                                "Anaxagoras",
                                "Apollo",
                                "Pewdiepie",
                                "Ares",
                                "Helios",
                                "Hades",
                                "Alastor",
                                "Bruh Moment",
                                "Shrek",
                                "Geofridus",
                                "Guillermo",
                                "Tephania",
                                "Christaire",
                                "Galileo",
                                "Newton",
                                "Herschel",
                                "Eratosthenes",
                                "Maxwell",
                                "Lavoisier",
                                "Maynard",
                            ], n);
                        case 'sassafras':
                            return chooseN([
                                "Sassafras",
                                "Sassafras",
                                "Hemisphere"
                            ], n);
                        case 'modder'://mine
                            return chooseN([
                                "Musicalement",
                                "ponglus",
                                "Wireworld",
                                "𝕸usicalement",
                                "Redky",
                                "𝙍𝙚𝙙𝙠𝙮",
                                "?&",
                                "Flare",
                                "berzeliumby",
                                "Tannuva_0",
                                "Anonymous"
                            ], n);
                        case 'lightning'://mine
                            return chooseN([
                                "Strike",
                                "Light",
                                "Tempest",
                                "Cloud",
                                "Storm",
                                "Rain",
                                "Zeus"
                            ], n);
                        case 'blightlands'://mine
                            return chooseN([
                                "Despair",
                                "Death",
                                "Agony",
                                "Toxic",
                                "Waste",
                                "Trash",
                                "Garbage",
                                "Bin",
                                "Empty can",
                                "Pollution"
                            ], n);
                        case 'forest'://mine
                            return chooseN([
                                "Lemon",
                                "Orange",
                                "Apple",
                                "Melon",
                                "Watermelon",
                                "Banana",
                                "Kiwi",
                                "Apricot",
                                "Mango",
                                "Pineapple",
                                "Cherry",
                                "Blueberry"
                            ], n);
                            case 'ice'://mine
                            return chooseN([
                                "Stalictic",
                                "Ice",
                                "Yeti",
                                "Cream",
                                "Frozen",
                                "Ice Queen",
                                "Rendeer",
                                "Rudolph"
                            ], n);
                            case 'desert'://mine
                            return chooseN([
                                "Cacti",
                                "Sun",
                                "Sand",
                                "Disease",
                                "Vulture"
                            ], n);
                            case 'hell'://mine
                            return chooseN([
                                "Belzebuth",
                                "Diable",
                                "Azrael",
                                "Ahriman",
                                "Asmodée"
                            ], n);
                        case 'player'://mine
                            return chooseN([
                                "Musicalement",
                                "𝕸usicalement",
                                "Redky",
                                "𝙍𝙚𝙙𝙠𝙮",
                                "?&",
                                "Flare",
                                "berzeliumby",
                                "Your Doom",
                                "⬢⬢Your Doom⬢⬢",
                                "UnderratedPlayer",
                                "𝓤nderrated𝓟layer",
                                ".",
                                "XXS",
                                "Developer Powers",
                                "dev party fun!",
                                "Patte_en_O",
                                "James",
                                "Tannuva_0",
                                "Rye Brainrot",
                                "Anonymous",
                            ], n);
                        case 'customElite'://mine
                            return chooseN([
                                "Chaos",
                                "Destroyer",
                                "Eater",
                                "Despair",
                                "Destruction",
                                "Annhiliation",
                                "Death",
                                "Agony",
                                "Torture",
                                "Atrocity",
                                "Abomination",
                                "Abyss",
  "Wraith",
  "Rift",
  "Shard",
  "Eclipse",
  "Fissure",
  "Specter",
  "Echo",
  "Phantom",
  "Fracture",
  "Void",
  "Oblivion",
  "Vortex",
  "Harbinger",
  "Torment",
  "Ember",
  "Hollow",
  "Storm",
  "Tremor",
  "Cipher",
  "Aether",
  "Cascade",
  "Nova",
  "Revenant",
  "Chasm",
  "Pulse",
  "Spectral",
  "Glimmer",
  "Lament",
  "Vigil",
  "Shroud",
  "Reckoning",
  "Emissary",
  "Fury",
  "Crimson",
  "Vigilance",
  "Breach",
  "Tear",
  "Haze",
  "Solace",
  "Ruin",
  "Obscura",
  "Dread",
  "Twilight",
  "Abyssal",
  "Ruinous",
  "Ascendant",
  "Wanderer",
  "Veil"
                            ], n);
                        case 'castle':
                            return chooseN([
                                "Berezhany",
                                "Lutsk",
                                "Dobromyl",
                                "Akkerman",
                                "Palanok",
                                "Zolochiv",
                                "Palanok",
                                "Mangup",
                                "Olseko",
                                "Brody",
                                "Isiaslav",
                                "Kaffa",
                                "Bilhorod",
                                "Cheese Block",
                                "Ganondorf",
                                "Weiss",
                                "Spiegel",
                                "Hasselhoff",
                                "Konstanze",
                                "Callum",
                                "Maleficum",
                                "Droukar",
                                "Astradhur",
                                "Saulazar",
                                "Gervaise",
                                "Reimund",
                                "Nothing",
                                "Kohntarkosz"
                            ], n);
                        case 'all':
                            return chooseN([
                                "Archimedes",
                                "Akilina",
                                "Anastasios",
                                "Athena",
                                "Alkaios",
                                "Amyntas",
                                "Aniketos",
                                "Artemis",
                                "Anaxagoras",
                                "Apollo",
                                "Pewdiepie",
                                "Ares",
                                "Helios",
                                "Hades",
                                "Alastor",
                                "Bruh Moment",
                                "Shrek",
                                "Geofridus",
                                "Guillermo",
                                "Tephania",
                                "Christaire",
                                "Galileo",
                                "Newton",
                                "Herschel",
                                "Eratosthenes",
                                "Maxwell",
                                "Lavoisier",
                                "Maynard",
                                "Berezhany",
                                "Lutsk",
                                "Dobromyl",
                                "Akkerman",
                                "Palanok",
                                "Zolochiv",
                                "Palanok",
                                "Mangup",
                                "Olseko",
                                "Brody",
                                "Isiaslav",
                                "Kaffa",
                                "Bilhorod",
                                "Cheese Block",
                                "Ganondorf",
                                "Weiss",
                                "Spiegel",
                                "Hasselhoff",
                                "Konstanze",
                                "Callum",
                                "Maleficum",
                                "Droukar",
                                "Astradhur",
                                "Saulazar",
                                "Gervaise",
                                "Reimund",
                                "Nothing",
                                "Kohntarkosz"
                            ], n);
                        default: return ['God'];
                    }
                },

                randomLore: function() {
                    return choose([
                        //"3 + 9 = 4 * 3 = 12",
                        //"You are inside of a time loop.",
                        //"There are six major wars.",
                        //"You are inside of the 6th major war.",
                        //"AWP-39 was re-assembled into the Redistributor.",
                        //"The world quakes when the Destroyers assemble.",
                        //"Certain polygons can pull you away from the world you know."
                        "Thanks To You For Playing and My Laptop For Suffering!",
                        "Thanks For Playing! My Laptop Will Have To Suffer Again Soon!",
                        "The Mini Dozen got a bad rep. It's not so bad once you use it.",
                        "When using Overlord Closer, hold click and release. Then watch the fireworks.",
                        "The Peacekeeper comes from a different game, which one?",
                        "The Reanimated Wither was originally a statue that became alive in Void Walkers. Wyatt killed it but we don't know if it will return or not...",
                        "There was originally a dominator at the center of the Dream map. It seems it will be replaced with something more dangerous...",
                        "The Shaman has a small chance of becoming very wealthy",
                        "There are 5 mutations, they are so rare that they can almost never spawn naturally"
                    ]);
                }
            }
        break;
        case "./lib/LZString":
            return (function () {
                // private property
                var f = String.fromCharCode;
                var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
                var baseReverseDic = {};

                function getBaseValue(alphabet, character) {
                    if (!baseReverseDic[alphabet]) {
                        baseReverseDic[alphabet] = {};
                        for (var i = 0; i < alphabet.length; i++) {
                            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
                        }
                    }
                    return baseReverseDic[alphabet][character];
                }
            
                var LZString = {
                    compressToBase64: function (input) {
                        if (input == null) return "";
                        var res = LZString._compress(input, 6, function (a) { return keyStrBase64.charAt(a); });
                        switch (res.length % 4) { // To produce valid Base64
                            default: // When could this happen ?
                            case 0: return res;
                            case 1: return res + "===";
                            case 2: return res + "==";
                            case 3: return res + "=";
                        }
                    },
                
                    decompressFromBase64: function (input) {
                        if (input == null) return "";
                        if (input == "") return null;
                        return LZString._decompress(input.length, 32, function (index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
                    },
                
                    compressToUTF16: function (input) {
                        if (input == null) return "";
                        return LZString._compress(input, 15, function (a) { return f(a + 32); }) + " ";
                    },
                
                    decompressFromUTF16: function (compressed) {
                        if (compressed == null) return "";
                        if (compressed == "") return null;
                        return LZString._decompress(compressed.length, 16384, function (index) { return compressed.charCodeAt(index) - 32; });
                    },
                
                    //compress into uint8array (UCS-2 big endian format)
                    compressToUint8Array: function (uncompressed) {
                        var compressed = LZString.compress(uncompressed);
                        var buf = new Uint8Array(compressed.length * 2); // 2 bytes per character
                    
                        for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
                            var current_value = compressed.charCodeAt(i);
                            buf[i * 2] = current_value >>> 8;
                            buf[i * 2 + 1] = current_value % 256;
                        }
                        return buf;
                    },
                
                    //decompress from uint8array (UCS-2 big endian format)
                    decompressFromUint8Array: function (compressed) {
                        if (compressed === null || compressed === undefined) {
                            return LZString.decompress(compressed);
                        } else {
                            var buf = new Array(compressed.length / 2); // 2 bytes per character
                            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
                                buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
                            }
                        
                            var result = [];
                            buf.forEach(function (c) {
                                result.push(f(c));
                            });
                            return LZString.decompress(result.join(''));
                        
                        }
                    
                    },
                
                
                    //compress into a string that is already URI encoded
                    compressToEncodedURIComponent: function (input) {
                        if (input == null) return "";
                        return LZString._compress(input, 6, function (a) { return keyStrUriSafe.charAt(a); });
                    },
                
                    //decompress from an output of compressToEncodedURIComponent
                    decompressFromEncodedURIComponent: function (input) {
                        if (input == null) return "";
                        if (input == "") return null;
                        input = input.replace(/ /g, "+");
                        return LZString._decompress(input.length, 32, function (index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
                    },
                
                    compress: function (uncompressed) {
                        return LZString._compress(uncompressed, 16, function (a) { return f(a); });
                    },
                    _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
                        if (uncompressed == null) return "";
                        var i, value,
                            context_dictionary = {},
                            context_dictionaryToCreate = {},
                            context_c = "",
                            context_wc = "",
                            context_w = "",
                            context_enlargeIn = 2, // Compensate for the first entry which should not count
                            context_dictSize = 3,
                            context_numBits = 2,
                            context_data = [],
                            context_data_val = 0,
                            context_data_position = 0,
                            ii;
                    
                        for (ii = 0; ii < uncompressed.length; ii += 1) {
                            context_c = uncompressed.charAt(ii);
                            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                                context_dictionary[context_c] = context_dictSize++;
                                context_dictionaryToCreate[context_c] = true;
                            }
                        
                            context_wc = context_w + context_c;
                            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                                context_w = context_wc;
                            } else {
                                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                                    if (context_w.charCodeAt(0) < 256) {
                                        for (i = 0; i < context_numBits; i++) {
                                            context_data_val = (context_data_val << 1);
                                            if (context_data_position == bitsPerChar - 1) {
                                                context_data_position = 0;
                                                context_data.push(getCharFromInt(context_data_val));
                                                context_data_val = 0;
                                            } else {
                                                context_data_position++;
                                            }
                                        }
                                        value = context_w.charCodeAt(0);
                                        for (i = 0; i < 8; i++) {
                                            context_data_val = (context_data_val << 1) | (value & 1);
                                            if (context_data_position == bitsPerChar - 1) {
                                                context_data_position = 0;
                                                context_data.push(getCharFromInt(context_data_val));
                                                context_data_val = 0;
                                            } else {
                                                context_data_position++;
                                            }
                                            value = value >> 1;
                                        }
                                    } else {
                                        value = 1;
                                        for (i = 0; i < context_numBits; i++) {
                                            context_data_val = (context_data_val << 1) | value;
                                            if (context_data_position == bitsPerChar - 1) {
                                                context_data_position = 0;
                                                context_data.push(getCharFromInt(context_data_val));
                                                context_data_val = 0;
                                            } else {
                                                context_data_position++;
                                            }
                                            value = 0;
                                        }
                                        value = context_w.charCodeAt(0);
                                        for (i = 0; i < 16; i++) {
                                            context_data_val = (context_data_val << 1) | (value & 1);
                                            if (context_data_position == bitsPerChar - 1) {
                                                context_data_position = 0;
                                                context_data.push(getCharFromInt(context_data_val));
                                                context_data_val = 0;
                                            } else {
                                                context_data_position++;
                                            }
                                            value = value >> 1;
                                        }
                                    }
                                    context_enlargeIn--;
                                    if (context_enlargeIn == 0) {
                                        context_enlargeIn = Math.pow(2, context_numBits);
                                        context_numBits++;
                                    }
                                    delete context_dictionaryToCreate[context_w];
                                } else {
                                    value = context_dictionary[context_w];
                                    for (i = 0; i < context_numBits; i++) {
                                        context_data_val = (context_data_val << 1) | (value & 1);
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                                
                                
                                }
                                context_enlargeIn--;
                                if (context_enlargeIn == 0) {
                                    context_enlargeIn = Math.pow(2, context_numBits);
                                    context_numBits++;
                                }
                                // Add wc to the dictionary.
                                context_dictionary[context_wc] = context_dictSize++;
                                context_w = String(context_c);
                            }
                        }
                    
                        // Output the code for w.
                        if (context_w !== "") {
                            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                                if (context_w.charCodeAt(0) < 256) {
                                    for (i = 0; i < context_numBits; i++) {
                                        context_data_val = (context_data_val << 1);
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                    }
                                    value = context_w.charCodeAt(0);
                                    for (i = 0; i < 8; i++) {
                                        context_data_val = (context_data_val << 1) | (value & 1);
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                                } else {
                                    value = 1;
                                    for (i = 0; i < context_numBits; i++) {
                                        context_data_val = (context_data_val << 1) | value;
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = 0;
                                    }
                                    value = context_w.charCodeAt(0);
                                    for (i = 0; i < 16; i++) {
                                        context_data_val = (context_data_val << 1) | (value & 1);
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                                }
                                context_enlargeIn--;
                                if (context_enlargeIn == 0) {
                                    context_enlargeIn = Math.pow(2, context_numBits);
                                    context_numBits++;
                                }
                                delete context_dictionaryToCreate[context_w];
                            } else {
                                value = context_dictionary[context_w];
                                for (i = 0; i < context_numBits; i++) {
                                    context_data_val = (context_data_val << 1) | (value & 1);
                                    if (context_data_position == bitsPerChar - 1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                    } else {
                                        context_data_position++;
                                    }
                                    value = value >> 1;
                                }
                            
                            
                            }
                            context_enlargeIn--;
                            if (context_enlargeIn == 0) {
                                context_enlargeIn = Math.pow(2, context_numBits);
                                context_numBits++;
                            }
                        }
                    
                        // Mark the end of the stream
                        value = 2;
                        for (i = 0; i < context_numBits; i++) {
                            context_data_val = (context_data_val << 1) | (value & 1);
                            if (context_data_position == bitsPerChar - 1) {
                                context_data_position = 0;
                                context_data.push(getCharFromInt(context_data_val));
                                context_data_val = 0;
                            } else {
                                context_data_position++;
                            }
                            value = value >> 1;
                        }
                    
                        // Flush the last char
                        while (true) {
                            context_data_val = (context_data_val << 1);
                            if (context_data_position == bitsPerChar - 1) {
                                context_data.push(getCharFromInt(context_data_val));
                                break;
                            }
                            else context_data_position++;
                        }
                        return context_data.join('');
                    },
                
                    decompress: function (compressed) {
                        if (compressed == null) return "";
                        if (compressed == "") return null;
                        return LZString._decompress(compressed.length, 32768, function (index) { return compressed.charCodeAt(index); });
                    },
                
                    _decompress: function (length, resetValue, getNextValue) {
                        var dictionary = [],
                            next,
                            enlargeIn = 4,
                            dictSize = 4,
                            numBits = 3,
                            entry = "",
                            result = [],
                            i,
                            w,
                            bits, resb, maxpower, power,
                            c,
                            data = { val: getNextValue(0), position: resetValue, index: 1 };
                    
                        for (i = 0; i < 3; i += 1) {
                            dictionary[i] = i;
                        }
                    
                        bits = 0;
                        maxpower = Math.pow(2, 2);
                        power = 1;
                        while (power != maxpower) {
                            resb = data.val & data.position;
                            data.position >>= 1;
                            if (data.position == 0) {
                                data.position = resetValue;
                                data.val = getNextValue(data.index++);
                            }
                            bits |= (resb > 0 ? 1 : 0) * power;
                            power <<= 1;
                        }
                    
                        switch (next = bits) {
                            case 0:
                                bits = 0;
                                maxpower = Math.pow(2, 8);
                                power = 1;
                                while (power != maxpower) {
                                    resb = data.val & data.position;
                                    data.position >>= 1;
                                    if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                    }
                                    bits |= (resb > 0 ? 1 : 0) * power;
                                    power <<= 1;
                                }
                                c = f(bits);
                                break;
                            case 1:
                                bits = 0;
                                maxpower = Math.pow(2, 16);
                                power = 1;
                                while (power != maxpower) {
                                    resb = data.val & data.position;
                                    data.position >>= 1;
                                    if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                    }
                                    bits |= (resb > 0 ? 1 : 0) * power;
                                    power <<= 1;
                                }
                                c = f(bits);
                                break;
                            case 2:
                                return "";
                        }
                        dictionary[3] = c;
                        w = c;
                        result.push(c);
                        while (true) {
                            if (data.index > length) {
                                return "";
                            }
                        
                            bits = 0;
                            maxpower = Math.pow(2, numBits);
                            power = 1;
                            while (power != maxpower) {
                                resb = data.val & data.position;
                                data.position >>= 1;
                                if (data.position == 0) {
                                    data.position = resetValue;
                                    data.val = getNextValue(data.index++);
                                }
                                bits |= (resb > 0 ? 1 : 0) * power;
                                power <<= 1;
                            }
                        
                            switch (c = bits) {
                                case 0:
                                    bits = 0;
                                    maxpower = Math.pow(2, 8);
                                    power = 1;
                                    while (power != maxpower) {
                                        resb = data.val & data.position;
                                        data.position >>= 1;
                                        if (data.position == 0) {
                                            data.position = resetValue;
                                            data.val = getNextValue(data.index++);
                                        }
                                        bits |= (resb > 0 ? 1 : 0) * power;
                                        power <<= 1;
                                    }
                                
                                    dictionary[dictSize++] = f(bits);
                                    c = dictSize - 1;
                                    enlargeIn--;
                                    break;
                                case 1:
                                    bits = 0;
                                    maxpower = Math.pow(2, 16);
                                    power = 1;
                                    while (power != maxpower) {
                                        resb = data.val & data.position;
                                        data.position >>= 1;
                                        if (data.position == 0) {
                                            data.position = resetValue;
                                            data.val = getNextValue(data.index++);
                                        }
                                        bits |= (resb > 0 ? 1 : 0) * power;
                                        power <<= 1;
                                    }
                                    dictionary[dictSize++] = f(bits);
                                    c = dictSize - 1;
                                    enlargeIn--;
                                    break;
                                case 2:
                                    return result.join('');
                            }
                        
                            if (enlargeIn == 0) {
                                enlargeIn = Math.pow(2, numBits);
                                numBits++;
                            }
                        
                            if (dictionary[c]) {
                                entry = dictionary[c];
                            } else {
                                if (c === dictSize) {
                                    entry = w + w.charAt(0);
                                } else {
                                    return null;
                                }
                            }
                            result.push(entry);
                        
                            // Add w+entry[0] to the dictionary.
                            dictionary[dictSize++] = w + entry.charAt(0);
                            enlargeIn--;
                        
                            w = entry;
                        
                            if (enlargeIn == 0) {
                                enlargeIn = Math.pow(2, numBits);
                                numBits++;
                            }
                        
                        }
                    }
                };
                return LZString;
            })()
        break;
        case "./lib/generateEvalCode.js":
            function lowestDivisor(number, starting = 2) {
                while (number / starting !== Math.floor(number / starting)) {
                    starting ++;
                }
                return starting;
            }

            function encodef(string) {
                string = string.split("").reverse();
                return string.map(char => {
                    let charCode = char.charCodeAt(0),
                        divisor = lowestDivisor(charCode);
                    return `|0${(divisor % 2) * 1}x0${divisor.toString(divisor % 2 ? 4 : 2)}x0${charCode / divisor}`;
                }).join("");
            }

            let mainExpressions = Object.entries({
                "typeof window": "'object'",
                "typeof Window": "'function'",
                "window instanceof Window": true,
                "typeof global": "'undefined'",
                "'open' in window": true,
                "typeof module": "'undefined'",
                "typeof exports": "'undefined'",
                "typeof window.document": "'object'",
                "typeof process": "'undefined'",
                "typeof localStorage": "'object'",
                "'WebSocket' in window": true,
                "'require' in window": false,
                "'process' in window": false,
                "'global' in window": false
            });

            mainExpressions = mainExpressions.map(entry => encodef(`(${entry[0]} == ${entry[1]})`));

            const variableGenerator = (function() {
                let variables = [];
                function generate() {
                    let variable;
                    while (variable = `_0x${((Math.random() * 8999999 | 0) + 1000000).toString(16).split("").map(char => Math.random() > .5 ? char.toUpperCase() : char.toLowerCase()).join("")}`, variables.includes(variable)) {}
                    variables.push(variable);
                    return variable;
                }
                return {
                    generate,
                    reset: () => variables = []
                }
            })();

            function generateNodeTest(generator) {
                let PROCESS = generator.generate(),
                    GLOBAL = generator.generate(),
                    REQUIRE = generator.generate(),
                    isNode = generator.generate();
                const nodeTests = [
                    ["fs", "util", "os", "http"].map(packageName => `${REQUIRE}('${packageName}');`),
                    `(Object.prototype.toString.call(${GLOBAL}.process) === '[object process]') && ${PROCESS}.exit();`,
                    `${PROCESS}.exit();`,
                    `${PROCESS}.kill(${PROCESS}.pid, 'SIGINT');`,
                    "Buffer.from('stop scripting');",
                    //"Buffer.from('Message above is from oblivion lmao')",
                    //"Buffer.from('Hey, this is drako, if you are seeing this, contact me Ill help you get around this jazz and you can come work with us.')"
                ].flat().sort(() => .5 - Math.random());
                nodeTests.length = Math.ceil(nodeTests.length * ((Math.random() * .3) + .3));
                return `(() => {let ${isNode}=true;try{let ${PROCESS}=process,${GLOBAL}=global,${REQUIRE}=require;${nodeTests.join("")}}catch(${generator.generate()}){${isNode}=false;}return ${isNode}})()`;
            }

            function obfuscateCheckFunction(generator) {
                let thrownError = generator.generate(),
                    userscriptDetected = generator.generate(),
                    _substring = generator.generate(),
                    _substr = generator.generate(),
                    _indexOf = generator.generate(),
                    _replace = generator.generate(),
                    ws = generator.generate(),
                    error = generator.generate(),
                    defineProperty = generator.generate();
                return `function () {
                    let ${thrownError} = false,
                        ${userscriptDetected} = false;
                    ${[
                        `const ${_substring} = String.prototype.substring;`,
                        `const ${_substr} = String.prototype.substr;`,
                        `const ${_indexOf} = String.prototype.indexOf;`,
                        `const ${_replace} = String.prototype.replace;`,
                        `const ${defineProperty} = Object.defineProperty;`
                    ].sort(() => .5 - Math.random()).join("")}
                    ${[
                        `delete String.prototype.substring;`,
                        `delete String.prototype.substr;`,
                        `delete String.prototype.indexOf;`,
                        `delete String.prototype.replace;`,
                        `delete Object.defineProperty;`
                    ].sort(() => .5 - Math.random()).join("")}
                    try {
                        let ${ws} = new WebSocket(10);
                        ${ws}.send("hi");
                    } catch (${error}) {
                        ${thrownError} = true;
                        ${userscriptDetected} = /user-?script|user\.js|multibox/i.test(${error}.stack) || ${error}.stack.includes("userscript.html");
                    }
                    ${[
                        `String.prototype.substring = ${_substring};`,
                        `String.prototype.substr = ${_substr};`,
                        `String.prototype.indexOf = ${_indexOf};`,
                        `String.prototype.replace = ${_replace};`,
                        `Object.defineProperty = ${defineProperty};`
                    ].sort(() => .5 - Math.random()).join("")}
                    return ${userscriptDetected} || !${thrownError};
                }`.trim().split("\n").map(r => r.trim()).join("").replace(/ = /g, "=");
            }

            function generateEvalPacket(keys) {
                variableGenerator.reset();
                // VARIABLE NAMES
                let count = variableGenerator.generate(),
                    decode = variableGenerator.generate(),
                    string = variableGenerator.generate(),
                    parseInteger = variableGenerator.generate(),
                    entry = variableGenerator.generate(),
                    charCode = variableGenerator.generate(),
                    evaluate = variableGenerator.generate(),
                    placeholderInput = variableGenerator.generate(),
                    expressionVariable = variableGenerator.generate();
                // END VARIABLE NAMES
                let expressions = mainExpressions.map(r => r).sort(() => .5 - Math.random());
                expressions.length = Math.floor(mainExpressions.length / (1 + Math.random() * .75));
                let baseExpressions = expressions.map(r => r);
                baseExpressions.length = Math.floor(baseExpressions.length / 2);
                let output = `return (${placeholderInput} => {let ${count}=0,${evaluate}=eval,${parseInteger}=parseInt,${expressionVariable}=${JSON.stringify(baseExpressions)}.concat(${placeholderInput});if((${obfuscateCheckFunction(variableGenerator)})()){return 0;}function ${decode}(${string}) {return ${string}.split("|0").slice(1).map(${entry}=>(${entry}=${entry}.split("x0"),${parseInteger}(${entry}[1],${entry}[0]==1?4:2)*${entry}[2])).map(${charCode}=>String.fromCharCode(${charCode})).reverse().join("");}`.trim(),
                    flag = 1 + Math.random() * 25 | 0,
                    result = 0,
                    checks = [];
                for (let i = 0, amount = expressions.length; i < amount; i++) {
                    checks.push({
                        code: Math.random() > .95 ? `"${expressions[i]}"` : `${expressionVariable}[${parseInteger}('${i.toString([2, 4, 8, 16][i % 4])}', ${[2, 4, 8, 16][i % 4]})]`,
                        flag: flag
                    });
                    result += flag;
                    flag = 1 + Math.random() * 25 | 0;
                }
                output += `if (${generateNodeTest(variableGenerator)}){return 0}`;
                for (let check of checks.sort(() => .5 - Math.random())) {
                    if (Math.random() > .334) {
                        output += `${count}+=${evaluate}(${decode}(${check.code}))*${parseInteger}("${check.flag.toString([2, 4, 16][check.flag % 3])}",${[2, 4, 16][check.flag % 3]});`
                    } else if (Math.random() > .5) {
                        output += `${evaluate}(${decode}(${check.code}))&&(${count}+=${parseInteger}("${check.flag.toString([2, 4, 16][check.flag % 3])}",${[2, 4, 16][check.flag % 3]}));`;
                        if (Math.random() > .5) {
                            output += `${evaluate}(${decode}(${check.code}))||(()=>{debugger})();`;
                        }
                        output += `if (${generateNodeTest(variableGenerator)}){return 0}`;
                    } else {
                        let variable = variableGenerator.generate();
                        output += `let ${variable};if(${variable}=${evaluate}(${decode}(${check.code})),+${variable}){${count}+=${parseInteger}("${check.flag.toString([2, 4, 16][check.flag % 3])}",${[2, 4, 16][check.flag % 3]});}`;
                        if (Math.random() > .5) {
                            output += `else{debugger}`;
                        }
                    }
                    if (Math.random() > .9) {
                        output += `if(${generateNodeTest(variableGenerator)}){return 0}`;
                    }
                }
                output += `if ('${JSON.stringify(keys)}' !== JSON.stringify({a:window._$a,b:window._$b,c:window._$c,d:window._$d,e:window._$e})){return ${Math.random() * result - 3 | 0};}`;
                output += `return ${count};})(${JSON.stringify(expressions.slice(baseExpressions.length))});`;
                return {
                    code: output,
                    result: result
                };
            }
            return generateEvalPacket
        break;
        case "./lib/fasttalk":
            const u32 = new Uint32Array(1),
                c32 = new Uint8Array(u32.buffer),
                f32 = new Float32Array(u32.buffer),
                u16 = new Uint16Array(1),
                c16 = new Uint8Array(u16.buffer);
            let encode = function(message) {
                let headers = [],
                    headerCodes = [],
                    contentSize = 0,
                    lastTypeCode = 0b1111,
                    repeatTypeCount = 0;
                for (let block of message) {
                    let typeCode = 0;
                    if (block === 0 || block === false) typeCode = 0b0000;
                    else if (block === 1 || block === true) typeCode = 0b0001;
                    else if (typeof block === "number") {
                        if (!Number.isInteger(block) || block < -0x100000000 || block >= 0x100000000) {
                            typeCode = 0b1000;
                            contentSize += 4;
                        } else if (block >= 0) {
                            if (block < 0x100) {
                                typeCode = 0b0010;
                                contentSize++;
                            } else if (block < 0x10000) {
                                typeCode = 0b0100;
                                contentSize += 2;
                            } else if (block < 0x100000000) {
                                typeCode = 0b0110;
                                contentSize += 4;
                            }
                        } else {
                            if (block >= -0x100) {
                                typeCode = 0b0011;
                                contentSize++;
                            } else if (block >= -0x10000) {
                                typeCode = 0b0101;
                                contentSize += 2;
                            } else if (block >= -0x100000000) {
                                typeCode = 0b0111;
                                contentSize += 4;
                            }
                        }
                    } else if (typeof block === "string") {
                        let hasUnicode = false;
                        for (let i = 0; i < block.length; i++) {
                            if (block.charAt(i) > "\xff") hasUnicode = true;
                            else if (block.charAt(i) === "\x00") {
                                console.error("Null containing string!", block);
                                throw new Error("Null containing string!");
                            }
                        }
                        if (!hasUnicode && block.length <= 1) {
                            typeCode = 0b1001;
                            contentSize++;
                        } else if (hasUnicode) {
                            typeCode = 0b1011;
                            contentSize += block.length * 2 + 2;
                        } else {
                            typeCode = 0b1010;
                            contentSize += block.length + 1;
                        }
                    } else {
                        console.error("Unencodable data type!", block);
                        console.log(JSON.stringify(message), message.indexOf(block))
                        throw new Error("Unencodable data type!");
                    }
                    headers.push(typeCode);
                    if (typeCode === lastTypeCode) repeatTypeCount++;
                    else {
                        headerCodes.push(lastTypeCode);
                        if (repeatTypeCount >= 1) {
                            while (repeatTypeCount > 19) {
                                headerCodes.push(0b1110);
                                headerCodes.push(15);
                                repeatTypeCount -= 19;
                            }
                            if (repeatTypeCount === 1) headerCodes.push(lastTypeCode);
                            else if (repeatTypeCount === 2) headerCodes.push(0b1100);
                            else if (repeatTypeCount === 3) headerCodes.push(0b1101);
                            else if (repeatTypeCount < 20) {
                                headerCodes.push(0b1110);
                                headerCodes.push(repeatTypeCount - 4);
                            }
                        }
                        repeatTypeCount = 0;
                        lastTypeCode = typeCode;
                    }
                }
                headerCodes.push(lastTypeCode);
                if (repeatTypeCount >= 1) {
                    while (repeatTypeCount > 19) {
                        headerCodes.push(0b1110);
                        headerCodes.push(15);
                        repeatTypeCount -= 19;
                    }
                    if (repeatTypeCount === 1) headerCodes.push(lastTypeCode);
                    else if (repeatTypeCount === 2) headerCodes.push(0b1100);
                    else if (repeatTypeCount === 3) headerCodes.push(0b1101);
                    else if (repeatTypeCount < 20) {
                        headerCodes.push(0b1110);
                        headerCodes.push(repeatTypeCount - 4);
                    }
                }
                headerCodes.push(0b1111);
                if (headerCodes.length % 2 === 1) headerCodes.push(0b1111);
                let output = new Uint8Array((headerCodes.length >> 1) + contentSize);
                for (let i = 0; i < headerCodes.length; i += 2) {
                    let upper = headerCodes[i],
                        lower = headerCodes[i + 1];
                    output[i >> 1] = (upper << 4) | lower;
                }
                let index = headerCodes.length >> 1;
                for (let i = 0; i < headers.length; i++) {
                    let block = message[i];
                    switch (headers[i]) {
                        case 0b0000:
                        case 0b0001:
                            break;
                        case 0b0010:
                        case 0b0011:
                            output[index++] = block;
                            break;
                        case 0b0100:
                        case 0b0101:
                            u16[0] = block;
                            output.set(c16, index);
                            index += 2;
                            break;
                        case 0b0110:
                        case 0b0111:
                            u32[0] = block;
                            output.set(c32, index);
                            index += 4;
                            break;
                        case 0b1000:
                            f32[0] = block;
                            output.set(c32, index);
                            index += 4;
                            break;
                        case 0b1001: {
                            let byte = block.length === 0 ? 0 : block.charCodeAt(0);
                            output[index++] = byte;
                        }
                        break;
                        case 0b1010:
                            for (let i = 0; i < block.length; i++) output[index++] = block.charCodeAt(i);
                            output[index++] = 0;
                            break;
                        case 0b1011:
                            for (let i = 0; i < block.length; i++) {
                                let charCode = block.charCodeAt(i);
                                output[index++] = charCode & 0xff;
                                output[index++] = charCode >> 8;
                            }
                            output[index++] = 0;
                            output[index++] = 0;
                            break;
                    }
                }
                return output;
            };
            let decode = function(packet) {
                let data = new Uint8Array(packet);
                if (data[0] >> 4 !== 0b1111) return null;
                let headers = [],
                    lastTypeCode = 0b1111,
                    index = 0,
                    consumedHalf = true;
                while (true) {
                    if (index >= data.length) return null;
                    let typeCode = data[index];
                    if (consumedHalf) {
                        typeCode &= 0b1111;
                        index++;
                    } else typeCode >>= 4;
                    consumedHalf = !consumedHalf;
                    if ((typeCode & 0b1100) === 0b1100) {
                        if (typeCode === 0b1111) {
                            if (consumedHalf) index++;
                            break;
                        }
                        let repeat = typeCode - 10;
                        if (typeCode === 0b1110) {
                            if (index >= data.length) return null;
                            let repeatCode = data[index];
                            if (consumedHalf) {
                                repeatCode &= 0b1111;
                                index++;
                            } else repeatCode >>= 4;
                            consumedHalf = !consumedHalf;
                            repeat += repeatCode;
                        }
                        for (let i = 0; i < repeat; i++) headers.push(lastTypeCode);
                    } else {
                        headers.push(typeCode);
                        lastTypeCode = typeCode;
                    }
                }
                let output = [];
                for (let header of headers) {
                    switch (header) {
                        case 0b0000:
                            output.push(0);
                            break;
                        case 0b0001:
                            output.push(1);
                            break;
                        case 0b0010:
                            output.push(data[index++]);
                            break;
                        case 0b0011:
                            output.push(data[index++] - 0x100);
                            break;
                        case 0b0100:
                            c16[0] = data[index++];
                            c16[1] = data[index++];
                            output.push(u16[0]);
                            break;
                        case 0b0101:
                            c16[0] = data[index++];
                            c16[1] = data[index++];
                            output.push(u16[0] - 0x10000);
                            break;
                        case 0b0110:
                            c32[0] = data[index++];
                            c32[1] = data[index++];
                            c32[2] = data[index++];
                            c32[3] = data[index++];
                            output.push(u32[0]);
                            break;
                        case 0b0111:
                            c32[0] = data[index++];
                            c32[1] = data[index++];
                            c32[2] = data[index++];
                            c32[3] = data[index++];
                            output.push(u32[0] - 0x100000000);
                            break;
                        case 0b1000:
                            c32[0] = data[index++];
                            c32[1] = data[index++];
                            c32[2] = data[index++];
                            c32[3] = data[index++];
                            output.push(f32[0]);
                            break;
                        case 0b1001: {
                            let byte = data[index++];
                            output.push(byte === 0 ? "" : String.fromCharCode(byte));
                        }
                        break;
                        case 0b1010: {
                            let string = "",
                                byte = 0;
                            while ((byte = data[index++])) string += String.fromCharCode(byte);
                            output.push(string);
                        }
                        break;
                        case 0b1011: {
                            let string = "",
                                byte = 0;
                            while ((byte = data[index++] | (data[index++] << 8))) string += String.fromCharCode(byte);
                            output.push(string);
                        }
                        break;
                    }
                }
                return output;
            };
            return {
                encode,
                decode
            }
        break;
    }
}




// THE SERVER //

async function startServer(configSuffix, serverGamemode, defExports){
/*g = defExports.g;
combineStats = defExports.combineStats;
setSkill = defExports.setSkill;
statNames = defExports.statNames;
gunCalcNames = defExports.gunCalcNames;
base = defExports.base;*/
/*jslint node: true */
/*jshint -W061 */
/*global Map*/
// TO CONSIDER: Tweak how entity physics work (IE: When two entities collide, they push out from the center. This would allow stuff like "bullet ghosting" to happen, making certain UP tanks viable.)
// TO DO: Give bosses name colors via a NAME_COLOR attribute and/or colored broadcasts, fix this.usesAltFire, fix bugs with zoom cooldown, fix FFA_RED overriding custom bullet colors
// Basic defaults in case of error
var performance = performance || Date;
let entries = []

// Rivet
let rivetToken = process.env.RIVET_TOKEN ? process.env.RIVET_TOKEN : process.env.RIVET_DEV_TOKEN

/*const Rivet = require("@rivet-gg/api")
let rivet = new Rivet.RivetClient({
    token: rivetToken
})*/
if (process.env.RIVET_TOKEN) {
    global.isVPS = true
}

if(global.isVPS) rivet.matchmaker.lobbies.ready().catch((e) => { console.log(e); console.log("Rivet matchmaker not ready, exiting.."); process.exit(1) });


// Maintain Global.ServerStats
global.serverStats = {
    cpu: 0,
    mem: 0
}

// Modify "Map" to improve it for our needs.
Map.prototype.filter = function (callback) {
    let output = [];
    this.forEach((object, index) => {
        if (callback(object, index)) {
            output.push(object);
        }
    });
    return output;
}

Map.prototype.find = function (callback) {
    let output;
    for (let [key, value] of this) {
        if (callback(value, key)) {
            output = value;
            break;
        }
    }
    return output;
}
class HashGrid {
    constructor(cellShift = 6) {
        this.grid = new Map();
        this.currentQuery = 0;
        this.cellShift = cellShift;
        this._resultPool = [];
    }

    clear() {
        this.grid.clear();
        this.currentQuery = 0;
    }

    insert(object) {
        const startX = object._AABB.x1 >> this.cellShift;
        const startY = object._AABB.y1 >> this.cellShift;
        const endX = object._AABB.x2 >> this.cellShift;
        const endY = object._AABB.y2 >> this.cellShift;

        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const key = (x << 16) | (y & 0xFFFF); // inlined for speed
                const cell = this.grid.get(key);
                if (cell) {
                    cell.push(object);
                } else {
                    this.grid.set(key, [object]);
                }
            }
        }
    }

    getCollisions(object, optFunct) {
        const result = this._resultPool;
        result.length = 0;

        const startX = object._AABB.x1 >> this.cellShift;
        const startY = object._AABB.y1 >> this.cellShift;
        const endX = object._AABB.x2 >> this.cellShift;
        const endY = object._AABB.y2 >> this.cellShift;

        const objectId = object.id;

        // Fast path for 1x1, 2x1, or 1x2 spans
        if (startX === endX && startY === endY) {
            const key = (startX << 16) | (startY & 0xFFFF);
            const cell = this.grid.get(key);
            if (cell) this._processCell(cell, object, objectId, result, optFunct);
        } else {
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const key = (x << 16) | (y & 0xFFFF);
                    const cell = this.grid.get(key);
                    if (cell) {
                        this._processCell(cell, object, objectId, result, optFunct);
                    }
                }
            }
        }

        this.currentQuery = (this.currentQuery + 1) >>> 0;
        return result;
    }

    _processCell(cell, object, objectId, result, optFunct) {
        // Unroll the loop here for small cell sizes
        const currentQuery = this.currentQuery;
        const cellLength = cell.length;

        // Unroll for small numbers of objects in the cell
        if (cellLength === 1) {
            this._checkCollision(cell[0], object, objectId, result, optFunct, currentQuery);
        } else if (cellLength === 2) {
            this._checkCollision(cell[0], object, objectId, result, optFunct, currentQuery);
            this._checkCollision(cell[1], object, objectId, result, optFunct, currentQuery);
        } else if (cellLength === 3) {
            this._checkCollision(cell[0], object, objectId, result, optFunct, currentQuery);
            this._checkCollision(cell[1], object, objectId, result, optFunct, currentQuery);
            this._checkCollision(cell[2], object, objectId, result, optFunct, currentQuery);
        } else {
            // Fallback to a general loop for larger cell sizes
            for (let i = 0; i < cellLength; i++) {
                this._checkCollision(cell[i], object, objectId, result, optFunct, currentQuery);
            }
        }
    }

    // Collision check helper (to avoid redundant code)
    _checkCollision(other, object, objectId, result, optFunct, currentQuery) {
        if (other._AABB.currentQuery === currentQuery) return;
        const a = object._AABB, b = other._AABB;
        b.currentQuery = currentQuery;

        // Hit detection logic
        if (other.id !== objectId && !(a.x1 > b.x2 || a.x2 < b.x1 || a.y1 > b.y2 || a.y2 < b.y1)) {
            if (optFunct) {
                optFunct(other);
            } else {
                result.push(other);
            }
        }
    }
      getAABB(object) {
        const size = object.realSize || object.size || object.radius || 1;
        const width = (object.width || 1) * size;
        const height = (object.height || 1) * size;
        return {
            x1: object.x - width,
            y1: object.y - height,
            x2: object.x + width,
            y2: object.y + height,
            currentQuery: -1
        };
    }
}
let tokendata = {};

const webhooks = (function () {
    const https = require("https");
    let private = {
        keys: {
            // USA
            "a": "/api/webhooks/1018582651147403284/pPuQBkSl7hSF5M3L9mBefvQf7ahDyi85kz2KGIuQm8FhS3FrjxYk9kuqLrCuheDL7Elk",
            "b": "/api/webhooks/1018583149820793012/2TnWYuqkDY6A7BuwNyjSK0em3TKeAh66lqkvDASjv1gyCv5dX11WkpPMP8gL0zSVjIAD",
            "c": "/api/webhooks/1018583275696042104/5I9n1nMk4eX5s0em4_agAIAC6LvDTX48SEzdHr2pzgtuanEbIhLaF0ZnGKWrV8RBcvON",
            "d": "/api/webhooks/1018583494131204117/j_I04EKhk9GcsBOEzYAXa9wQpgi9wQYCaXLLKMpnzD5VdynBPu9GJ9Pu_RXwEPt055QW",
            // Europe
            "e": "/api/webhooks/1018584313496862812/S8n17RJAa0NCgCTT-8IznuxRLtBbHthi3nAwEk1Kuo3JLrCzIsTBGIlD1IrBP55toX2u",
            "f": "/api/webhooks/1018584491591225355/hBvJrFWvKzMIAMUznSbL2DL4HtYD_1aEokJQW_PUfgpES8q0gUlpOvfgabacfP1h26KU",
            "g": "/api/webhooks/1018584955988742144/sfS1STjH5u5kIdwfVpdrVAk8tEXTKMuBjOS6fDNaZ4JfaqJDAzN3wWDRtOMuen5Wdreg",
            "h": "/api/webhooks/1018585088872693820/17Ns87ftXylRrL9GinGWxp-1Ka-0WhmZaFvePq3GQQdccjvz2E6-KxyQoK8Lnhb5Lryv",
            // ASIA
            "j": "/api/webhooks/1018588607017123950/xoF2920rrUXlcIJawiLETDwCrM6WZPs0EZxfTVvbu0fXsJ_7N_vQ5Gpjsqnm7PiMKX1y",
            "v": "/api/webhooks/1018588802668838963/lpjrCg7P2M9HvCuH0LfExb0qPe7f9K1G7QdXUugZDhp8dsGtZwuY0-xew9_dFZIaJ_uw",
            "w": "/api/webhooks/1018585281869393992/0aNkN6KQZUGZud31Wq50NeXRbkUeRAcMDx6qX-bxpV7yZa8DDOcE1wi1ZLbRC_P5pKHR",
            "x": "/api/webhooks/1018585430146433095/6xZNBJOPnQmf1vDXsaP292JAMya6Qa2H08sSss2fh4DTX9y1lK3iAIgBfJ_4lgUsERJJ",
            // Alternate
            "y": "/api/webhooks/1018585598749065286/WmKkHdcFxD4QYjNxAV43khqk71ld4jtuKShaOjcF6AUj8X00WjSUaEp5yEjga8K646QO",

            // Localhost
            "z": "/api/webhooks/1018585818631250111/1gxDTNmkivDgA-oeK4K31PlYtNvuV4aKM1ahT82hZob4PXQfqQ8TllwkSluouldPROvD",
            // Fallback
            "default": "/api/webhooks/1018587345747984424/5289v5gyzDtRrYCZzP7XYNsOiTyxovIdvFwCFqf7ZsR0Hz8A9L9XDoFjkyywDKwX2yRB"
        },
        buffer: '',
        queue: [],
        lastSend: 0,
        send(data) {
            let path = private.keys[process.env.HASH || "z"] || private.keys.default;
            let req = https.request({
                hostname: 'discordapp.com',
                path,
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            }, () => { });
            req.write(JSON.stringify({
                content: data.trim()
            }));
            req.end();
        },
        publish(force) {
            let output = "";
            if (private.queue.length < 3 && Date.now() - private.lastSend < 10000 && !force) {
                return;
            }
            private.lastSend = Date.now();
            while (private.queue.length > 0) {
                if (output + "\n" + private.queue[0] > 2000) {
                    private.send(output);
                    return;
                }
                output += "\n" + private.queue.shift();
            }
            private.send(output);
        },
        log(data, force) {
            data = data + "";
            data = data.replace("@", "🤓");
            data = data.trim();
            if (data.length > 2000) {
                while (data.length) {
                    private.send(data.slice(0, 2000).trim());
                    data = data.slice(2000).trim();
                }
                return;
            }
            private.queue.push(data);
            if (force) {
                private.publish(true);
            }
        }
    };
    //setInterval(private.publish, 5000);
    return {
        log: (data, force) => {
            //private.log('[' + util.getLogTime() + ']: ' + data, force);
        }
    }
})();
const util = require("./lib/util");
function Chainf() {
    this.chain = Object.create(null); // Using null prototype avoids prototype chain lookups
    this.length = 0;
    this._keys = []; // Cache keys for faster iteration
}

Chainf.prototype.set = function(key, value) {
    // Only increment length if it's a new key
    if (!Object.hasOwn(this.chain, key)) {
        this._keys.push(key);
        this.length++;
    }
    this.chain[key] = value;
    return this; // Enable chaining
}

Chainf.prototype.get = function(key) {
    return this.chain[key];
}

Chainf.prototype.has = function(key) {
    return Object.hasOwn(this.chain, key); // Faster than hasOwnProperty
}

Chainf.prototype.delete = function(key) {
    if (Object.hasOwn(this.chain, key)) {
        delete this.chain[key];
        // Update keys array efficiently
        const keyIndex = this._keys.indexOf(key);
        if (keyIndex !== -1) {
            this._keys.splice(keyIndex, 1);
        }
        this.length--;
        return true;
    }
    return false;
}

Chainf.prototype.clear = function() {
    this.chain = Object.create(null);
    this._keys = [];
    this.length = 0;
    return this; // Enable chaining
}

Chainf.prototype.forEach = function(callback) {
    const keys = this._keys;
    const chain = this.chain;
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        callback(chain[key], key, i);
    }
    return this; // Enable chaining
}

Chainf.prototype.map = function(callback) {
    const result = [];
    const keys = this._keys;
    const chain = this.chain;
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        result.push(callback(chain[key], key, i));
    }
    return result;
}

Chainf.prototype.mapToChain = function(callback) {
    const keys = this._keys;
    const chain = this.chain;
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        chain[key] = callback(chain[key], key, i);
    }
    return this;
}

Chainf.prototype.filter = function(callback) {
    const result = [];
    const keys = this._keys;
    const chain = this.chain;
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = chain[key];
        if (callback(value, key, i)) {
            result.push(value);
        }
    }
    return result;
}

Chainf.prototype.filterToChain = function(callback) {
    const keys = this._keys;
    const chain = this.chain;
    for (let i = keys.length - 1; i >= 0; i--) {
        const key = keys[i];
        if (!callback(chain[key], key, i)) {
            delete chain[key];
            keys.splice(i, 1);
            this.length--;
        }
    }
    return this;
}

Chainf.prototype.keys = function() {
    return [...this._keys];
}

Chainf.prototype.values = function() {
    const values = [];
    const keys = this._keys;
    const chain = this.chain;
    for (let i = 0; i < keys.length; i++) {
        values.push(chain[keys[i]]);
    }
    return values;
}

Chainf.prototype[Symbol.iterator] = function() {
    let index = 0;
    const keys = this._keys;
    const chain = this.chain;
    const length = keys.length;
    
    return {
        next: function() {
            if (index < length) {
                const key = keys[index++];
                return {
                    value: chain[key],
                    done: false
                };
            }
            return { done: true };
        }
    };
}

const Chain = Chainf;
for (let key of ["log", "warn", "info", "spawn", "error"]) {
    const _oldUtilLog = util[key];
    util[key] = function (text, force) {
        webhooks.log(text, force);
        return _oldUtilLog(text);
    }
}
/*function loadWASM() {
    const Module = require("./wasm.js");
    return new Promise((resolve) => {
        let e = setInterval(function () {
            if (Module.ready) {
                clearInterval(e);
                resolve(Module);
            }
        }, 5);
    });
}*/
global.utility = util;
global.minifyModules = true;
function getApiJazz(){
    let apiEvent = {on:()=>{}}
    let apiConnection;
    async function connectToApi(c) {
        apiConnection = {talk:()=>{}}//new WebSocket(`${c.api_ws_url}/${process.env.API_CONNECTION_KEY}`)
        return {
            apiConnection, apiEvent
        }
    }
    function getApiStuff(){
        return {
            apiConnection,
            apiEvent
        }
    }
    return {
        connectToApi,
        getApiStuff
    }
}

let apiJs = getApiJazz();
((r,e)=>{"function"==typeof define&&define.amd?define([],e):"object"==typeof module&&module.exports?module.exports=e():r.fuzzysort=e()})(this,r=>{"use strict";var i,o,e,a,f=r=>{var e=v(r="string"!=typeof r?"":r);return{target:r,t:e.i,o:e.v,u:N,l:e.g,score:N,_:[0],obj:N}},t=r=>{r=(r="string"!=typeof r?"":r).trim();var e=v(r),a=[];if(e.p)for(var f,t=r.split(/\s+/),t=[...new Set(t)],n=0;n<t.length;n++)""!==t[n]&&(f=v(t[n]),a.push({v:f.v,i:t[n].toLowerCase(),p:!1}));return{v:e.v,g:e.g,p:e.p,i:e.i,h:a}},M=r=>{var e;return 999<r.length?f(r):(void 0===(e=n.get(r))&&(e=f(r),n.set(r,e)),e)},q=r=>{var e;return 999<r.length?t(r):(void 0===(e=s.get(r))&&(e=t(r),s.set(r,e)),e)},D=(r,e,a=!1)=>{if(!1===a&&r.p)return j(r,e);for(var a=r.i,f=r.v,t=f[0],n=e.o,i=f.length,o=n.length,v=0,s=0,u=0;;){if(t===n[s]){if(C[u++]=s,++v===i)break;t=f[v]}if(o<=++s)return N}var v=0,l=!1,g=0,d=e.u,c=(d===N&&(d=e.u=k(e.target)),s=0===C[0]?0:d[C[0]-1],0);if(s!==o)for(;;)if(o<=s){if(v<=0)break;if(200<++c)break;--v;s=d[L[--g]]}else if(f[v]===n[s]){if(L[g++]=s,++v===i){l=!0;break}++s}else s=d[s];var w=e.t.indexOf(a,C[0]),r=~w;if(r&&!l)for(var _=0;_<u;++_)C[_]=w+_;a=!1;r&&(a=e.u[w-1]===w);p=l?(b=L,g):(b=C,u);for(var b,p,x=0,h=0,_=1;_<i;++_)b[_]-b[_-1]!=1&&(x-=b[_],++h);if(x-=(12+(b[i-1]-b[0]-(i-1)))*h,0!==b[0]&&(x-=b[0]*b[0]*.2),l){for(var y=1,_=d[0];_<o;_=d[_])++y;24<y&&(x*=10*(y-24))}else x*=1e3;r&&(x/=1+i*i*1),a&&(x/=1+i*i*1),e.score=x-=o-i;for(_=0;_<p;++_)e._[_]=b[_];return e._.j=p,e},j=(r,e)=>{for(var a=new Set,f=0,t=N,n=0,i=r.h,o=0;o<i.length;++o){var v=i[o];if((t=D(v,e))===N)return N;f+=t.score,t._[0]<n&&(f-=n-t._[0]);for(var n=t._[0],s=0;s<t._.j;++s)a.add(t._[s])}r=D(r,e,!0);if(r!==N&&r.score>f)return r;t.score=f;var u,o=0;for(u of a)t._[o++]=u;return t._.j=o,t},v=r=>{for(var e=r.length,a=r.toLowerCase(),f=[],t=0,n=!1,i=0;i<e;++i){var o=f[i]=a.charCodeAt(i);32===o?n=!0:t|=1<<(97<=o&&o<=122?o-97:48<=o&&o<=57?26:o<=127?30:31)}return{v:f,g:t,p:n,i:a}},k=r=>{for(var e=r.length,a=(r=>{for(var e=r.length,a=[],f=0,t=!1,n=!1,i=0;i<e;++i){var o=r.charCodeAt(i),v=65<=o&&o<=90,o=v||97<=o&&o<=122||48<=o&&o<=57,s=v&&!t||!n||!o,t=v,n=o;s&&(a[f++]=i)}return a})(r),f=[],t=a[0],n=0,i=0;i<e;++i)i<t?f[i]=t:(t=a[++n],f[i]=void 0===t?e:t);return f},n=new Map,s=new Map,C=[],L=[],E=r=>{for(var e=J,a=r.length,f=0;f<a;++f){var t=r[f];t!==N&&e<(t=t.score)&&(e=t)}return e===J?N:e},F=(r,e)=>{var a=r[e];if(void 0!==a)return a;for(var f=e,t=(f=Array.isArray(e)?f:e.split(".")).length,n=-1;r&&++n<t;)r=r[f[n]];return r},G=r=>"object"==typeof r,H=1/0,J=-H,K=[],N=null,O=(i=[],o=K.total=0,a=r=>{for(var e=i[t=0],a=1;a<o;){var f=a+1,t=a;f<o&&i[f].score<i[a].score&&(t=f),i[t-1>>1]=i[t],a=1+(t<<1)}for(var n=t-1>>1;0<t&&e.score<i[n].score;n=(t=n)-1>>1)i[t]=i[n];i[t]=e},(e={}).add=r=>{var e=o;i[o++]=r;for(var a=e-1>>1;0<e&&r.score<i[a].score;a=(e=a)-1>>1)i[e]=i[a];i[e]=r},e.k=r=>{var e;if(0!==o)return e=i[0],i[0]=i[--o],a(),e},e.C=r=>{if(0!==o)return i[0]},e.L=r=>{i[0]=r,a()},e);return{single:(r,e)=>{var a;return"farzher"==r?{target:"farzher was here (^-^*)/",score:0,_:[0]}:!r||!e||(r=q(r),G(e)||(e=M(e)),((a=r.g)&e.l)!==a)?N:D(r,e)},go:(r,e,a)=>{if("farzher"==r)return[{target:"farzher was here (^-^*)/",score:0,_:[0],obj:e?e[0]:N}];if(!r)if(a&&a.all){var f=e;var t=a;var n=[],i=(n.total=f.length,t&&t.limit||H);if(t&&t.key)for(var o=0;o<f.length;o++){var v=f[o];var s=F(v,t.key);if(!s)continue;if(!G(s))s=M(s);s.score=J;s._.j=0;var u=s;u={target:u.target,t:"",o:N,u:N,l:0,score:s.score,_:N,obj:v};n.push(u);if(n.length>=i)return n}else if(t&&t.keys)for(o=0;o<f.length;o++){v=f[o];var l=new Array(t.keys.length);for(var g=t.keys.length-1;g>=0;--g){s=F(v,t.keys[g]);if(!s){l[g]=N;continue}if(!G(s))s=M(s);s.score=J;s._.j=0;l[g]=s}l.obj=v;l.score=J;n.push(l);if(n.length>=i)return n}else for(o=0;o<f.length;o++){s=f[o];if(!s)continue;if(!G(s))s=M(s);s.score=J;s._.j=0;n.push(s);if(n.length>=i)return n}return n;return}else return K;var d=q(r),c=d.g,w=(d.p,a&&a.threshold||J),_=a&&a.limit||H,b=0,p=0,x=e.length;if(a&&a.key)for(var h=a.key,y=0;y<x;++y){var j=e[y];!(m=F(j,h))||(c&(m=G(m)?m:M(m)).l)!==c||(B=D(d,m))===N||B.score<w||(B={target:B.target,t:"",o:N,u:N,l:0,score:B.score,_:B._,obj:j},b<_?(O.add(B),++b):(++p,B.score>O.C().score&&O.L(B)))}else if(a&&a.keys)for(var k=a.scoreFn||E,C=a.keys,L=C.length,y=0;y<x;++y){for(var j=e[y],S=new Array(L),z=0;z<L;++z){h=C[z];(m=F(j,h))?(c&(m=G(m)?m:M(m)).l)!==c?S[z]=N:S[z]=D(d,m):S[z]=N}S.obj=j;var A=k(S);A===N||A<w||(S.score=A,b<_?(O.add(S),++b):(++p,A>O.C().score&&O.L(S)))}else for(var m,B,y=0;y<x;++y)!(m=e[y])||(c&(m=G(m)?m:M(m)).l)!==c||(B=D(d,m))===N||B.score<w||(b<_?(O.add(B),++b):(++p,B.score>O.C().score&&O.L(B)));if(0===b)return K;for(var I=new Array(b),y=b-1;0<=y;--y)I[y]=O.k();return I.total=b+p,I},highlight:(r,e,a)=>{if("function"==typeof e){var f=e;if((l=r)===N)return N;for(var t=l.target,n=t.length,i=(i=l._).slice(0,i.j).sort((r,e)=>r-e),o="",v=0,s=0,u=!1,l=[],g=0;g<n;++g){var d=t[g];if(i[s]===g){if(++s,u||(u=!0,l.push(o),o=""),s===i.length){o+=d,l.push(f(o,v++)),o="",l.push(t.substr(g+1));break}}else u&&(u=!1,l.push(f(o,v++)),o="");o+=d}return l}if(r===N)return N;void 0===e&&(e="<b>"),void 0===a&&(a="</b>");for(var c="",w=0,_=!1,b=r.target,p=b.length,x=(x=r._).slice(0,x.j).sort((r,e)=>r-e),h=0;h<p;++h){var y=b[h];if(x[w]===h){if(_||(_=!0,c+=e),++w===x.length){c+=y+a+b.substr(h+1);break}}else _&&(_=!1,c+=a);c+=y}return c},prepare:f,indexes:r=>r._.slice(0,r._.j).sort((r,e)=>r-e),cleanup:()=>{n.clear(),s.clear(),C=[],L=[]}}});
let api = apiJs.getApiStuff()
let forcedProfile = false;
api.apiEvent.on("forcedProfile", (data) => {
    forcedProfile = data.data
})
const restricted = [];
async function getForcedProfile() {
    return new Promise(resolve => {
        const interval = setInterval(() => {
            if (forcedProfile !== false) {
                clearInterval(interval);
                resolve();
            }
        });
    });
}

api.apiEvent.on("tokenData", (data) => {
    tokendata = data.data
});

(async () => {
    //const WASMModule = await loadWASM();



    //"use strict";
    let serverPrefix;
    //global.c = require("./configs/sterilize.js")(`config`),
    api = await apiJs.connectToApi(/*c*/)
    if (process.argv[2]) {
        serverPrefix = configSuffix
        console.log(`Forcing server prefix to ${configSuffix}`)
    } else {
        try {
            console.log("Server is supposed to be online. Loading profile", configSuffix);
            serverPrefix = `-${configSuffix}`;
        } catch (e) {
            console.error(e)
            console.log("Couldn't load from API. Terminating.");
            if (global.isVPS) process.exit();
        }
    }

    let baseConfig = {
        "host": "0.0.0.0",
        "api_url": "https://woomy-api.glitch.me",
        "api_ws_url": "wss://woomy-api.glitch.me",
        "servesStatic": true,
        "mockupChunkLength": 200,
        "port": 3001,
        "restarts": {
            "enabled": true,
            "interval": 14401
        },
        "networkUpdateFactor": 24,
        "socketWarningLimit": 5,
        "tabLimit": 1,
        "strictSingleTab": true,
        "maxPlayers": 999,
        "BETA": 0,
        "networkFrontlog": 1,
        "networkFallbackTime": 150,
        "visibleListInterval": 60,
        "gameSpeed": 1,
        "runSpeed": 1.75,
        "maxHeartbeatInterval": 1000,
        "verbose": true,
        "WIDTH": 6500,
        "HEIGHT": 6500,
        "connectionLimit": 999,
        "MODE": "ffa",
        "serverName": "Free For All",
        "TEAM_AMOUNT": 2,
        "RANDOM_COLORS": false,
        "BOSS_SPAWN_TIMER": 2000,
        "PORTALS": {
            "ENABLED": false,
            "TANK_FORCE": 3000,
            "TANK_DAMP": 4000,
            "BOSS_FORCE": 12500,
            "DIVIDER_1": {
                "ENABLED": true,
                "LEFT": 2979,
                "RIGHT": 3521
            },
            "DIVIDER_2": {
                "ENABLED": true,
                "TOP": 2979,
                "BOTTOM": 3521
            }
        },
        "MAZE": {
            "ENABLED": false,
            "cellSize": 150,
            "stepOneSpacing": 3,
            "fillChance": 0.33,
            "sparedChance": 0.65,
            "cavey": false,
            "lineAmount": false,
            "margin": 0,
            "posMulti": 0.25
        },
        "BANNED_CHARACTER_REGEX": "/[\uFDFD\u200E\u0000]/gi",
        "ROOM_SETUP": [
            ["roid", "norm", "norm", "norm", "rock", "norm", "norm", "norm", "rock", "rock", "norm", "norm", "norm", "rock", "norm", "norm", "norm", "roid"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "rock", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "rock", "norm", "norm", "norm"],
            ["rock", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "rock"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "nest", "nest", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "roid", "nest", "nest", "nest", "nest", "roid", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "nest", "nest", "nest", "nest", "nest", "nest", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["rock", "norm", "norm", "norm", "norm", "nest", "nest", "nest", "roid", "roid", "nest", "nest", "nest", "norm", "norm", "norm", "norm", "rock"],
            ["rock", "norm", "norm", "norm", "norm", "nest", "nest", "nest", "roid", "roid", "nest", "nest", "nest", "norm", "norm", "norm", "norm", "rock"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "nest", "nest", "nest", "nest", "nest", "nest", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "roid", "nest", "nest", "nest", "nest", "roid", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "nest", "nest", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["rock", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "rock"],
            ["norm", "norm", "norm", "rock", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "rock", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm"],
            ["roid", "norm", "norm", "norm", "rock", "norm", "norm", "norm", "rock", "rock", "norm", "norm", "norm", "rock", "norm", "norm", "norm", "roid"]
        ],
        "X_GRID": 18,
        "Y_GRID": 18,
        "DAMAGE_CONSTANT": 0.75,
        "KNOCKBACK_CONSTANT": 1.8,
        "BORDER_FORCE": 0.025,
        "OUTSIDE_ROOM_DAMAGE": 0,
        "MAX_SKILL": 9,
        "SOFT_MAX_SKILL": 0.59,
        "REGEN_MULTIPLIER": 0.45,
        "TIER_1": 15,
        "TIER_2": 30,
        "TIER_3": 45,
        "TIER_4": 60,
        "TIER_5": 60,
        "LEVEL_ZERO_UPGRADES": false,
        "SKILL_CAP": 60,//75 for tier 5s
        "SKILL_SOFT_CAP": 0,
        "SKILL_CHEAT_CAP": 60,//60 for tier 5s
        "SKILL_LEAK": 0,
        "STEALTH": 4,
        "MIN_SPEED": 0.001,
        "MIN_DAMAGE": 0,
        "MAX_FOOD": 400,
        "MAX_NEST_FOOD": 30,
        "MAX_CRASHERS": 18,
        "MAX_SANCS": 1,
        "TIME_BETWEEN_SANCS": 900000,
        "EVOLVE_TIME": 90000,
        "EVOLVE_TIME_RAN_ADDER": 210000,
        "EVOLVE_HALT_CHANCE": 0.25,
        "SHINY_CHANCE": 0.00001,
        "SKILL_BOOST": 5,
        "BOTS": 10,
        "GLASS_HEALTH_FACTOR": 1.8,
        "DO_BASE_DAMAGE": true,
        "SIEGE": false,
        "DISABLE_LEADERBOARD": false,
        "BLACKOUT": false,
        "NO_MAP": false,
        "GAMEMODE_JS": "",
        "TOURNEY": false,
        "LOSE_SCORE_EXPONENT": 0.935,
        "SPAWN_FISHES": false,
        "SPAWN_AQUAFOOD": false
    }

    let sterilize = file => {
        try {
            let data = file;
            for (let key in data) {
                baseConfig[key] = data[key];
            }
        } catch (e) {
            console.log("Failed to load the config using defaults instead...");
        }
        return baseConfig;
    }

    let gamemodeConfig = {  /* "MODE": "tdm",
    "serverName": "CUSTOOOOM",
    "TEAM_AMOUNT": 2,
    "MODE": "tdm",
    "WIDTH": 2450,
    "HEIGHT": 4000,
    "X_GRID": 12,
    "Y_GRID": 25,
    "MAX_FOOD": 0,
    "MAX_edge_FOOD": 0,
    "MAX_CRASHERS": 0,
    "MAX_SANCS": 0,
    "ROOM_SETUP": [
        ["edge","edge","edge","edge","edge","edge","edge","edge","edge","edge","edge","edge"],
        ["edge","edge","edge","norm","norm","n_b2","n_b1","norm","norm","edge","edge","edge"],
        ["edge","edge","norm","norm" ,"norm","n_b2","n_b1","norm","norm" ,"norm","edge","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","domm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","norm","norm","norm","norm","n_b2","n_b1","norm","norm","norm","norm","edge"],
        ["edge","edge","norm","norm","norm","n_b2","n_b1","norm","norm","norm","edge","edge"],
        ["edge","edge","edge","norm","norm","n_b2","n_b1","norm","norm","edge","edge","edge"],
        ["edge","edge","edge","edge","edge","edge","edge","edge","edge","edge","edge","edge"],
        
        
    ],
    "PLAYER_SPAWN_TILES": ["norm"],
    "DO_BASE_DAMAGE": false,
    "BOTS": 0,
    "BORDER_FORCE": 1,
    "OUTSIDE_ROOM_DAMAGE": 0,
    "BOSS_SPAWN_TIMER": 500,
    "LEVEL_ZERO_UPGRADES": true,
    "GAMEMODE_JS": "./server/gamemodes/corruptedTanks.js",
        // normalement ya rien 
       /*"MODE": "tdm",
        "serverName": "Hangout",
        "TEAM_AMOUNT": 1,
        "MODE": "tdm",
        "WIDTH": 8000,
        "HEIGHT": 8000,
        "X_GRID": 2,
        "Y_GRID": 2,
        "MAX_FOOD": 100,
        "MAX_NEST_FOOD": 1,
        "MAX_CRASHERS": 10,
        "MAX_SANCS": 10,
        "ROOM_SETUP": [
            ["norm","nest"],
            ["rock","norm"],
        ],
        "BOTS": 0,
        "BORDER_FORCE": 0.025,
    "BOSS_SPAWN_TIMER": 100*/};
    let res = await fetch("./configs/config-"+configSuffix)  //await fetch("./configs/config-"+configSuffix)   the thing just down below was very annoying :/  also :    await fetch(gamemodeConfig)      let res = await fetch("file:///Users/anakin/Documents/woomy%20mod/woomy-online.glitch.me/configs/config-"+configSuffix)
    if(configSuffix.includes(".json")){
        gamemodeConfig = await res.json()
    }else if(configSuffix.includes(".js")){
        gamemodeConfig = eval(await res.text())
    }else{
        alert("Invalid gamemode file type "+configSuffix)
    }
      if(gamemodeConfig.selectable === false){
      worker.postMessage({type:"serverStartText", text:"This gamemode is not selectable", tip:"This is by design. Please select a different gamemode."})
      return;
    }
    global.c = sterilize(gamemodeConfig);
function numberToLetters(number) {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ       .0123456789';//70 characters
    let result = '';
    
    // Ensure that number is a BigInt if not already
    number = BigInt(number);

    while (number > 0n) {  // Use BigInt literal (0n) for comparison
        number--; // Adjust for 1-indexed system (1 = 'A', 27 = ' ' (space))
        result = chars[Number(number % 70n)] + result; // Convert BigInt to Number for array index
        number = number / 70n;  // Use BigInt division
    }

    return result;
}
  function cleanNulls(obj) {
  if (Array.isArray(obj)) {
    // If it's an array, filter out null or undefined values and clean the elements
    return obj
      .filter(item => item !== null && item !== undefined)
      .map(item => cleanNulls(item)); // Recursively clean each item in the array
  } else if (typeof obj === 'object' && obj !== null) {
    // If it's an object, clean each property
    const cleanedObj = {};
    for (const key in obj) {
      if (obj[key] !== null && obj[key] !== undefined) {
        cleanedObj[key] = cleanNulls(obj[key]); // Recursively clean each property
      }
    }
    return cleanedObj;
  }
  return obj; // Return the value if it's neither an object nor an array
}

    if(c.GAMEMODE_JS){
function getCrptFunction(){
    const CONFIG = {
        usedTanks: 5, // Number of tanks used per generated tank
        maxChildren: 30, // The overall max children a singluar tank can have
        labelLength: 16/* + Math.floor(Math.random * 10) - 5*/, // The random amount of label per tank to use
        gunsPerTank: 7, // The max amount of guns to use from each tank
        turretsPerTank: 2, // The max amount of turrets to use from each tank
        propsPerTank: 2, // The max amount of props to use from each tank
    }

    let defs = defExports
    defs = Object.entries(defs)
    let maxDefLength = defs.length
    for(let arr of defs){
        arr[1].MAX_CHILDREN = CONFIG.maxChildren
        arr[1].ON_TICK = function(me){
            let children = 0;
            if (me.childrenMap.size) {
                let entries = [...me.childrenMap.entries()].reverse()
                for (let v of entries) {
                    children++
                    if (children > CONFIG.maxChildren) {
                        v[1].kill()
                        me.childrenMap.delete(v[0])
                    }
                }
            }
        }
        if(arr[1].GUNS != null){
            for(let gun of arr[1].GUNS){
                if(gun.PROPERTIES != null){
                    gun.PROPERTIES.MAX_CHILDREN = CONFIG.maxChildren
                    gun.PROPERTIES.DESTROY_OLDEST_CHILD = true
                }
            }
        }
    }

    return function(){
        let label = ""
        let finalTank = defs[Math.random() * defs.length | 0][1]
        finalTank.GUNS = []
        finalTank.TURRETS = []
        finalTank.LASERS = []
        finalTank.PROPS = []

        for(let i = 0; i < CONFIG.usedTanks; i++){
            let entity = defs[(Math.random() * maxDefLength | 0)][1]

            if(entity.LABEL){
                let end = Math.random()*entity.LABEL.length|0
                if(label.length+end < CONFIG.labelLength){
                    label += entity.LABEL.substring(0, end)
                }
            }

            if(entity.GUNS){
                for(let a = 0; a < CONFIG.gunsPerTank; a++){
                    let gun = entity.GUNS[(Math.random() * entity.GUNS.length | 0)]
                    if(!gun) continue;
                    if(gun.PROPERTIES){

                    }
                    finalTank.GUNS.push(gun)
                }
            }

            if (entity.TURRETS) {
                for (let a = 0; a < CONFIG.turretsPerTank; a++) {
                    let turret = entity.TURRETS[(Math.random() * entity.TURRETS.length | 0)]
                    if (!turret) continue;
                    turret.MAX_CHILDREN = CONFIG.maxChildren
                    if (turret.GUNS != null) {
                        for (let gun of turret.GUNS) {
                            if (gun.PROPERTIES != null) {
                                gun.PROPERTIES.MAX_CHILDREN = CONFIG.maxChildren
                                gun.PROPERTIES.DESTROY_OLDEST_CHILD = true
                            }
                        }
                    }
                    finalTank.TURRETS.push(turret)
                }
            }

            if (entity.PROPS) {
                for (let a = 0; a < CONFIG.propsPerTank; a++) {
                    let prop = entity.PROPS[(Math.random() * entity.PROPS.length | 0)]
                    if (!prop) continue;
                    finalTank.PROPS.push(prop)
                }
            }
        }
        let randomLabel = 0
        let randomDice = Math.floor(Math.random() * 6)
          randomLabel = BigInt(Math.floor(Math.random() * Math.pow(70, 4)))
        if (randomDice <= 1) {
          finalTank.LABEL = label
        } else {
            finalTank.LABEL = numberToLetters(randomLabel).charAt(0).toUpperCase() + numberToLetters(randomLabel).slice(1)
            if (randomDice == 4) {
              let randomLabelTwo = BigInt(Math.floor(Math.random() * Math.pow(70, 4)))    
              finalTank.LABEL = numberToLetters(randomLabel).charAt(0).toUpperCase() + numberToLetters(randomLabel).slice(1) + (numberToLetters(randomLabelTwo))   
              //console.log(numberToLetters(randomLabel) + numberToLetters(randomLabelTwo))
              }
            if (randomDice == 5) {
              let randomLabelTwo = BigInt(Math.floor(Math.random() * Math.pow(70, 4)))
              let randomLabelThree = BigInt(Math.floor(Math.random() * Math.pow(70, 4)))
              finalTank.LABEL = numberToLetters(randomLabel).charAt(0).toUpperCase() + numberToLetters(randomLabel).slice(1) + (numberToLetters(randomLabelTwo)) + numberToLetters(randomLabelThree)
              //console.log(numberToLetters(randomLabel) + numberToLetters(randomLabelTwo) + numberToLetters(randomLabelThree))
            }
            //console.log(numberToLetters(randomLabel))
        }
        if(finalTank?.PARENT?.length)finalTank.PARENT[0].CONTROLLERS = []
        finalTank.CONTROLLERS = []
        finalTank.TYPE = "tank"
        finalTank.DIE_AT_LOW_SPEED = false
        finalTank.DIE_AT_RANGE = false
        finalTank.INDEPENDANT = true
        finalTank.HAS_NO_MASTER = true
        finalTank.ACCEPTS_SCORE = true
        finalTank.CAN_BE_ON_LEADERBOARD = true
        finalTank.GOD_MODE = false
        finalTank.IS_ARENA_CLOSER = false
        //finalTank.PASSIVE = false //mine
        finalTank.STAT_NAMES = 6 // generic
        finalTank.SKILL_CAP = [9, 9, 9, 9, 9, 9, 9, 9, 9, 9]
        finalTank.AI = {}
        //finalTank.MOTION_TYPE = 'motor'
        //finalTank.FACING_TYPE = 'toTarget'
        finalTank.SANCTUARY_TYPE = 'None'
        finalTank.BOSS_TYPE = 'None'
        finalTank.RANDOM_TYPE = 'None'
        finalTank.MISC_IDENTIFIER = "None"
        finalTank.MAX_CHILDREN = (CONFIG.usedTanks*CONFIG.gunsPerTank*CONFIG.maxChildren)*0.5
        finalTank.isCorrupted = true //mine
        let exportName = `${Date.now()}-${Math.random()}`
        console.log("Guns, Turrets, Props and Body Data of " + exportName + ": (" + finalTank.LABEL + ")")
        console.log('GUNS:', JSON.stringify(cleanNulls(finalTank.GUNS), null, 2));
        console.log('TURRETS:', JSON.stringify(cleanNulls(finalTank.TURRETS), null, 2));
        console.log('PROPS:', JSON.stringify(cleanNulls(finalTank.PROPS), null, 2));
        console.log('BODY:', JSON.stringify(cleanNulls(finalTank.BODY), null, 2));
        global.addNewClass(exportName, finalTank)
        return exportName
    }
}
        global.gamemodeCode = {generateNewTank: getCrptFunction()}
    }
    webhooks.log("Server initializing!");
    const defsPrefix = "";//process.argv[3] || "";
    const ran = require("./lib/random");
    const LZString = require("./lib/LZString");
    global.sandboxRooms = [];
    Array.prototype.remove = index => {
        if (index === this.length - 1) return this.pop();
        else {
            let r = this[index];
            this[index] = this.pop();
            return r;
        }
    };

    let rankedRoomTicker = 0, rankedRooms = {};
    function* chunkar(array, int) {
        for (let i = 0; i < array.length; i += int) {
            yield array.slice(i, i + int);
        }
    };

    class RankedRoom {
        constructor(clients) {
            this.clients = clients;
            this.id = rankedRoomTicker++;
            this.timer = 46;
            this.timeout = null;
            this.forEach((socket) => {
                socket.roomId = this.id;
                socket.battleRoom = this;
                socket.talk("w", true);
            });
            this.battleStarted = false;
            this.loop();
            this.createMap();
            rankedRooms[this.id] = this;
        }
        createMap() {
            switch (Math.random() * 3 | 0) {
                case 0: {
                    const types = [Class.babyObstacle, Class.obstacle, Class.megaObstacle];
                    const count = (room.width / 100) * (Math.random() + .75);
                    for (let i = 0; i < count; i++) {
                        setTimeout(() => {
                            let type = ran.choose(types);
                            let x = 0,
                                position;
                            do {
                                position = room.randomType("norm");
                                x++;
                                if (x > 200) {
                                    util.warn("Failed to place obstacles!");
                                    return 0;
                                }
                            } while (dirtyCheck(position, 10 + type.SIZE));
                            let o = new Entity(position);
                            o.define(type);
                            o.team = -101;
                            o.facing = ran.randomAngle();
                            o.protect();
                            o.life();
                            o.roomId = this.id;
                        }, i * 250);
                    }
                } break;
                case 1: {
                    global.generateMaze(this.id);
                } break;
            }
        }
        broadcast(message, color = "") {
            this.forEach((socket) => {
                socket.talk("m", message, color);
            });
        }
        forEach(callback) {
            for (let i = 0; i < this.clients.length; i++) {
                callback(this.clients[i], this.clients[i].player ? this.clients[i].player.body : null, i);
            }
        }
        loop() { // 1s loop
            if (this.clients.filter(client => client.readyState === client.OPEN).length < 2) {
                this.forEach((socket, instance) => {
                    socket.talk("w", "results", 2, "The other party has disconnected");
                    socket.roomId = "ready";
                    if (instance) {
                        instance.onDead = () => { };
                        instance.kill();
                    }
                });
                entities.forEach(o => {
                    if (o.roomId === this.id) {
                        o.kill();
                    }
                });
                delete rankedRooms[this.id];
                return;
            }
            this.timer--;
            let stop = false;
            if (!this.battleStarted) { // Pre battle
                if (!this.timer) {
                    this.battleStarted = true;
                    this.timer = 181;
                    this.broadcast("The match has started! Good luck!");
                    entities.forEach(o => {
                        if (o.roomId === this.id) {
                            o.passive = false;
                        }
                    });
                    this.forEach((_, body) => {
                        if (body) {
                            body.passive = false;
                            body.invuln = false;
                            body.upgrades = [];
                            body.onDead = () => {
                                this.forEach((socket, instance) => {
                                    socket.talk("w", "results", socket.id !== body.socket.id, `1v1 Ranked Battle ${this.clients.map(client => `[${client.name}]`).join(" vs. ")}`);
                                    socket.roomId = "ready";
                                    if (socket.betaData.discordID !== -1) {
                                    }
                                    if (instance) {
                                        instance.onDead = () => { };
                                        instance.kill();
                                    }
                                });
                                entities.forEach(o => {
                                    if (o.roomId === this.id) {
                                        o.kill();
                                    }
                                });
                                clearTimeout(this.timeout);
                                delete rankedRooms[this.id];
                            }
                        }
                    });
                    this.timeout = setTimeout(() => this.loop(), 1000);
                    return;
                }
                this.forEach((_, body, i) => {
                    if (body) {
                        body.roomId = this.id;
                        body.passive = true;
                        body.x = i ? room.width : 0;
                        body.y = i ? room.height : 0;
                        body.onDead = () => {
                            this.forEach((socket, instance) => {
                                socket.talk("w", "results", 2, "The other party has disconnected");
                                socket.roomId = "ready";
                                if (instance) {
                                    instance.onDead = () => { };
                                    instance.kill();
                                }
                            });
                            entities.forEach(o => {
                                if (o.roomId === this.id) {
                                    o.kill();
                                }
                            });
                            clearTimeout(this.timeout);
                            delete rankedRooms[this.id];
                        }
                    } else if (this.timer <= 40) {
                        this.forEach((socket, instance) => {
                            socket.talk("w", "results", 2, "The other party has disconnected");
                            socket.roomId = "ready";
                            if (instance) {
                                instance.onDead = () => { };
                                instance.kill();
                            }
                        });
                        entities.forEach(o => {
                            if (o.roomId === this.id) {
                                o.kill();
                            }
                        });
                        clearTimeout(this.timeout);
                        delete rankedRooms[this.id];
                    }
                });
                if (this.timer < 10 || this.timer % 5 === 0) {
                    this.broadcast(this.timer + "s until start!");
                }
            } else {
                if (!this.timer) {
                    this.forEach((socket, instance) => {
                        socket.talk("w", "results", 2, "Time has expired");
                        socket.roomId = "ready";
                        if (instance) {
                            instance.onDead = () => { };
                            instance.kill();
                        }
                    });
                    entities.forEach(o => {
                        if (o.roomId === this.id) {
                            o.kill();
                        }
                    });
                    delete rankedRooms[this.id];
                    return;
                }
                if (this.timer < 10 || this.timer % (this.timer <= 30 ? 5 : 10) === 0) {
                    this.broadcast(this.timer + "s until the match is over!");
                }
            }
            if (stop) {
                return;
            }
            this.timeout = setTimeout(() => this.loop(), 1000);
        }
        get leaderboard() {
            let entries = this.clients.filter(client => client.player && client.player.body).map(client => {
                let body = client.player.body;
                return [
                    body.id,
                    Math.round(body.skill.score),
                    this.battleStarted ? body.index : Class.rankedBattle.index,
                    body.name,
                    body.color,
                    100 + Date.now() * 0.001 % 85 | 0,
                    body.nameColor,
                    body.labelOverride || 0
                ];
            });
            return [entries.length, ...entries].flat();
        }
        get minimap() {
            let entries = entities.filter(entity => entity.roomId === this.id && (entity.type === 'wall' || entity.type === "mazeWall") && entity.alpha > 0.2).map(my => {
                return [
                    my.id,
                    (my.type === 'wall' || my.type === "mazeWall") ? my.shape === 4 ? 2 : 1 : 0,
                    util.clamp(Math.floor(256 * my.x / room.width), 0, 255),
                    util.clamp(Math.floor(256 * my.y / room.height), 0, 255),
                    my.color,
                    Math.round(my.SIZE),
                    my.width || 1,
                    my.height || 1
                ]
            });
            return [entries.length, ...entries].flat();
        }
    }
    class Room {
        constructor(config) {

            if (!global.isVPS) {
                c.tabLimit = 1e5;
            }

            this.config = config;
            this.width = config.WIDTH;
            this.height = config.HEIGHT;
            this.setup = config.ROOM_SETUP;
            this.xgrid = this.setup[0].length;
            this.ygrid = this.setup.length;
            this.xgridWidth = this.width / this.xgrid;
            this.ygridHeight = this.height / this.ygrid;
            this.lastCycle = undefined;
            this.cycleSpeed = 1000 / c.gameSpeed / 30;
            this.gameMode = config.MODE;
            this.testingMode = c.testingMode;
            this.speed = c.gameSpeed;
            this.timeUntilRestart = c.restarts.interval;
            this.maxBots = c.BOTS;
            this.maxFood = config.MAX_FOOD;
            this.maxNestFood = config.MAX_NEST_FOOD;
            this.maxCrashers = config.MAX_CRASHERS;
            this.maxSbEntities = config.MAX_ENTITIES;
            this.maxSancs = config.MAX_SANCS;
            this.skillBoost = config.SKILL_BOOST;
            this.topPlayerID = -1;
            this.arenaClosed = false;
            this.teamAmount = c.TEAM_AMOUNT;
            this.modelMode = c.modelMode;
            this.bossRushOver = false;
            this.bossRushWave = 0;
            this.bossString = "";
            this.infernumCoef = 0; //mine for siegeg
            this.motherships = [];
            this.nextTagBotTeam = [];
            this.defeatedTeams = [];
            this.wallCollisions = [];
            this.score1 = 1;//all os these are mine bruh
            this.score2 = 1;
            this.BextraSkill = 0;
            this.RextraSkill = 0;
            this.BPerk1 = 0;
            this.RPerk1 = 0;
            this.BPerk2 = 0;
            this.RPerk2 = 0;
            this.BPerk3 = 0;
            this.RPerk3 = 0;
            this.BPerk4 = 0;
            this.RPerk4 = 0;
            this.BPerk5 = 0;
            this.RPerk5 = 0;
            this.BPerk6 = 0;
            this.RPerk6 = 0;
            this.BPerk7 = 0;
            this.RPerk7 = 0;
            this.BPerk8 = 0;
            this.RPerk8 = 0;
            this.BPerk9 = 0;
            this.RPerk9 = 0;
            this.BPerk10 = 0;
            this.RPerk10 = 0;
            this.gameEnd = false
            this.detWon = false
            this.murWon = false
            /*this.blueUpgrades {
                extraSkill: 0
            };
            this.redUpgrades {
                extraSkill: 0
            };*/
            
            this.cardinals = [
                ["NW", "Northern", "NE"],
                ["Western", "Center", "Eastern"],
                ["SW", "Southern", "SE"]
            ];
            this.cellTypes = (() => {
                const output = ["nest", "norm", "rock", "roid", "port", "wall", "door", "edge", "domi", "outb", "door", "boss","compound","blightlands","forest","ice","desert","hell","myboss", "sb"/*,"iceWall"*/];//mines after bosses
                for (let i = 1; i <= 8; i++) {
                    output.push("bas" + i);
                    output.push("bad" + i);
                    output.push("n_b" + i);
                    output.push("dom" + i);
                    output.push("mot" + i);
                    output.push("spn" + i);
                }
                for (let i = 0; i < this.ygrid; i++) {
                    for (let j = 0; j < this.xgrid; j++) {
                        if (!output.includes(this.setup[i][j])) {
                            output.push(this.setup[i][j]);
                        }
                    }
                }
                return output;
            })();
            for (let type of this.cellTypes) {
                this.findType(type);
            }
            this.partyHash = Array(config.TEAM_AMOUNT || 0).fill().map((_, i) => 1000 * (i + 1) + Math.floor(1000 * Math.random()));
            this.blackHoles = [];
            this.scale = {
                square: this.width * this.height / 100000000,
                linear: Math.sqrt(c.WIDTH * c.HEIGHT / 100000000)
            };
            this.rankedRoomTicker = 0;
            this.rankedRooms = [];
            this.tagMode = c.serverName.includes("Tag");
            this.mapPoints = [];
            if (c.ARENA_TYPE === 3) {
                let dist = this.width / 4;
                for (let i = 0; i < 3; i++) {
                    let angle = (Math.PI * 2 / 3 * i) + Math.PI / 2,
                        x = dist * Math.cos(angle) + this.width / 2,
                        y = dist * Math.sin(angle) + this.width / 2;
                    this.mapPoints.push({ x, y, angle });
                }
            }
        }
        isInRoom(location) {
            return location.x >= 0 && location.x <= this.width && location.y >= 0 && location.y <= this.height;
        }
        findType(type) {
            const output = [];
            for (let i = 0, l = this.setup.length; i < l; i++) {
                for (let j = 0, k = this.setup[i].length; j < k; j++) {
                    if (this.setup[i][j] === type) {
                        output.push({
                            x: (j + 0.5) * this.width / this.xgrid,
                            y: (i + 0.5) * this.height / this.ygrid,
                            id: j * this.xgrid + i
                        });
                    }
                }
            }
            this[type] = output;
        }
        setType(type, location) {
            if (!this.isInRoom(location)) {
                return false;
            }
            const a = ((location.y * this.ygrid) / this.height) | 0;
            const b = ((location.x * this.xgrid) / this.width) | 0;
            const oldType = this.setup[a][b];
            this.setup[a][b] = type;
            this.findType(type);
            this.findType(oldType);
            sockets.broadcastRoom();
        }
        random() {
            return {
                x: ran.irandom(this.width),
                y: ran.irandom(this.height)
            }
        }
        near(position, radius) {
            return {
                x: position.x + ((Math.random() * (radius * 2) | 0) - radius),
                y: position.y + ((Math.random() * (radius * 2) | 0) - radius)
            }
        }
        randomType(type) {
            if (!this[type] || !this[type].length) {
                return this.random();
            }
            const selection = this[type][Math.random() * this[type].length | 0];
            return {
                x: ran.irandom(this.width / this.xgrid) + selection.x - (.5 * this.width / this.xgrid),
                y: ran.irandom(this.height / this.ygrid) + selection.y - (.5 * this.width / this.xgrid),
            }
        }
        isIn(type, location) {
            if (!this.isInRoom(location)) {
                return false;
            }
            const a = (location.y * this.ygrid / this.height) | 0;
            const b = (location.x * this.xgrid / this.width) | 0;
            if (!this.setup[a] || !this.setup[a][b]) {
                return false;
            }
            return type === this.setup[a][b];
        }
        at(location) {
            if (!this.isInRoom(location)) {
                return "fuck";
            }
            const a = (location.y * this.ygrid / this.height) | 0;
            const b = (location.x * this.xgrid / this.width) | 0;
            if (!this.setup[a] || !this.setup[a][b]) {
                return "fuck";
            }
            return this.setup[a][b];
        }
        isAt(location) {
            if (!this.isInRoom(location)) {
                return false;
            }
            const x = (location.x * this.xgrid / this.width) | 0;
            const y = (location.y * this.ygrid / this.height) | 0;
            return {
                x: (x + .5) / this.xgrid * this.width,
                y: (y + .5) / this.ygrid * this.height,
                id: x * this.xgrid + y
            }
        }
        isInNorm(location) {
            if (!this.isInRoom(location)) {
                return false;
            }
            const a = (location.y * this.ygrid / this.height) | 0;
            const b = (location.x * this.xgrid / this.width) | 0;
            if (!this.setup[a] || !this.setup[a][b]) {
                return false;
            }
            const v = this.setup[a][b];
            return v !== 'norm' && v !== 'roid' && v !== 'rock' && v !== 'wall' && v !== 'edge';
        }
        gauss(clustering) {
            let output,
                i = 5;
            do {
                output = {
                    x: ran.gauss(this.width / 2, this.height / clustering),
                    y: ran.gauss(this.width / 2, this.height / clustering),
                };
                i--;
            } while (!this.isInRoom(output) && i > 0);
            return output;
        }
        gaussInverse(clustering) {
            let output,
                i = 5;
            do {
                output = {
                    x: ran.gaussInverse(0, this.width, clustering),
                    y: ran.gaussInverse(0, this.height, clustering),
                };
                i--;
            } while (!this.isInRoom(output), i > 0);
            return output;
        }
        gaussRing(radius, clustering) {
            let output,
                i = 5;
            do {
                output = ran.gaussRing(this.width * radius, clustering);
                output = {
                    x: output.x + this.width / 2,
                    y: output.y + this.height / 2,
                };
                i--;
            } while (!this.isInRoom(output) && i > 0);
            return output;
        }
        gaussType(type, clustering) {
            if (!this[type] || !this[type].length) {
                return this.random();
            }
            const selection = this[type][Math.random() * this[type].length | 0];
            let location = {},
                i = 5;
            do {
                location = {
                    x: ran.gauss(selection.x, this.width / this.xgrid / clustering),
                    y: ran.gauss(selection.y, this.height / this.ygrid / clustering),
                };
                i--;
            } while (!this.isIn(type, location) && i > 0);
            return location;
        }
        regenerateObstacles() {
            entities.forEach(entity => (entity.type === "wall" || entity.type === "mazeWall") && entity.kill());
            if (c.MAZE.ENABLED) {
                global.generateMaze(c.MAZE);
            } else {
                global.placeObstacles();
            }
        }
        init() {
            if (c.ROOM_SETUP.length !== c.Y_GRID) {
                util.warn("c.Y_GRID (" + c.ROOM_SETUP.length + ") has conflicts with the current room setup. Please check these configs and relaunch.");
                process.exit();
            }
            let fail = false;
            for (let i = 0; i < c.ROOM_SETUP.length; i++)
                if (c.ROOM_SETUP[i].length !== c.X_GRID) fail = true;
            if (fail) {
                util.warn("c.X_GRID has conflicts with the current room setup. Please check these configs and relaunch.");
                process.exit();
            }
            util.log(this.width + " x " + this.height + " room initalized. Max food: " + this.maxFood + ". Max nest food: " + this.maxNestFood + ". Max crashers: " + this.maxCrashers + ".");
            if (c.restarts.enabled) {//après ( if (c.restarts.enabled))
                let totalTime = c.restarts.interval;
                setTimeout(() => util.log("Automatic server restarting is enabled. Time until restart: " + this.timeUntilRestart / 7200 + " hours."), 340);
                setInterval(() => {
                    //this.timeUntilRestart--; changé
                    if (this.timeUntilRestart === 1800 || this.timeUntilRestart === 900 || this.timeUntilRestart === 600 || this.timeUntilRestart === 300) {
                        if (c.serverName.includes("Boss")) sockets.broadcast(`WARNING: Tanks have ${this.timeUntilRestart / 60} minutes to defeat the boss rush!`, "#FFE46B");
                        else sockets.broadcast(`WARNING: The server will automatically restart in ${this.timeUntilRestart / 60} minutes!`, "#FFE46B");
                        util.warn(`Automatic restart will occur in ${this.timeUntilRestart / 60} minutes.`);
                    }
                    if (!this.timeUntilRestart) {
                        let reason = c.serverName.includes("Boss") ? "Reason: The tanks could only defeat " + this.bossRushWave + "/100 waves" : "Reason: Uptime has reached " + totalTime / 60 / 60 + " hours";
                        util.warn("Automatic server restart initialized! Closing arena...");
                        let toAdd = c.serverName.includes("Boss") ? "Tanks have run out of time to kill the bosses!" : c.serverName.includes("Domination") ? "No team has managed to capture all of the Dominators! " : c.serverName.includes("Mothership") ? "No team's Mothership has managed to become the last Mothership standing! " : "";
                        sockets.broadcast(toAdd + "Automatic server restart initializing...", "#FFE46B");
                        setTimeout(() => closeArena(), 2500);
                        if (c.serverName.includes("Boss")) this.bossRushOver = true;
                    }
                }, 1000);
            }
            if (c.PORTALS.ENABLED) util.log("Portal mode is enabled.");
            if (this.modelMode) util.warn("Model mode is enabled. This will only allow for you to make and see tank models. No shapes or bosses will spawn, and Basic is the only tank.");
            /*if(c.serverName.includes("Score War")) {
                    for (let i = 0; i < c.TEAM_AMOUNT; i++) {
                        output.leaderboard.push({
                            id: i,
                            skill: {
                                score: c.SOCCER ? soccer.scoreboard[i] : 0,
                            },
                            index: c.SOCCER ? Class.soccerMode.index : Class.tagMode.index,
                            name: ["BLUE", "RED", "GREEN", "PURPLE"][i],
                            color: [10, 12, 11, 15][i] ?? 0,
                            nameColor: "#FFFFFF",
                            team: -i - 1,
                            label: 0
                        });
                    }
                }*/
            //mine
            //if (c.serverName.includes('Score War')) {this.score1 = 0, this.score2 = 0}
        }
        resize(width, height) {
            this.width = width;
            this.height = height;
            for (let type of this.cellTypes) {
                this.findType(type);
            }
            this.regenerateObstacles();
            sockets.broadcastRoom();
        }
    }

    if (typeof c["KILL_SCORE_FORMULA"] === "string") {
        util.getJackpot = eval(`x => ${c["KILL_SCORE_FORMULA"]}`);
    }
    const room = new Room(c);

    class Vector {
        constructor(x, y) {
            this.X = x;
            this.Y = y;
        }
        get x() {
            if (isNaN(this.X)) this.X = c.MIN_SPEED;
            return this.X;
        }
        get y() {
            if (isNaN(this.Y)) this.Y = c.MIN_SPEED;
            return this.Y;
        }
        set x(value) {
            this.X = value;
        }
        set y(value) {
            this.Y = value;
        }
        null() {
            this.X = 0;
            this.Y = 0;
        }
        update() {
            this.len = this.length;
            this.dir = this.direction;
        }
        isShorterThan(d) {
            return this.x * this.x + this.y * this.y <= d * d;
        }
        unit() {
            let length = this.length;
            if (length === 0) return new Vector(1, 0);
            return new Vector(this.x / length, this.y / length);
        }
        get length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        get direction() {
            return Math.atan2(this.y, this.x);
        }
    }

    function newMockups(){
    
    // Defaults
    // Applied to every mockup, adds the value if its missing
    const defaults = {
        x: 0,
        y: 0,
        color: 16,
        shape: 0,
        size: 1,
        realSize: 1,
        facing: 0,
        layer: 0,
        statnames: 0,
        defaultArrayLength: 0,
        aspect: 1,
        skin: 0,
        colorUnmix: 0,
        angle: 0
    };
    
    function applyDefaults(mockup) {
        for (const key in mockup) {
            if (defaults[key] != null) {
                if (mockup[key] == defaults[key] || mockup[key] == null) {
                    delete mockup[key];
                }
            } else if (Array.isArray(mockup[key]) && mockup[key].length === defaults.defaultArrayLength) {
                delete mockup[key];
            }
        }
        (mockup.guns || []).forEach(gun => {
            for (const key in gun) {
                if (defaults[key] != null) {
                    if (gun[key] == defaults[key] || gun[key] == null) {
                        delete gun[key];
                    }
                } else if (Array.isArray(mockup[key]) && gun[key].length === defaults.defaultArrayLength) {
                    delete gun[key];
                }
            }
        });
        return mockup;
    }
  
    
    
    // Parsing
    // Parses the mockups
    class PriorityQueue {
        constructor() {
            this.clear();
        }
        clear() {
            this.array = [];
            this.sorted = true;
        }
        enqueue(priority, to) {
            this.array.push([priority, to]);
            this.sorted = false;
        }
        dequeue() {
            if (!this.sorted) {
                this.array.sort((a, b) => b[0] - a[0]);
                this.sorted = true;
            }
            return this.array.pop()[1];
        }
        getCount() {
            return this.array.length;
        }
    }
    function rounder(val) {
        if (Math.abs(val) < 0.001) val = 0;
        return +val.toPrecision();
    }
    const parseMockup = (e, p) => {
        return {
            index: e.index,
            name: e.label,
            x: rounder(e.x),
            y: rounder(e.y),
            color: e.color,
            shape: e.shapeData || 0,
            size: rounder(e.size),
            realSize: rounder(e.realSize),
            facing: rounder(e.facing),
            layer: e.layer,
            statnames: e.settings.skillNames,
            position: p,
            upgrades: e.upgrades.map(r => ({
                tier: r.tier,
                index: r.index
            })),
            guns: e.guns.map(g => {
                return {
                    offset: rounder(g.offset),
                    direction: rounder(g.direction),
                    length: rounder(g.length),
                    width: rounder(g.width),
                    aspect: rounder(g.aspect),
                    angle: rounder(g.angle),
                    color: rounder(g.color),
                    skin: rounder(g.skin),
                    color_unmix: rounder(g.color_unmix),
                    alpha: g.alpha
                };
            }),
            turrets: e.turrets.map(t => {
                let out = parseMockup(t, {});
                out.sizeFactor = rounder(t.bound.size);
                out.offset = rounder(t.bound.offset);
                out.direction = rounder(t.bound.direction);
                out.layer = rounder(t.bound.layer);
                out.angle = rounder(t.bound.angle);
                return applyDefaults(out);
            }),
            lasers: e.lasers.map(l => {
                return {
                    offset: rounder(l.offset),
                    direction: rounder(l.direction),
                    length: rounder(l.length),
                    width: rounder(l.width),
                    aspect: rounder(l.aspect),
                    angle: rounder(l.angle),
                    color: rounder(l.color),
                    laserWidth: rounder(l.laserWidth)
                };
            }),
            props: e.props.map(p => {
                return {
                    size: rounder(p.size),
                    x: rounder(p.x),
                    y: rounder(p.y),
                    angle: rounder(p.angle),
                    layer: rounder(p.layer),
                    color: rounder(p.color),
                    shape: p.shape,
                    fill: p.fill,
                    loop: p.loop,
                    isAura: p.isAura,
                    rpm: p.rpm,
                    specific: p.specific,
                    dip: p.dip,
                    ring: p.ring,
                    arclen: p.arclen
                };
            })
        };
    };
    
    // Unknown
    // I think this is what generates the upgrade icon data although im not sure
    const lazyRealSizes = (() => {
        let o = [1, 1, 1];
        for (let i = 3; i < 17; i++) {
            // We say that the real size of a 0-gon, 1-gon, 2-gon is one, then push the real sizes of triangles, squares, etc...
            o.push(Math.sqrt((2 * Math.PI / i) * (1 / Math.sin(2 * Math.PI / i))));
        }
        return o;
    })();
    function getDimensions(entities) {
        let endpoints = [];
        let pointDisplay = [];
        let pushEndpoints = function (model, scale, focus = {
            x: 0,
            y: 0
        }, rot = 0) {
            let s = Math.abs(model.shape);
            let z = (Math.abs(s) > lazyRealSizes.length) ? 1 : lazyRealSizes[Math.abs(s)];
            if (z === 1) { // Body (octagon if circle)
                for (let i = 0; i < 2; i += 0.5) {
                    endpoints.push({
                        x: focus.x + scale * Math.cos(i * Math.PI),
                        y: focus.y + scale * Math.sin(i * Math.PI)
                    });
                }
            } else { // Body (otherwise vertices)
                for (let i = (s % 2) ? 0 : Math.PI / s; i < s; i++) {
                    let theta = (i / s) * 2 * Math.PI;
                    endpoints.push({
                        x: focus.x + scale * z * Math.cos(theta),
                        y: focus.y + scale * z * Math.sin(theta)
                    });
                }
            }
            for (let i = 0; i < model.guns.length; i++) {
                let gun = model.guns[i];
                let h = gun.aspect > 0 ? ((scale * gun.width) / 2) * gun.aspect : (scale * gun.width) / 2;
                let r = Math.atan2(h, scale * gun.length) + rot;
                let l = Math.sqrt(scale * scale * gun.length * gun.length + h * h);
                let x = focus.x + scale * gun.offset * Math.cos(gun.direction + gun.angle + rot);
                let y = focus.y + scale * gun.offset * Math.sin(gun.direction + gun.angle + rot);
                endpoints.push({
                    x: x + l * Math.cos(gun.angle + r),
                    y: y + l * Math.sin(gun.angle + r)
                });
                endpoints.push({
                    x: x + l * Math.cos(gun.angle - r),
                    y: y + l * Math.sin(gun.angle - r)
                });
                pointDisplay.push({
                    x: x + l * Math.cos(gun.angle + r),
                    y: y + l * Math.sin(gun.angle + r)
                });
                pointDisplay.push({
                    x: x + l * Math.cos(gun.angle - r),
                    y: y + l * Math.sin(gun.angle - r)
                });
            }
            for (let i = 0; i < model.turrets.length; i++) {
                let turret = model.turrets[i];
                pushEndpoints(turret, turret.bound.size, {
                    x: turret.bound.offset * Math.cos(turret.bound.angle),
                    y: turret.bound.offset * Math.sin(turret.bound.angle)
                }, turret.bound.angle);
            }
        };
        pushEndpoints(entities, 1);
        // 2) Find their mass center
        let massCenter = {
            x: 0,
            y: 0
        };
        // 3) Choose three different points (hopefully ones very far from each other)
        let chooseFurthestAndRemove = function (furthestFrom) {
            let index = 0;
            if (furthestFrom != -1) {
                let list = new PriorityQueue();
                let d;
                for (let i = 0; i < endpoints.length; i++) {
                    let thisPoint = endpoints[i];
                    d = Math.pow(thisPoint.x - furthestFrom.x, 2) + Math.pow(thisPoint.y - furthestFrom.y, 2) + 1;
                    list.enqueue(1 / d, i);
                }
                index = list.dequeue();
            }
            let output = endpoints[index];
            endpoints.splice(index, 1);
            return output;
        };
        let point1 = chooseFurthestAndRemove(massCenter);
        let point2 = chooseFurthestAndRemove(point1);
        let chooseBiggestTriangleAndRemove = function (point1, point2) {
            let list = new PriorityQueue();
            let index = 0;
            let a;
            for (let i = 0; i < endpoints.length; i++) {
                let thisPoint = endpoints[i];
                a = Math.pow(thisPoint.x - point1.x, 2) + Math.pow(thisPoint.y - point1.y, 2) + Math.pow(thisPoint.x - point2.x, 2) + Math.pow(thisPoint.y - point2.y, 2);
                list.enqueue(1 / a, i);
            }
            index = list.dequeue();
            let output = endpoints[index];
            endpoints.splice(index, 1);
            return output;
        };
        let point3 = chooseBiggestTriangleAndRemove(point1, point2);
        // 4) Define our first enclosing circle as the one which seperates these three furthest points
        function circleOfThreePoints(p1, p2, p3) {
            let x1 = p1.x;
            let y1 = p1.y;
            let x2 = p2.x;
            let y2 = p2.y;
            let x3 = p3.x;
            let y3 = p3.y;
            let denom = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2;
            let xy1 = x1 * x1 + y1 * y1;
            let xy2 = x2 * x2 + y2 * y2;
            let xy3 = x3 * x3 + y3 * y3;
            let x = (xy1 * (y2 - y3) + xy2 * (y3 - y1) + xy3 * (y1 - y2)) / (2 * denom);
            let y = (xy1 * (x3 - x2) + xy2 * (x1 - x3) + xy3 * (x2 - x1)) / (2 * denom);
            let r = Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2));
            let r2 = Math.sqrt(Math.pow(x - x2, 2) + Math.pow(y - y2, 2));
            let r3 = Math.sqrt(Math.pow(x - x3, 2) + Math.pow(y - y3, 2));
            //if (r != r2 || r != r3) util.log("Something is up with the mockups generation!");
            return {
                x: isNaN(x) ? 0 : x,
                y: isNaN(y) ? 0 : y,
                radius: isNaN(r) ? 1 : r
            };
        }
        let c = circleOfThreePoints(point1, point2, point3);
        pointDisplay = [{
            x: rounder(point1.x),
            y: rounder(point1.y),
        }, {
            x: rounder(point2.x),
            y: rounder(point2.y),
        }, {
            x: rounder(point3.x),
            y: rounder(point3.y),
        }];
        let centerOfCircle = {
            x: c.x,
            y: c.y
        };
        let radiusOfCircle = c.radius;
        // 5) Check to see if we enclosed everything
        function checkingFunction() {
            for (let i = endpoints.length; i > 0; i--) {
                // Select the one furthest from the center of our circle and remove it
                point1 = chooseFurthestAndRemove(centerOfCircle);
                let vectorFromPointToCircleCenter = new Vector(centerOfCircle.x - point1.x, centerOfCircle.y - point1.y);
                // 6) If we're still outside of this circle build a new circle which encloses the old circle and the new point
                if (vectorFromPointToCircleCenter.length > radiusOfCircle) {
                    pointDisplay.push({
                        x: rounder(point1.x),
                        y: rounder(point1.y)
                    });
                    // Define our new point as the far side of the cirle
                    let dir = vectorFromPointToCircleCenter.direction;
                    point2 = {
                        x: centerOfCircle.x + radiusOfCircle * Math.cos(dir),
                        y: centerOfCircle.y + radiusOfCircle * Math.sin(dir)
                    };
                    break;
                }
            }
            // False if we checked everything, true if we didn't
            return !!endpoints.length;
        }
        while (checkingFunction()) { // 7) Repeat until we enclose everything
            centerOfCircle = {
                x: (point1.x + point2.x) / 2,
                y: (point1.y + point2.y) / 2,
            };
            radiusOfCircle = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2)) / 2;
        }
        // 8) Since this algorithm isn't perfect but we know our shapes are bilaterally symmetrical, we bind this circle along the x-axis to make it behave better
        return {
            middle: {
                x: rounder(centerOfCircle.x),
                y: 0
            },
            axis: rounder(radiusOfCircle * 2),
            points: pointDisplay,
        };
    }
    
    // Mockup Generator
    // Generates the actual mockup info
    let cachedMockups = new Map()
    return {
        getMockup: function (entityIndex, skipCacheCheck) {
            // If we already made the mockup return the cached version
            if(!skipCacheCheck){
                let cachedValue = cachedMockups.get(entityIndex)
                if (cachedValue) {
                    return cachedValue
                }
            }
        
            // Make the mockup
            let classString = `${entityIndex} (entity index)`;
            try {
                classString = exportNames[entityIndex]
                if (!classString) {
                    return ""
                }
                let o = new Entity({
                    x: 0,
                    y: 0
                });
                let temp = Class[classString];
            
                o.upgrades = [];
                o.settings.skillNames = null;
                o.minimalReset();
                o.minimalDefine(temp);
                o.name = temp.LABEL;
                temp.mockup = {
                    body: o.camera(true),
                    position: getDimensions(o)
                };
                temp.mockup.body.position = temp.mockup.position;
                let mockup = applyDefaults(parseMockup(o, temp.mockup.position));
                cachedMockups.set(entityIndex, mockup)
                o.destroy();
                purgeEntities();
                return mockup
            } catch (err) {
                console.error("ERROR WHILE GENERATING MOCKUP: " + classString)
                console.error(err)
            }
        }
    }
}
    global.mockups = newMockups()

    global.exportNames = []
    global.Class = (() => {
        let def = defExports
        for (let k in def) {
            // Checks
            if (!def.hasOwnProperty(k)){
                continue;
            };

            // Add it
            def[k].index = global.exportNames.length;
            global.exportNames[def[k].index] = k
        }
        return def;
    })();
    function updateClassDatas(exportName, data, index/*replaces class rather than make new*/){
        Class[exportName] = data
        Class[exportName].index = index||global.exportNames.length
        if(!index) global.exportNames.push(exportName)
        return Class[exportName]
    }

    // These two are seperate for error catching reasons, you might not mean to overwrite mockups if you do the first but you mean to if you do the second
    global.addNewClass = (exportName, data) => {
        if(Class[exportName]){
            throw new Error(`Trying to add existing mockup "${exportName}"`);
        }
        updateClassDatas(exportName, data)
        sockets.talkToAll("mu", Class[exportName].index, JSON.stringify(mockups.getMockup(Class[exportName].index, true/*skip cache chcek*/)))
    }
    global.updateClass = (exportName, data) =>{
        if (!Class[exportName]) {
            throw new Error(`Trying to update nonexistent mockup "${exportName}"`);
        }
        updateClassDatas(exportName, data, Class[exportName].index)
        sockets.talkToAll("mu", Class[exportName].index, JSON.stringify(mockups.getMockup(Class[exportName].index, true/*skip cache chcek*/)))
    }
    
    global.editorChangeEntity = (code) => {
      let affectedExports = []
      code.split("defExports.").forEach((v)=>{
        v = v.split("=")
        v = v[0].trim()
        if(v.includes("\n") || v === "" || v.match(/^[a-z0-9]+$/i) === null) return;
        affectedExports.push(v)
      })
      console.log("Updating exports for the following entities:", affectedExports)
      
      
      global.initExportCode(code) // run through defs (replaces their defExport)
      
      
      // keep indexs
      let indexs = [];
      let indexI = 0;
      for(let exportName of affectedExports){
        indexs.push(Class[exportName].index)
      }      
      
      for(let exportName of affectedExports){
        Class[exportName].index = indexs[indexI++]
        global.updateClass(exportName, defExports[exportName])
      }
      //console.log("yo, you can't use this rn, wait for a future update :c")
    }

//tank here
    function nearest(array, location, test, skips = 0) {
        if (!array.length) return;
        let priority = Infinity,
            lowest;
        if (test) {
            for (let i = 0, l = array.length; i < l; i++) {
                let x = array[i].x - location.x,
                    y = array[i].y - location.y,
                    d = x * x + y * y;
                if (d < priority && test(array[i], d)) {
                    priority = d;
                    lowest = array[i];
                }
            }
        } else {
            for (let i = 0, l = array.length; i < l; i++) {
                let x = array[i].x - location.x,
                    y = array[i].y - location.y,
                    d = x * x + y * y;
                if (d < priority) {
                    priority = d;
                    lowest = array[i + skips];
                }
            }
        }
        return lowest;
    }

    function timeOfImpact(p, v, s) {
        // Requires relative position and velocity to aiming point
        let a = s * s - (v.x * v.x + v.y * v.y),
            b = p.x * v.x + p.y * v.y,
            c = p.x * p.x + p.y * p.y,
            d = b * b + a * c,
            t = 0;
        if (d >= 0) {
            t = Math.max(0, (b + Math.sqrt(d)) / a);
        }
        return t * 0.9;
    }

    const sendRecordValid = (data) => {
        api.apiConnection.talk({
            type: "record",
            data: {
                gamemode: c.serverName,
                tank: data.tank,
                score: data.score,
                timeAlive: data.timeAlive,
                totalKills: data.totalKills,
                discord: typeof data.discord === "string" ? `<@${data.discord}>` : data.name
            }
        })
    };

    const teamNames = ["BLUE", "RED", "GREEN", "PURPLE", "TEAL", "LIME", "ORANGE", "GREY"];
    const teamColors = [10, 12, 11, 15, 0, 1, 2, 6];

    function getTeamColor(team) {
        if (Math.abs(team) - 1 >= teamNames.length) {
            return 13;
        }
        return teamColors[Math.abs(team) - 1];
    }

    function getTeam(type = 0) { // 0 - Bots only, 1 - Players only, 2 - all
        const teamData = {};
        for (let i = 0; i < room.teamAmount; i++) teamData[i + 1] = 0;
        if (type !== 1) {
            /*entities.forEach(o => {
                if ((o.isBot) && (-o.team > 0 && -o.team <= room.teamAmount)) {
                    teamData[-o.team]++;
                }
            });*/

            for (let o of entities) {
                if (o.isBot && -o.team > 0 && -o.team <= room.teamAmount) {
                    teamData[-o.team]++;
                }
            }
        }
        if (type !== 0) {
            for (let socket of clients) {
                if (socket.rememberedTeam > 0 && socket.rememberedTeam <= room.teamAmount) {
                    teamData[socket.rememberedTeam]++;
                }
            }
        }
        const toSort = Object.keys(teamData).map(key => [key, teamData[key]]).filter(entry => !room.defeatedTeams.includes(-entry[0])).sort((a, b) => a[1] - b[1]);
        return toSort.length === 0 ? ((Math.random() * room.teamAmount | 0) + 1) : toSort[0][0];
    }

    let botTanks = (function () {
        let output = [];
        function add(my, skipAdding = false) {
            if (output.includes(my)) {
                return;
            }
            if (!skipAdding) {
                output.push(my);
            }
            for (let key in my) {
                if (key.startsWith("UPGRADES_TIER")) {
                    my[key].forEach(add);
                    flag = 1;
                }
            }
        }
        if (c.serverName === "Squidward's Tiki Land") add(Class.playableAC);
        else add(Class.basic);
        return output;
    })();
    /*let botTankst5 = (function () {
        let output = [Class.forEach(defExports.tier5tanks.UPGRADES_TIER_4)]
        return output;
    })();*/

    const spawnBot = (loc = null) => {
        let position = loc,
            max = 100;
        if (!loc) {
            do position = room.randomType(c.serverName === "Infiltration" ? "edge" : "norm");
            while (dirtyCheck(position, 400) && max-- > 0);
        }
        if (!loc && c.PLAYER_SPAWN_TILES) {
          i = 10
          let uh = ran.choose(c.PLAYER_SPAWN_TILES)
          do position = room.randomType(uh);
          while (dirtyCheck(position, 50) && i--);
        }
        let o = new Entity(position);
        o.color = 12;
        if (room.gameMode === "tdm") {
            let team = c.serverName === "Infiltration" ? 20 : room.nextTagBotTeam.shift() || getTeam(0);
            o.team = -team;
            o.color = team === 20 ? 17 : [10, 12, 11, 15, 3, 35, 36, 0][team - 1];
        }
        // Reload, Pen, Bullet Health, Bullet Damage, Bullet Speed, Capacity, Body Damage, Max Health, Regen, Speed//24680
        let tank =  ran.choose(botTanks)
            botType = (tank.IS_SMASHER || tank.IS_LANCER) ? "bot2" : "bot",
            skillSet = tank.IS_LANCER ? ran.choose([
                [0, 0, 3, 8, 8, 8, 6, 8, 0, 0],
                [1, 5, 1, 7, 7, 9, 2, 7, 0, 3],
                [0, 0, 0, 6, 9, 9, 9, 9, 0, 0],
            ]) : tank.IS_SMASHER ? ran.choose([
                [12, 12, 11, 11, 11, 11, 0, 12, 0, 6],
                [10, 12, 11, 11, 11, 11, 0, 10, 3, 7],
                [9, 11, 11, 11, 11, 11, 4, 8, 1, 5],
            ]) : ran.choose([ // Dupes act as a weight system lo
                [0, 0, 4, 8, 8, 9, 8, 5, 0, 0],
                [0, 0, 5, 9, 9, 9, 9, 1, 0, 0],
                [0, 0, 8, 7, 7, 8, 5, 7, 0, 0],
                [2, 4, 2, 7, 6, 9, 6, 5, 0, 1],
                [0, 0, 8, 9, 9, 9, 0, 7, 0, 0],
                [0, 0, 4, 8, 8, 9, 8, 5, 0, 0],
                [0, 0, 5, 9, 9, 9, 9, 1, 0, 0],
                [0, 0, 8, 7, 7, 8, 5, 7, 0, 0],
                [0, 0, 5, 9, 9, 9, 9, 1, 0, 0],
                [0, 0, 8, 7, 7, 8, 5, 7, 0, 0],
                [2, 4, 2, 7, 6, 9, 6, 5, 0, 1],
                [0, 0, 8, 9, 9, 9, 0, 7, 0, 0],
                [0, 0, 8, 9, 9, 9, 0, 7, 0, 0],
                [4, 4, 2, 7, 7, 7, 3, 8, 0, 0],
            ]);
        o.isBot = true;
        o.randomThing = Math.random()
        o.define(Class[botType]);//o.define(Class[botType]);
        o.tank = tank;
        o.define(tank);
        if(o.randomThing < 0.1) {o.define(Class.customTankRandomizer)}
        o.name = "[BOT] " + ran.chooseBotName().replaceAll("%t", o.label);
        o.nameColor = o.name.includes("UnderratedBot") ? "#C9FF00" : o.name.includes("Blueky") ? "#00c5ff" : o.name.includes("Reeeedky") ? "#fc9087" : o.name.includes("Musikale") ? "#9b7572": o.name.includes("Bee") ? "#FFF782" : o.name.includes("Honey Bee") ? "#FCCF3B" : o.name.includes("Fallen") ? "#CCCCCC" : "#b4bfff";
        o.autoOverride = true;
        o.invuln = true;
        //o.skill.score = 26302 + Math.floor(10000 * Math.random());
        o.skill.score = 25000 + Math.floor(25000 * Math.random());
        o.fov *= 0.85
        setTimeout(() => {
            o.invuln = false;
            o.autoOverride = false;
            o.skill.maintain();
            o.refreshBodyAttributes();
            //o.controllers = [new ioTypes.nearestEntity(o)]
            o.skill.set([skillSet[6], skillSet[4], skillSet[3], skillSet[5], skillSet[2], skillSet[9], skillSet[0], skillSet[1], skillSet[8], skillSet[7]].map(value => {
                if (value < 9 && Math.random() > 0.85) value += 1;
                return value
            }));
            if (c.serverName === 'Boss Rush' && !tank.INVISIBLE) o.controllers.push(new ioTypes.wanderWhenIdle(o));
            else if (!tank.INVISIBLE) o.controllers.push(new ioTypes.roamWhenIdle(o));
        }, 7500);
        if (room.maxBots > 0) bots.push(o);
        if (c.serverName.includes("The Shattered Beyond")) {
            o.team = -100
            o.color = 34
            o.name = "A Corrupted Soul"
            o.vacoEntry = "004",
            o.scienceValue = 40
            o.nameColor = "#a40101"
            o.labelOverride = "Entry 004"
            o.label = "Corrupted Soul"
        }
if (c.serverName.includes("The Doom Walk")) {
            o.team = -100
            o.color = 34
            o.name = "A Corrupted Soul"
            o.vacoEntry = "004",
            o.scienceValue = 40
            o.nameColor = "#a40101"
            o.labelOverride = "Entry 004"
            o.label = "Corrupted Soul"
        }
        return o;
    };

    const closeArena = () => {
        if (c.serverName.includes("Boss")) room.bossRushOver = true;
        room.arenaClosed = true;
        //if (c.enableBot) editStatusMessage("Offline");
        sockets.broadcast("Arena Closed: No players can join.", "#FF0000");
        for (let socket of clients) socket.talk("P", "The arena has closed. Please try again later once the server restarts.", ran.randomLore());//"P"
        util.log("The arena has closed!", true);
        if (room.modelMode || c.SANDBOX) {
            util.warn("Closing server...");
            return setTimeout(() => process.exit(), 750);
        }
        let closers = [
            Class.arenaCloserAI,
            Class.arenaCloser5AI,
            Class.machCloserAI,
            Class.boostCloserAI,
            Class.rediShotgunAI,
            Class.bigChungusAI,
            Class.sniperCloserAI,
            Class.hotwheelsAI,
            Class.absoluteCyanideAI,
            Class.arenaSummonerAI,
            Class.trapperCloserAI,
            Class.borerCloserAI,
            Class.hybridCloserAI,
            Class.acCeptionAI,
            Class.minishotCloserAI,
            Class.octoArenaCloserAI,
            Class.spreadCloserAI,
            Class.ac3ai
        ],
            positions = [{
                x: room.width * .25,
                y: room.height * -.25
            }, {
                x: room.width * .25,
                y: room.height * 1.25
            }, {
                x: room.width * -.25,
                y: room.height * .25
            }, {
                x: room.width * 1.25,
                y: room.height * .25
            }, {
                x: room.width * .75,
                y: room.height * -.25
            }, {
                x: room.width * 1.25,
                y: room.height * 1.25
            }, {
                x: room.width * -.25,
                y: room.height * .75
            }, {
                x: room.width * 1.25,
                y: room.height * .75
            }];
        for (let i = 0; i < 8; i++) {
            let o = new Entity(positions[i]);
            o.define(ran.choose(closers));
            o.team = -100;
            o.alwaysActive = true;
            //o.facing += ran.randomRange(.5 * Math.PI, Math.PI); // Does nothing
        }
        for (let body of bots) body.kill();
        let completed = false;
        let interval = setInterval(() => {
            let alivePlayers = players.filter(player => player.body != null && player.body.isAlive() && player.body.type === "tank");
            for (let player of alivePlayers) {
                let body = player.body;
                body.passive = body.invuln = body.godmode = false;
                entities.forEach(o => {
                    if (o.master.id === body.id && o.id !== body.id) o.passive = false;
                });
                body.dangerValue = 7;
            }
            if (!alivePlayers.length && !completed) {
                completed = true;
                clearInterval(interval);
                setTimeout(() => {
                    util.log("All players are dead! Ending process...", true);
                    setTimeout(process.exit, 500);
                }, 1000);
            }
        }, 100);
        setTimeout(() => {
            completed = true;
            util.log("Arena Closers took too long! Ending process...", true);
            setTimeout(process.exit, 500);
        }, 6e4);
    };

    function countPlayers() {
        let teams = [];
        for (let i = 1; i < c.TEAM_AMOUNT + 1; i++) teams.push([-i, 0]);
        let all = 0;
        /*entities.forEach(o => {
            if (o.isPlayer || o.isBot) {
                if ([-1, -2, -3, -4, -5, -6, -7, -8].includes(o.team)) {
                    teams.find(entry => entry[0] === o.team)[1]++;
                    all++;
                };
            }
        });*/
        for (let o of entities) {
            if (o.isPlayer || o.isBot) {
                if ([-1, -2, -3, -4, -5, -6, -7, -8].includes(o.team)) {
                    teams.find(entry => entry[0] === o.team)[1]++;
                    all++;
                };
            }
        }
        let team = teams.find(entry => entry[1] === all);
        if (team) winner(-team[0] - 1);
    };

    let won = false;

    function winner(teamId) {
        if (won) return;
        won = true;
        let team = ["BLUE", "RED", "GREEN", "PURPLE"][teamId];
        sockets.broadcast(team + " has won the game!", ["#00B0E1", "#F04F54", "#00E06C", "#BE7FF5", "#FFEB8E", "F37C20", "#E85DDF", "#8EFFFB"][teamId]);
        setTimeout(closeArena, 3e3);
    };

    function tagDeathEvent(instance) {
        let killers = [];
        for (let entry of instance.collisionArray)
            if (entry.team > -9 && entry.team < 0 && instance.team !== entry.team) killers.push(entry);
        if (!killers.length) return;
        let killer = ran.choose(killers);
        if (instance.socket) instance.socket.rememberedTeam = -killer.team;
        if (instance.isBot) room.nextTagBotTeam.push(-killer.team);
        setTimeout(countPlayers, 1000);
    }

    const smoke = (timeout, x, y) => {
        let smokeSpawner = new Entity({
            x: x,
            y: y
        });
        smokeSpawner.define(Class.smokeSpawner);
        smokeSpawner.passive = true;
        setTimeout(() => smokeSpawner.kill(), timeout);
    };

    class Domination {
        constructor() {
            this.takenDominators = (new Array(room.teamAmount)).fill(0);
            this.amountOfDominators = room.domi.length;
        }

        init() {
            for (let location of room.domi) {
                let dominator = new Entity(location);
                dominator.define([
                    Class.destroyerDominatorAI,
                    Class.gunnerDominatorAI,
                    Class.trapperDominatorAI,
                    Class.crockettDominatorAI,
                    Class.steamrollDominatorAI,
                    Class.autoDominatorAI
                ][ran.chooseChance(35, 35, 10, 8, 10, 10)]);

                dominator.alwaysActive = true;
                dominator.color = 13;
                dominator.FOV = .5;
                dominator.isDominator = true;
                dominator.miscIdentifier = "appearOnMinimap";
                dominator.settings.hitsOwnType = "pushOnlyTeam";
                dominator.SIZE = 70;
                dominator.team = -100;

                dominator.onDead = () => {
                    // Cheeky lil workabout so we don't have to redefine a dominator
                    dominator.health.amount = dominator.health.max;
                    dominator.isGhost = false;
                    dominator.hasDoneOnDead = false;

                    // Get the people who murdered the dominator
                    let killers = [];
                    for (let instance of dominator.collisionArray) {
                        if (instance.team >= -room.teamAmount && instance.team <= -1) {
                            killers.push(instance.team);
                        }
                    }

                    let killTeam = killers.length ? ran.choose(killers) : 0,
                        team = ["INVALID", "BLUE", "RED", "GREEN", "PURPLE", "YELLOW", "ORANGE", "PINK", "TEAL"][-killTeam],
                        teamColor = ["#000000", "#00B0E1", "#F04F54", "#00E06C", "#BE7FF5", "#FFEB8E", "#F37C20", "#E85DDF", "#8EFFFB"][-killTeam];

                    // If the dominator is taken, make it contested
                    if (dominator.team !== -100) {
                        this.takenDominators[-dominator.team] -= 1;
                        killTeam = 0;
                        sockets.broadcast(`The ${room.cardinals[Math.floor(3 * location.y / room.height)][Math.floor(3 * location.x / room.height)]} Dominator is being contested!`, "#FFE46B");
                    } else { // If a contested dominator is taken...
                        this.takenDominators[-killTeam] += 1;
                        sockets.broadcast(`The ${room.cardinals[Math.floor(3 * location.y / room.height)][Math.floor(3 * location.x / room.height)]} Dominator is now captured by ${team}!`, teamColor);

                        entities.forEach(body => {
                            if (body.team === killTeam && body.type === "tank" && !body.underControl) {
                                body.sendMessage("Press H to control the Dominator!");
                            }
                        });
                    }

                    // Set area type based off of team
                    room.setType(`dom${-killTeam || "i"}`, location);

                    // Set dominator team
                    dominator.team = killTeam || -100;
                    dominator.color = [13, 10, 12, 11, 15, 3, 35, 36, 0][-killTeam];

                    // If all dominators are taken by the same team, close the arena
                    if (this.takenDominators.includes(this.amountOfDominators) && killTeam && !room.arenaClosed) {
                        util.warn(`${team} has won the game! Closing arena...`);
                        setTimeout(() => sockets.broadcast(`${team} has won the game!`, teamColor), 2e3);
                        setTimeout(() => closeArena(), 5e3);
                    }
                };
            }
        }
    }

    const mothershipLoop = (loc, team) => {
        let o = new Entity(loc),
            teams = ["BLUE", "RED", "GREEN", "PURPLE", "YELLOW", "ORANGE", "PINK", "TEAL"],
            teamColors = ["#00B0E1", "#F04F54", "#00E06C", "#BE7FF5", "#FFEB8E", "#F37C20", "#E85DDF", "#8EFFFB"];
        o.define(Class.mothership);
        o.isMothership = true;
        o.miscIdentifier = "appearOnMinimap";
        o.alwaysActive = true;
        o.team = -team;
        o.controllers.push(new ioTypes.nearestDifferentMaster(o), new ioTypes.mapTargetToGoal(o), new ioTypes.roamWhenIdle(o));
        o.color = [10, 12, 11, 15, 3, 35, 36, 0][team - 1];
        o.nameColor = teamColors[team - 1];
        o.settings.hitsOwnType = "pushOnlyTeam";
        o.name = "Mothership";
        o.onDead = () => {
            room.defeatedTeams.push(o.team);
            sockets.broadcast(teams[team - 1] + "'s Mothership has been killed!", teamColors[team - 1]);
            if (room.motherships.length !== 1) util.remove(room.motherships, room.motherships.indexOf(o));
            entities.forEach(n => {
                if (n.team === o.team && (n.isBot || n.isPlayer)) {
                    n.sendMessage("Your team has been defeated!");
                    n.kill();
                }
            });
            if (room.arenaClosed || room.motherships.length !== 1) return;
            util.warn(teams[-room.motherships[0].team - 1] + " has won the game! Closing arena...");
            setTimeout(() => sockets.broadcast(teams[-room.motherships[0].team - 1] + " has won the game!", teamColors[-room.motherships[0].team - 1]), 2e3);
            setTimeout(() => closeArena(), 5e3);
        };
        room.motherships.push(o);
    };

    let soccer = {
        scoreboard: [0, 0],
        timer: 60,
        spawnBall: function () {
            let o = new Entity({
                x: room.width / 2,
                y: room.height / 2
            });
            o.define(Class.soccerBall);
            o.miscIdentifier = "appearOnMinimap";
            o.settings.noNameplate = true;
            o.settings.acceptsScore = false;
            o.team = -100;
            o.alwaysActive = true;
            o.modeDead = () => {
                let cell = o.myCell.slice(3);
                if (cell == 1) {
                    soccer.scoreboard[1]++;
                    sockets.broadcast("RED Scored!");
                }
                if (cell == 2) {
                    soccer.scoreboard[0]++;
                    sockets.broadcast("BLUE Scored!");
                }
                setTimeout(soccer.spawnBall, 1500);
            }
        },
        update: function () {
            soccer.timer--;
            if (soccer.timer <= 0) {
                if (soccer.scoreboard[0] > soccer.scoreboard[1]) {
                    sockets.broadcast("BLUE has won!");
                    setTimeout(closeArena, 2500);
                    return;
                } else if (soccer.scoreboard[0] < soccer.scoreboard[1]) {
                    sockets.broadcast("RED has won!");
                    setTimeout(closeArena, 2500);
                    return;
                } else {
                    sockets.broadcast("It was a tie!");
                    soccer.timer += 3;
                    setTimeout(() => sockets.broadcast("3 Minutes have been added to the clock!"), 1500);
                }
            }
            if (soccer.timer % 2 === 0) sockets.broadcast(soccer.timer + " minutes until the match is over!");
            setTimeout(soccer.update, 60000);
        },
        init: function () {
            soccer.spawnBall();
            setTimeout(soccer.update, 60000);
        }
    };
    const bossRushLoop = (function () {
        const bosses = [
            //Weak
            Class.eggQueenTier1AI, Class.eggQueenTier2AI,
            Class.AWP_14AI,
            Class.AWP_24AI,
            Class.AWP_cos5AI,
            Class.AWP_11AI,
            Class.AWP_21AI,
            Class.RK_1AI,
            Class.eliteGunnerAI, Class.eliteSprayerAI, Class.eliteTwinAI, Class.eliteMachineAI, Class.eliteTrapAI, Class.arrasEliteTrapGuardAI, Class.arrasEliteSpinnerAI, Class.eliteGoudaAI, Class.eliteStormAI, Class.eliteSpawnerAI, Class.eliteZipperAI, Class.eliteMinglerAI, Class.eliteJalopyAI, Class.eliteTriTrapGuardAI, Class.eliteVolleyAI, Class.eliteQuellerAI, Class.eliteAnnihilatorAI, Class.eliteMegaSpawnerAI, Class.eliteLauncherAI, Class.eliteBaltimoreAI, Class.eliteOctoTankAI, Class.eliteBatteryAI, Class.eliteConquerorAI, Class.eliteRuptureAI, Class.eliteWidgetAI, Class.eliteHangarAI, Class.eliteNecromancerAI, Class.eliteFortressAI, Class.eliteDeathStarAI, Class.eliteOvergunnerAI, Class.elitePeashooterAI, Class.improvedSkimBossAI, Class.eliteMachineGunnerAI, Class.eliteFoundryAI, Class.eliteSubgunnerAI, Class.lemonBossAI,
            Class.eliteBorerAI, Class.eliteSniperAI, Class.eliteBasicAI, Class.eliteInfernoAI, Class.fallenBoosterAI, Class.fallenInvokerAI,
            Class.deltaDestroyerAI, Class.deltaSprayerAI, Class.deltaSprayerAI, Class.deltaBattleshipAI, Class.deltaSpawnerAI, Class.deltaSpinnerAI, Class.deltaTrapGuardAI,
            Class.fallenOverlordAI, Class.fallenPistonAI, Class.fallenAutoTankAI, Class.fallenCavalcadeAI,
            Class.fallenFighterAI, Class.reanimFarmerAI, Class.reanimHeptaTrapAI, Class.reanimUziAI,
            Class.skimBossAI, Class.deltaSkimmerAI, Class.ultMultitoolAI,
            Class.orangicusAI,
            Class.atriumAI,
            Class.armySentrySwarmAI, Class.armySentryGunAI, Class.armySentryTrapAI, Class.armySentryRangerAI,
            Class.alphaSentryAI,
            Class.trapeFighterAI,
            Class.messengerAI,
            Class.aquamarineAI, Class.kioskAI,
            Class.magnetarAI,
            Class.eggBossTier1AI, Class.eggBossTier2AI,
            Class.pulsarAI,Class.quasarAI,
            Class.applicusAI, Class.lemonicusAI, Class.fallenDrifterAI,Class.lavendicusAI, Class.greatWalletAI,
            Class.trifrasAI,
            //Normal
            Class.eggQueenTier3AI,
            Class.AWP_1AI,
            Class.AWP_psAI,
            Class.AWP_8AI,
            Class.eliteRifleAI,
            Class.eliteDestroyerAI,
            Class.palisadeAI,
            Class.leviathanAI,
            Class.nailerAI,
            Class.gravibusAI,
            Class.constructionistAI,
            Class.dropshipAI,
            Class.derogatorAI, Class.hexadecagorAI, Class.blitzkriegAI, Class.demolisherAI, Class.octogeddonAI,
            Class.asteroidAI, Class.asteroidAI, Class.octagronAI,
            Class.visUltimaAI, Class.gunshipAI,
            Class.deltrabladeAI,
            Class.vanguardAI,
            Class.guardianAI, Class.summonerAI, Class.defenderAI,
            Class.conquistadorAI, Class.sassafrasAI, Class.constAI, Class.bowAI,
            Class.greenGuardianAI, Class.lavenderGuardianAI,
            Class.eggSpiritTier1AI, Class.eggSpiritTier2AI,
            Class.s2_22AI, Class.hb3_37AI,
            Class.ultraPuntAI,
            Class.trapDwellerAI,
            Class.astraAI, Class.eliteSidewindAI, Class.swarmSquareAI, Class.vacuoleAI, Class.lamperAI, Class.mk1AI, Class.mk2AI,
            Class.tk1AI,
            Class.sorcererAI,
            Class.enchantressAI,
            Class.RK_2AI,
            Class.rs1AI,Class.rs2AI,
            Class.sliderAI,
            Class.eliteMinesweeperAI,
            Class.ascendedSquare,
            //Pretty Hard          
            Class.hexashipAI,
            Class.cometAI,
            Class.brownCometAI,
            Class.ultimateAI,
            Class.cutterAI,
            Class.colliderAI,
            Class.xyvAI,
            Class.snowflakeAI,
            Class.eggSpiritTier3AI,
            Class.EK_3AI,
            Class.at4_bwAI,
            Class.confidentialAI,
            Class.sacredCrasherAI,
            Class.legendaryCrasherAI,
            Class.iconsagonaAI,
            Class.hexagonBossAI,
            Class.heptagonBossAI,
            Class.vulcanShipAI,
            Class.mk3AI,
            Class.tk2AI,
            Class.tk3AI,/* Class.greendeltrabladeAI, Class.icecolliderAI, Class.neutronStarAI,*/
            Class.icemessengerAI,
            Class.exorcistorAI,
            Class.triguardAI,
            Class.RK_3AI,
            Class.rs3AI,
            Class.bluestarAI,
            Class.splitterSummoner,
            Class.streakAI,
            Class.goldenStreakAI,
            Class.curveplexAI,
            Class.orbitalspaceAI,
            Class.leshyAI,
            Class.leshyAIred,
            Class.ascendedTriangle,
            Class.ascendedPentagonAI,
            Class.AWPOrchestra1AI,
            Class.AWPOrchestra2AI,
            Class.moonShardAAI,
            Class.moonShardBAI,
            Class.awpOrchestratan33AI,
            Class.AWPOrchestra4AI,
            Class.frigateShipAI,
            //customs
            Class.devilishDragonAI,Class.purifierBossAI,Class.sandGhostAI,Class.nestKeeperAI,Class.ultraTwinAI,Class.ultraBorerAI,Class.ultraDestroyerAI,Class.ultraGoudaAI,Class.ultraStormAI,Class.shadowCoreAI,Class.shadowShardAI,Class.ultraSniperAI,Class.ultraTrapAI,Class.fruityFlavorAI,Class.ultraSprayerAI,Class.spiderBossAI,
            Class.satanAI,
            //the pongle bosses
            Class.supremeantimatAI, Class.jolterAI, /*Class.awpomegaAI,*/ Class.cogbossAI, Class.spectrumAI, Class.elitegrudgeAI, Class.awptorusAI, Class.elitelaserAI, Class.meteoroidAI, Class.supersummonistAI, Class.industropolisAI, Class.armoredindustryAI, Class.goldindustryAI, Class.spn1AI, Class.spn2AI, Class.spn3AI, Class.rtk1AI, Class.rtk2AI, Class.rtk3AI, 
            Class.checkboard1AI, Class.checkboard2AI, Class.checkboard3AI, Class.shk1AI, Class.shk2AI, Class.shk3AI,
            //arceus bosses
            Class.sanctumAI, Class.surtAI, Class.yellowGuardianAI,
            //scrappeds (wow)
            Class.awp_nephAI, Class.awp_snipeAI, Class.awp_machineAI,Class.chandelierAI, Class.hexahedronAI,Class.bitskriegAI,Class.fallenHybridAI,Class.fallenOctoAI,Class.article13AI,Class.industrianAI,Class.tetrafrasAI,Class.pentafrasAI,Class.sarfassasAI,Class.hyperionAI,Class.XZ_4_MainAI,Class.triSeekerAI,Class.hexachoronAI,Class.hf61AI,Class.eliteDefenderAI,Class.superbirdAI,Class.overTitanAI,Class.terrorhedronAI,Class.eliteRailgunAI,Class.orthoAI,Class.jetBossAI,Class.testingthingAI,Class.battlegonAI,Class.rod1AI,Class.kingAI,Class.eliteDirectorAI,Class.carbonfrasAI,Class.eliteXyvAI,Class.heptazoidAI,Class.elitePelleterAI,
            Class.beggarsBaneAI,Class.awpPoundAI,Class.eliteEngieAI,Class.gegenscheinAI,Class.thunderstormAI,Class.fallenDirigibleAI,Class.eliteCarpenterAI,Class.fuckahedronAI,Class.subjectorAI,Class.keeperAI,Class.vivisectionAI,Class.bigRedBossAI,Class.eliteShrapnelAI,Class.leaferBossAI,Class.greenGearBossAI,Class.eliteDustbowlAI,Class.serpentTestAI,Class.AWP_6AI,Class.AWP_7AI,Class.AWP_12AI,Class.pentagonBossTier1AI,Class.pentagonBossTier2AI,Class.pentagonBossTier3AI,Class.hexagonBossTier1AI,Class.hexagonBossTier2AI,Class.hexagonBossTier3AI,Class.heptagonBossTier1AI,Class.heptagonBossTier2AI,Class.heptagonBossTier3AI,Class.obp1AI,
            Class.obp2AI,Class.obp3AI,Class.obt1AI,Class.chk1AI,Class.chk2AI,Class.chk3AI,Class.greenBossTier1AI,Class.greenBossTier2AI,Class.greenBossTier3AI,Class.nk1AI,Class.nk2AI,Class.nk3AI,Class.ultraGunnerAI,Class.ultraEngieAI,Class.ultraBasicAI,Class.ultraMachineAI,Class.tridrillAI,Class.irisBossAI,Class.desecratorAI,Class.AWP_4AI,Class.AWP_8_altAI,Class.AWP_5AI,Class.ship36AI,Class.ultraSkimAI,Class.awp17AI,/*Class.awp846AI,*/Class.awpspawnerAI,/*Class.awp59AI,*/Class.awp61AI,Class.awp73pi9AI,/*Class.awpsqrt50AI,Class.awp56AI,*/Class.hypervesselAI,Class.nonationAI,Class.awp2p112AI,/*Class.awp135AI,Class.awp404AI,Class.awporchestrasinAI,*//*Class.awpccAI,*/
            Class.awppolyleader,/*Class.awp3AI,*/Class.awpTurtAI,Class.awp19AI,/*Class["awp(5/3)AI"],Class.awphouserAI,*/Class.ultraCannonAI,Class.cranberryGuardianAI,Class.hendecahedronAI,
            //Red base entities :p
            Class.fallenStreamlinerAI/*, Class.fallenAnnihilatorAI*/, Class.reanimCartographerAI, Class.cryogenAI,
            //Red Other
            Class.peaceKeeperAI, // 1st Bosses
            Class.toxicDefenderAI, Class.lunarEclipseAI, Class.scutiSummonerAI, // 2nd Bosses
            Class.shinyGuardianAI, Class.ascendedEK1AI, Class.ascendedSummonerAI, Class.ascendedDefenderAI, Class.enragedAscendedDefenderAI, Class.ascendedLeviathanAI, Class.ascendedGuardianAI,//, Class.ascendedNestKeeperAI, // Ascended & Mutated Bosses
            Class.eliteRedistributorAI, Class.eliteIncognitoAI,  // Elites
            Class.shamanAI, Class.triplaneAI, Class.defenderceptionAI, Class.ussrBossAI, Class.virusBossAI, Class.imperatorAI, Class.eliteTroisAI, Class.heptabasitraAI, // Boss Siege Serie
            Class.fallenDragonAI, Class.radiosourceAI, Class.volcanicMultitoolAI, Class.jigsawAI, Class.spectreAI, // Arms Race Squad 
            Class.abysslingAI,  Class.bobAI,Class.fallenParalyserAI, // Last but not least
            Class.milleniumFalconAI,Class.chessboardBossAI,Class.ell2AI,
            //ok
            Class.trapperzoidAI,Class.reanimBiohazardAI,Class.mladicAI,Class.goldenMladicAI,Class.ascendedSplitterSquare,Class.orangeGuardianAI,Class.ell0AI,Class.ell1AI,Class.quadMessengerAI,Class.shieldGuardianAI,Class.eliteChargerAI,defExports.viewerAI,defExports.AWP_9AI,defExports.defender2AI,
            // rare cases where Misfit makes a boss
            Class.vantablackGuardianAI, Class.chromaAI, Class.violetSliderAI, Class.authorityAI, Class.safeZoneAI, Class.swarmingCube, Class.corridorBoss,
            Class.tangariusAI
            //1234567890 (CTRL + F)
        ].filter(o => o != null);
        const waveAss = {
            15: [
                Class.greendeltrabladeAI, Class.ESHG_85_MainAI, Class.icecolliderAI, defExports.eliteShrapnelMK2AI, Class.neutronStarAI, Class.moonCoreAI, Class.rogueMothershipAI
            ],
            25: [
                Class.lucrehulkAI, Class.lucrehulkCarrierAI, Class.lucrehulkBattleshipAI, Class.eggBossTier4AI,
                Class.eggSpiritTier4AI, Class.eggQueenTier4AI, Class.nk4AI, Class.heptahedronAI, Class.LQMAI, Class.RK_4AI, Class.spn4AI, 
                Class.destroyerShipAI, Class.mk4AI, Class.tk4AI, Class.superSplitterSummoner, Class.HAWP_11AI,
                Class.odinAI, Class.athenaAI, Class.caelusAI, Class.demeterAI, Class.hermesAI, Class.shk4AI, Class.awp129AI, Class.pentagonBossTier4AI, Class.rtk4AI, Class.hexagonBossTier4AI, Class.AWPOrchestra3AI,
                //mine
                Class.awp_33AI,Class.hollowCenterAI,Class.PCUAI,Class.awpsqrt3AI,Class.cometbetterAI,Class.ultimatebetterAI,Class.awptorusbetterAI,Class.elitebasicbetterAI,Class.soulless1AI,Class.legionaryCrasherAI,
                Class.awpOrchestraPiAI,
            ],
            30: [
                Class.minosAI, Class.sisyphusAI, Class.bidenAI, Class.grudgeAIWeaker, Class.redistributionAI, Class.stabilizationAI,/*mine*/Class.awp39AI,Class.oppressorAI,
                Class.reanimWitherAI, Class.historyGod,
                Class.eggDecimatorAI,Class.triDecimatorAI,Class.squareDecimatorAI, Class.pentaguardianAI, Class.pictorisAI
            ],
            50: [
                Class.boreasAI, Class.worldDestroyerAIWeaker, Class.mythicalCrasherAIWeaker, Class.sassafrasSupremeAIWeaker,
                Class.tetraplexAIWeaker, Class.squarefortAI, Class.voidPentagonAIWeaker, Class.clockAIWeaker, Class.RK_5AI, Class.nk5AI,
                Class.rs4AIWeaker, Class.supremeSidewinderAI,
                Class.elitePrimeAI, Class.rSassSupremeAI, Class.awpOrchestra5AI, Class.dozenAI, Class.quintetAI,
                //mine
                Class.heliosAI, Class.colossusBossAI, Class.awp66AI, Class.awpimnotwritingthatAI
            ],
            65: [
                Class.eveningstarAI, Class.morningstarAI, Class.awp_trapAI, Class.awp_droneAI, Class.mk5AI, Class.tk5AI
            ],
        };
        for (const key in waveAss) {
            waveAss[key] = waveAss[key].filter(o => o != null);
        }
        const waveOverrides = {
            10: [
                [2, [Class.treasuryAI, Class.fueronAI, Class.morningstarAI]],
                [2, [Class.clockAI, Class.voidPentagonAI, Class.rs4AI, Class.grudgeAI]]
            ],
            20: [
                [10, [Class.ascendedEK1AI, Class.ascendedSummonerAI, Class.ascendedDefenderAI, Class.ascendedLeviathanAI]]
            ],
            30: [
                [2, [Class.mythicalCrasherAI, Class.sassafrasSupremeAI]],
                Class.ussrBossAI, Class.infmultitoolAI
            ],
            40: [
                [2, [Class.tetraplexAI, Class.worldDestroyer, Class.eggBossTier5AI]],
                //Class.orangeGuardianAI
            ],
            50: [
                [Class.moonAI, Class.es5AI,Class.omegasupergunnerAI],
                [5, Class.virusBossAI]
            ],
            60: [
                [2, [Class.legacyACAI, Class.PDKAI,Class.octorturerAI]],
                [4, Class.abysslingAI]
            ],
            /// THE GAUNTLET ///
            70: [
                [3, [Class.sunkingAI, Class.awp30AI]],
                Class.triplaneAI,
                Class.elitePrimeAI
            ],
            71: [
                [Class.eggBossTier5AI, Class.boreasAI],
                [Class.eggBossTier5AI, Class.boreasAI],
                [Class.cometAI, Class.ascendedGuardianAI],
                Class.cometAI,
                [Class.splitterSummoner, Class.fueronAI, Class.treasuryAI],
                [7, [Class.armySentryGunAI, Class.armySentryRangerAI, Class.armySentrySwarmAI, Class.armySentryTrapAI]]
            ],
            72: [
                [Class.RK_5AI, Class.awp30AI, Class.sunkingAI],
                [Class.worldDestroyer, Class.tetraplexAI],
                [Class.legendaryCrasherAI, Class.clockAI],
                [Class.sacredCrasherAI, Class.confidentialAI],
                Class.neutronStarAI,
                [Class.eggQueenTier4AI, Class.eggBossTier4AI, Class.eggSpiritTier4AI],
                [7, [Class.armySentryGunAI, Class.armySentryRangerAI, Class.armySentrySwarmAI, Class.armySentryTrapAI]]
            ],
            73: [
                [Class.triguardAI, Class.triguardAI, Class.quintetAI],
                [Class.lucrehulkCarrierAI, Class.lucrehulkBattleshipAI, Class.lucrehulkAI],
                Class.triguardAI,
                Class.shamanAI,
                [Class.cranberryGuardianAI, Class.greenGuardianAI, Class.lavenderGuardianAI, Class.s2_22AI, Class.at4_bwAI],
                [5, Class.polyamorousAI],
                [4, [Class.armySentryGunAI, Class.armySentryRangerAI, Class.armySentrySwarmAI, Class.armySentryTrapAI]]
            ],
            74: [
                [Class.torchmorningstarAI, Class.PDKAI],
                [Class.quintetAI, Class.triguardAI, Class.pentaguardianAI],
                [2, [Class.minosAI, Class.sisyphusAI, Class.bidenAI]],
                [Class.AWP_28AI, Class.AWP_1AI, Class.AWP_psAI],
                [Class.mk5AI, Class.tk5AI, Class.eggBossTier5AI],
                [Class.frigateShipAI, Class.destroyerShipAI],
                [Class.mythicalCrasherAI, Class.sassafrasSupremeAI, Class.voidPentagonAI],
                [Class.RK_4AI, Class.tk4AI, Class.mk4AI],
                [Class.polyamorousAI, Class.quintetAI],
                Class.dozenAI,
                [Class.squarefortAI, Class.heptahedronAI, Class.RK_3AI]
            ],
            75: [
                Class.fallenDragonAI, Class.radiosourceAI, Class.volcanicMultitoolAI, Class.jigsawAI, Class.eveningstarAI, Class.spectreAI, Class.legionaryCrasherAI
            ],
            80: [
              [3, [Class.supremeMTSOAI,Class.eggBossTier6AI,Class.voidPentadoomerAI,Class.omegaCrusherAI]]
            ],
            85: [
                Class.supremeEternal,Class.fallenDragonAI, Class.awp_trapAI, Class.volcanicMultitoolAI, Class.awpCarpetBomberAI, Class.eveningstarAI, Class.spectreAI, Class.legionaryCrasherAI,
                [15, Class.bobAI],
                Class.shamwowAI
            ],
            90: [Class.ship23AI, Class.bigVoidPentaAI,Class.dozenAI, Class.missilusAI, Class.cometbettererAI,],
            95: [
                Class.supremeChaosMakerAI,
                Class.imperatorAI,
                [3, Class.abysslingAI],
                Class.swarmistAI,
                Class.milleniumFalconAI
            ],
            100: [
                Class.elitePrimeAI,
                Class.abyssGuardianAI,
                Class.shamwowAI
            ],
            105: [
                  [Class.awp_minionAI,
                  Class.awpawpAI,
                  Class.awp5e777AI]
            ],
            110: [[2, [Class.awpaleph1AI, Class.abyssGuardianAI]]]
        }
        for (let i = 0; i < bosses.length; i++) {
            if (bosses[i] != null) continue;
            console.warn(`[WARN] Boss at index "${i}" was null.`);
            bosses.splice(i, 1);
        }
        let bossesAlive;
        function entityModeDead() {
            bossesAlive--;
            if (bossesAlive <= 0) {
                if (room.bossRushWave === 250) {
                    sockets.broadcast("The tanks have beaten the boss rush!");
                    players.forEach(player => player.body != null && player.body.rewardManager(-1, "victory_of_the_4th_war"));
                    setTimeout(closeArena, 2500);
                } else {
                    sockets.broadcast("The next wave will arrive in 10 seconds!");
                    setTimeout(bossRushLoop, 10000);
                }
            } else {
                sockets.broadcast(`${bossesAlive} Boss${bossesAlive > 1 ? "es" : ""} left!`);
            }
        };
        function spawnBoss(class_) {
            const o = new Entity(room.randomType("myboss"));//boss
            //let infenumCoefffffff = room.infernumCoef
            //room.infernumCoef == null ? o.isAdvancedBoss = Math.random() + (room.bossRushWave / 400) : o.isAdvancedBoss = (Math.random() + (room.bossRushWave / 400)) + room.infernumCoef
            o.isAdvancedBoss = Math.random() + (room.bossRushWave / 400)
            if (room.bossRushWave % 5 == 0) {o.isAdvancedBoss = 0}
            //if(room.infernumCoef != null) {o.isAdvancedBoss += room.infernumCoef}
            //o.isAdvancedBoss += room.infernumCoef
            o.team = -100;
            o.define(class_);
            o.modeDead = entityModeDead;
            if (c.SMODE == "Attack" && room.bossRushWave != 10 && room.bossRushWave != 20 && room.bossRushWave != 30 && room.bossRushWave != 40 && room.bossRushWave != 50 && room.bossRushWave != 60 && room.bossRushWave != 70 && room.bossRushWave != 71 && room.bossRushWave != 72 && room.bossRushWave != 73 && room.bossRushWave != 74 && room.bossRushWave != 75 && room.bossRushWave != 80 && room.bossRushWave != 85 && room.bossRushWave != 90 && room.bossRushWave != 95 && room.bossRushWave != 100 && room.bossRushWave != 105 && room.bossRushWave != 110 && room.bossRushWave != 115 && room.bossRushWave != 120) {
                o.randomInt = Math.random()
                if (o.randomInt > 0.7 - (1/240 /*120 / 2 120 = max waves*/* room.bossRushWave)) {
                    o.controllers = []
                    o.randomInt = Math.floor(4 * Math.random() + 1)//no way thisdoes 5 right?
                    switch(o.randomInt) {
                    case 1:
                        o.define(Class.nemesisRight)
                        sockets.broadcast("A Visitor Has Spawned In The Right Lane!","red")
                    break;
                    case 2:
                        o.define(Class.nemesisTop)
                        sockets.broadcast("A Visitor Has Spawned In The Top Lane!","red")
                    break;
                    case 3:
                        o.define(Class.nemesisBottom)
                        sockets.broadcast("A Visitor Has Spawned In The Bottom Lane!","red")
                    break;
                    case 4:
                        o.define(Class.nemesisLeft)
                        sockets.broadcast("A Visitor Has Spawned In The Left Lane!","red")
                    break;
                    default:
                        //well done you can continue your life lil lucky boss that did 5 at the roll
                        break;
                    }
                }
            }
            if (o.isAdvancedBoss > 0.98 - room.infernumCoef) {
                o.dice = Math.random()// + room.infernumCoef + (room.bossRushWave / 800)
      if (o.dice < 0.4) {
                o.label = "Superior " + o.label
                o.color = 31
                o.HEALTH = o.HEALTH * 1.25//1.5
                o.SHIELD = o.SHIELD * 1.1
                o.SIZE = Math.min(o.SIZE * 1.2, 150)
                o.SPEED = o.SPEED * 1.05//1.2
                o.DAMAGE = o.DAMAGE * 1.05//1.1
                o.ACCELERATION = o.ACCELERATION * 1//1.2
                o.skill.score = o.skill.score * 2
                /*if (!o.label.includes('Nemesis')) {
                    setTimeout(() => {
                    if (o.isAlive()) {
                        let x = o.x,
                            y = o.y;
                        setTimeout(() => {
                            let boss1 = new Entity({
                                x: x + 600,//o.SIZE * 3
                                y: y
                            });
                            boss1.team = o.team;
                            boss1.define(class_);
                            let boss2 = new Entity({
                                x: x - 600,
                                y: y
                            });
                            boss2.team = o.team;
                            boss2.define(class_);
                        }, 100);
                    }
                }, 100);
            }*/
                o.refreshBodyAttributes()
                o.reloadCoef = 0.9
                o.skill.spd = o.skill.spd * 1.1//1.4
                o.skill.dam = o.skill.dam * 1.2//1.7
                //o.skill.hlt 
                o.skill.atk *= 1.1//1.2
                o.refreshFOV()
                sockets.broadcast("A " + o.label + " has awoken...","#51ff5e")
    } else if (o.dice >= 0.4 && o.dice < 0.7) {
                o.label = "Advanced " + o.label
                o.color = 100
                o.HEALTH = o.HEALTH * 1.45//2
                o.SHIELD = o.SHIELD * 1.25//1.5
                o.SIZE = Math.min(o.SIZE * 3.3, 200)
                o.SPEED = o.SPEED * 1.1//1.5
                o.DAMAGE = o.DAMAGE * 1.075//1.25
                o.ACCELERATION = o.ACCELERATION * 1.1//1.5
                o.skill.score = o.skill.score * 2.5
                if (!o.label.includes('Nemesis')) {
                    setTimeout(() => {
                    if (o.isAlive()) {
                        let x = o.x,
                            y = o.y;
                        setTimeout(() => {
                            let boss1 = new Entity({
                                x: x + 600,//o.SIZE * 3
                                y: y
                            });
                            boss1.team = o.team;
                            boss1.define(class_);
                            let boss2 = new Entity({
                                x: x - 600,
                                y: y
                            });
                            boss2.team = o.team;
                            boss2.define(class_);
                            /*let boss3 = new Entity({
                                x: x,
                                y: y + 600
                            });
                            boss3.team = o.team;
                            boss3.define(class_);
                            let boss4 = new Entity({
                                x: x,
                                y: y - 600
                            });
                            boss4.team = o.team;
                            boss4.define(class_);*/
                            o.onDead = () => {
                            boss1.kill()
                            boss2.kill()
                            }
                        }, 100);
                    }
                }, 100);
            }
                o.refreshBodyAttributes()
                o.reloadCoef = 0.825//0.75
                o.skill.spd = o.skill.spd * 1.2//1.4
                o.skill.dam = o.skill.dam * 1.2//2.3
                o.skill.atk *= 1.2//1.5
                o.refreshFOV()
                sockets.broadcast("An " + o.label + " has awoken...","#ff5151")
              
    } else if (o.dice >= 0.7 && o.dice < 0.9) {
                o.label = "Shadowed " + o.label
                o.color = 217
                o.HEALTH = o.HEALTH * 1.75//3.85
                o.SHIELD = o.SHIELD * 1.5//2
                o.SIZE = Math.min(o.SIZE * 4.1, 300)
                o.SPEED = o.SPEED * 1.6
                o.DAMAGE = o.DAMAGE * 1.15//1.5
                o.ACCELERATION = o.ACCELERATION * 1.7
                o.skill.score = o.skill.score * 5
                o.refreshBodyAttributes()
                o.alpha = 0.05
                o.reloadCoef = 0.65//0.5
                o.skill.spd = o.skill.spd * 1.6
                o.skill.dam = o.skill.dam * 1.3//3
                //o.skill.hlt 
                o.skill.atk *= 1.5
                o.refreshFOV()
                sockets.broadcast("An " + o.label + " has awoken...","#a5feff")
              } else {
                o.label = "Ultimate " + o.label
                o.color = 243
                o.HEALTH = o.HEALTH * 3//5
                o.SHIELD = o.SHIELD * 2//5
                o.SIZE = Math.min(o.SIZE * 5, 350) // too big else
                o.SPEED = o.SPEED * 1.2//2
                o.DAMAGE = o.DAMAGE * 1.2//2
                o.ACCELERATION = o.ACCELERATION * 1.2//2
                o.skill.score = o.skill.score * 12
                if (!o.label.includes('Nemesis')) {
                    setTimeout(() => {
                    if (o.isAlive()) {
                        let x = o.x,
                            y = o.y;
                        setTimeout(() => {
                            let boss1 = new Entity({
                                x: x + 600,//o.SIZE * 3
                                y: y
                            });
                            boss1.team = o.team;
                            boss1.define(class_);
                            let boss2 = new Entity({
                                x: x - 600,
                                y: y
                            });
                            boss2.team = o.team;
                            boss2.define(class_);
                            let boss3 = new Entity({
                                x: x,
                                y: y + 600
                            });
                            boss3.team = o.team;
                            boss3.define(class_);
                            let boss4 = new Entity({
                                x: x,
                                y: y - 600
                            });
                            boss4.team = o.team;
                            boss4.define(class_);
                            /*let boss5 = new Entity({
                                x: x + 600,
                                y: y - 600
                            });
                            boss5.team = o.team;
                            boss5.define(class_);
                            let boss6 = new Entity({
                                x: x + 600,
                                y: y + 600
                            });
                            boss6.team = o.team;
                            boss6.define(class_);
                            let boss7 = new Entity({
                                x: x - 600,
                                y: y - 600
                            });
                            boss7.team = o.team;
                            boss7.define(class_);
                            let boss8 = new Entity({
                                x: x - 600,
                                y: y + 600
                            });
                            boss8.team = o.team;
                            boss8.define(class_);*/
                            o.onDead = () => {
                              boss1.kill()
                              boss2.kill()
                              boss3.kill()
                              boss4.kill()
                              /*boss5.kill()
                              boss6.kill()
                              boss7.kill()
                              boss8.kill()*/
                            }
                        }, 100);
                    }
                }, 100);
            }
                o.refreshBodyAttributes()
                o.reloadCoef = 0.5//0.25
                o.skill.spd = o.skill.spd * 1.5//1.8
                o.skill.dam = o.skill.dam * 1.5//3.35
                //o.skill.hlt 
                o.skill.atk *= 1.5
                o.refreshFOV()
                sockets.broadcast("An " + o.label + " has awoken...","rainbow")
              }
            }
            bossesAlive++;
        }
        return function () {
            room.bossRushWave++;
            let amount = c.MAXBOSSES ? (Math.round(Math.random() * (c.MAXBOSSES - c.MINBOSSES) + c.MINBOSSES)) : (c.SMODE == "Attack" ? Math.round(Math.random() * 3 + (2 + (0.02 * room.bossRushWave))) : Math.round(Math.random() * 10 + 15 /*20 + 20*/))/* * 8 + 4*/
            switch (room.bossRushWave) {
                case 10:
                case 20:
                case 30:
                case 40:
                case 50:
                case 60:
                case 70:
                case 75:
                    amount = 1;//1
                    break;
                case 71:
                case 72:
                case 73:
                case 74:
                    amount = 12;
                    break;
            }
            bossesAlive = 0;
            room.hasdonethewavebroadcast = false//mine
            sockets.broadcast(`Wave ${room.bossRushWave} has arrived!`);
            if (waveAss[room.bossRushWave] != null) {
                const assertion = waveAss[room.bossRushWave];
                for (let i = 0; i < assertion.length; i++) {
                    bosses.push(assertion[i]);
                }
            }
            bosses.sort(() => 0.5 - Math.random());
            if (waveOverrides[room.bossRushWave] == null) {
                for (let i = 0; i < amount; i++) {
                    spawnBoss(bosses[i % bosses.length]);
                }
            } else {
                const override = waveOverrides[room.bossRushWave];
                for (let i = 0; i < override.length; i++) {
                    const entry = override[i];
                    if (Array.isArray(entry)) {
                        if (typeof entry[0] === "number") {
                            for (let j = 0; j < entry[0]; j++) {
                                if (Array.isArray(entry[1])) {
                                    spawnBoss(ran.choose(entry[1]));
                                } else {
                                    spawnBoss(entry[1]);
                                }
                            }
                        } else {
                            spawnBoss(ran.choose(entry));
                        }
                    } else {
                        spawnBoss(entry);
                    }
                }
            }
            sockets.broadcast(`${bossesAlive} Boss${bossesAlive > 1 ? "es" : ""} to kill!`);
        }
    })();
    const shatteredBeyond = (function() {
        const raffinedLength = 20
        for (let i = 0; i < raffinedLength/1.75; i++) {
            for (let j = 0; j < raffinedLength; j++) {
            let o = new Entity({
                x: room.width/raffinedLength * i * 1.75 + (room.width/raffinedLength/2),
                y: room.height/raffinedLength * j + (room.height/raffinedLength/2)
            })
            o.define(Class.mazeObstacle)
            o.randomThing = Math.random()
            if (o.randomThing < 0.2) {
              o.define(Class.creepyObstacle)
            }
            if (o.randomThing < 0.05) {
              o.define(Class.creepierObstacle)
            }
            o.color = 34
            o.SIZE = 305
            o.onCollide = (me, them) => {
              if ((them.isPlayer && them.invuln) || them.gotSpawned == true) {
                them.x = room.width * Math.random()
                them.y = room.height * Math.random()
              }
            }
            if (o.randomThing > 0.8) {o.kill()}//20% chance to insta die
        }}
    })
    const voidwalkers = (function () {
        // MAP SET UP //
        const doors = [];
        let buttons = [];
        function makeDoor(loc, team = -101) {
            const door = new Entity(loc);
            door.define(Class.mazeObstacle);
            door.team = team;
            door.SIZE = (room.width / room.xgrid) / 2;
            door.protect();
            door.life();
            door.color = 45;
            doors.push(door);
            const doorID = doors.indexOf(door);
            door.onDead = function () {
                for (const button of buttons) {
                    if (button.doorID === doorID) {
                        button.ignoreButtonKill = 2;
                        button.kill();
                    }
                }
            }
        }
        function makeButton(loc, open, doorID) {
            const button = new Entity(loc);
            button.define(Class.button);
            button.pushability = button.PUSHABILITY = 0;
            button.team = -101;
            button.doorID = doorID;
            button.color = (open ? 12 : 11);
            button.onDead = function () {
                buttons = buttons.filter(instance => instance.id !== button.id);
                if (!button.ignoreButtonKill) {
                    const door = doors[button.doorID];
                    if (open) {
                        door.alpha = 0.2;
                        door.passive = true;
                        if (door.isAlive() && door.alpha === .2 && door.passive) {
                            let toKill = buttons.find(newButton => newButton.doorID === button.doorID);
                            if (toKill) {
                                toKill.kill();
                            }
                        }
                    } else {
                        door.alpha = 1;
                        door.passive = false;
                    }
                    for (const other of buttons) {
                        if (button !== other && button.doorID === other.doorID) {
                            other.ignoreButtonKill = true;
                            other.kill();
                        }
                    }
                }
                if (button.ignoreButtonKill !== 2) {
                    setTimeout(() => {
                        makeButton(loc, !open, doorID);
                    }, 2500)
                }
            }
            buttons.push(button);
        }
        function makeButtons() {
            buttonLocs = [
            ]
            let i = 0;
            for (const loc of room.door) {
                makeDoor(loc);
                switch (i++) {
                    case 0:
                        buttonLocs.push({
                            x: loc.x,
                            y: loc.y + (room.height / room.ygrid) / 1.5
                        })
                        break;
                    case 1:
                        buttonLocs.push({
                            x: loc.x + (room.width / room.xgrid) / 1.5,
                            y: loc.y
                        })
                        break;
                    case 2:
                        buttonLocs.push({
                            x: loc.x - (room.width / room.xgrid) / 1.5,
                            y: loc.y
                        })
                        break;
                    case 3:
                        buttonLocs.push({
                            x: loc.x,
                            y: loc.y - (room.height / room.ygrid) / 1.5
                        })
                        break;
                }
            }
            i = 0
            for (const loc of buttonLocs) {
                makeButton(loc, 1, i++);
            }
        }
        makeButtons();
        function spawnDominator(location, team, type) {
            const o = new Entity(location);
            o.define(Class[type]);
            o.team = team;
            o.color = getTeamColor(team);
            o.name = "Outpost Guardian";
            o.isDominator = true;
            o.alwaysActive = true;
            o.settings.hitsOwnType = "pushOnlyTeam";
            o.FOV = .5;
        }
        spawnDominator(room["domm"][0], -1, "outpostGuardian");

        // DIFFICULTY INCREASING LOOP //
        setInterval(() => {
            for (let player of players) {
                // Setup any new players
                if (!player.body || (player.body && !player.body.isAlive())) {
                    if (player.vw.crasherArray) {
                        while (player.vw.crasherArray.length) {
                            player.vw.crasherArray.shift().destroy()
                        }
                    }
                    if (player.vw.sentryArray) {
                        while (player.vw.sentryArray.length) {
                            player.vw.sentryArray.shift().destroy()
                        }
                    }
                    if (player.vw.bossArray) {
                        while (player.vw.bossArray.length) {
                            player.vw.bossArray.shift().destroy()
                        }
                    }
                    continue
                }
                if (!player.vw) {
                    player.vw = {
                        crasherArray: [],
                        sentryArray: [],
                        bossArray: [],
                    }
                    player.body.skill.level = 60
                    player.body.skill.points = 42
                    player.body.refreshBodyAttributes()
                }
                player.body.scoped = false
                player.body.settings.leaderboardable = true

                // Adjust caps based on difficulty
                player.body.skill.score = player.vw.distanceFromOutpost = util.getDistance(player.body, room["domm"][0])
                player.vw.difficulty = Math.min(1, player.vw.distanceFromOutpost / 75_000) // 100000 being the farthest till difficulty stays the same
                player.vw.crasherAmount = Math.round(185 * player.vw.difficulty)
                player.vw.sentryAmount = Math.round(26 * player.vw.difficulty)
                player.vw.bossAmount = Math.round(5 * player.vw.difficulty)

                // Adjust enemies based on the caps
                // CRASHERS //
                for (let i = 0; i < player.vw.crasherArray.length; i++) {
                    let crasher = player.vw.crasherArray[i]
                    if (util.getDistance(player.body, crasher) > 2000) {
                        player.vw.crasherArray.splice(i, 1)
                        crasher.destroy()
                    }
                }
                while (player.vw.crasherArray.length > player.vw.crasherAmount) {
                    let crasher = player.vw.crasherArray.shift()
                    crasher.destroy()
                }
                let crasherList = getCrasherList(player.vw.difficulty)
                while (player.vw.crasherArray.length < player.vw.crasherAmount) {
                    if (!crasherList.length) {
                        break;
                    }
                    let crasher = summonCrasher(player, crasherList)
                    //targetableEntities.push(crasher)
                    player.vw.crasherArray.push(crasher)
                }

                // SENTERIES //
                for (let i = 0; i < player.vw.sentryArray.length; i++) {
                    let sentry = player.vw.sentryArray[i]
                    if (util.getDistance(player.body, sentry) > 2000) {
                        player.vw.sentryArray.splice(i, 1)
                        sentry.destroy()
                    }
                }
                while (player.vw.sentryArray.length > player.vw.sentryAmount) {
                    let sentry = player.vw.sentryArray.shift()
                    sentry.destroy()
                }
                let sentryList = getSentryList(player.vw.difficulty)
                while (player.vw.sentryArray.length < player.vw.sentryAmount) {
                    if (!sentryList.length) {
                        break;
                    }
                    let sentry = summonSentry(player, sentryList)
                    //targetableEntities.push(sentry)
                    player.vw.sentryArray.push(sentry)
                }

                // BOSSES // 
                for (let i = 0; i < player.vw.bossArray.length; i++) {
                    let boss = player.vw.bossArray[i]
                    if (util.getDistance(player.body, boss) > 2000) {
                        player.vw.bossArray.splice(i, 1)
                        boss.destroy()
                    }
                }
                while (player.vw.bossArray.length > player.vw.bossAmount) {
                    let boss = player.vw.bossArray.shift()
                    boss.destroy()
                }
                let bossList = getBossList(player.vw.difficulty)
                while (player.vw.bossArray.length < player.vw.bossAmount) {
                    if (!bossList.length) {
                        break;
                    }
                    let boss = summonBoss(player, bossList)
                    //targetableEntities.push(boss)
                    player.vw.bossArray.push(boss)
                }
            }
        }, 1000)

        // DIFFICULTY INCREASING LOOP FUNCTIONS //
        const buffer = 1000 + ran.randomRange(-100, 100)
        let crasherDifficultyList = {
            "0.01": [
                "crasher",
                "longCrasher",
                "invisoCrasher",
                "minesweepCrasher",
                "walletCrasher"
            ],
            "0.05": [
                "bladeCrasher",
                "semiCrushCrasher",
                "semiCrushCrasher0",
                "semiCrushCrasher14",
                "semiCrushCrasher217",
                "fastCrasher"
            ],
            "0.15": [
                "redRunner1",
                "curvyBoy",
                "poisonBlades",
                "spikedRunner",
                "greenRunner"
            ],
            "0.20": [
                "visDestructia",
                "destroyCrasher",
                "kamikazeCrasher",
                "orbitcrasher",
                "busterCrasher",
                "crushCrasher",
                "trircle",
                "terminatorCrasher",
                "swellFlasher"
            ],
            "0.25": [
                "iceCrusher",
                "torchKamikaze",
                "redRunner2"
            ],
            "0.3": [
                "megaCrushCrasher",
                "prismarineCrash",
                "shrivelFlasher"
            ],
            "0.4": [
                "boomCrasher",
                "asteroidCrasher",
                "morpher"
            ],
            "0.45": [
                "blueRunner",
                "guy",
                "purpleRunner",
            ],
            "0.5": [
                "redRunner3",
                "redRunner4",
                "wallerCrasher"
            ]
        }
        function getCrasherList(diff) {
            let list = []
            for (let val in crasherDifficultyList) {
                if (Number(val) > diff) {
                    return list
                }
                list = list.concat(crasherDifficultyList[val])
            }
            return list
        }
        function summonCrasher(player, crasherList) {
            const angle = Math.PI * 2 * Math.random();
            let spawnPos = {
                x: player.body.x + Math.cos(angle) * buffer,
                y: player.body.y + Math.sin(angle) * buffer
            }
            let crasher = new Entity(spawnPos)
            let type = ran.choose(crasherList)
            crasher.define(Class[type])
            crasher.team = -2
            if (ran.chance(0.5)) {
                crasher.seeInvisible = true
            }
            crasher.settings.leaderboardable = false
            return crasher
        }

        let sentryDifficultyList = {
            "0.05": [
                "sentrySwarmAI",
                "sentryTrapAI",
            ],
            "0.15": [
                "sentryGunAI",
                "sentryRangerAI",
            ],
            "0.20": [
                "flashSentryAI",
                "semiCrushSentryAI",
                "scorcherSentryAI"
            ],
            "0.25": [
                "crushSentryAI",
                "bladeSentryAI",
                "skimSentryAI",
            ],
            "0.40": [
                "squareSwarmerAI",
            ],
            "0.45": [
                "summonerLiteAI",
            ],
            "0.50": [
                "squareGunSentry",
                "crusaderCrash",
                "kamikazeCrasherLite",
            ],
            "0.55": [
                "greenSentrySwarmAI",
            ],
            "0.65": [
                "awp39SentryAI",
                "varpAI"
            ],
            "0.7": [
                "flashGunnerAI"
            ]
        }
        function getSentryList(diff) {
            let list = []
            for (let val in sentryDifficultyList) {
                if (Number(val) > diff) {
                    return list
                }
                list = list.concat(sentryDifficultyList[val])
            }
            return list
        }
        function summonSentry(player, sentryList) {
            const angle = Math.PI * 2 * Math.random();
            let spawnPos = {
                x: player.body.x + Math.cos(angle) * buffer,
                y: player.body.y + Math.sin(angle) * buffer
            }
            let sentry = new Entity(spawnPos)
            let type = ran.choose(sentryList)
            sentry.define(Class[type])
            sentry.team = -2
            if (ran.chance(0.75)) {
                sentry.seeInvisible = true
            }
            sentry.settings.leaderboardable = false
            return sentry
        }

        let bossDifficultyList = {
            "0.3": [
                "trapperzoidAI",
                "sliderAI",
                "deltrabladeAI"
            ],
            "0.4": [
                "trapeFighterAI",
                "messengerAI",
                "violetSliderAI",
            ],
            "0.5": [
                "pulsarAI",
                "gunshipAI",
            ],
            "0.6": [
                "visUltimaAI",
                "colliderAI",
            ],
            "0.7": [
                "alphaSentryAI",
                "constructionistAI"
            ],
            "0.8": [
                "vanguardAI",
                "magnetarAI"
            ],
            "0.9": [
                "kioskAI",
                "aquamarineAI"
            ],
            "0.99": [
                "blitzkriegAI"
            ],
        }
        function getBossList(diff) {
            let list = []
            for (let val in bossDifficultyList) {
                if (Number(val) > diff) {
                    return list
                }
                list = list.concat(bossDifficultyList[val])
            }
            return list
        }
        function summonBoss(player, bossList) {
            const angle = Math.PI * 2 * Math.random();
            let spawnPos = {
                x: player.body.x + Math.cos(angle) * buffer,
                y: player.body.y + Math.sin(angle) * buffer
            }
            let boss = new Entity(spawnPos)
            let type = ran.choose(bossList)
            boss.define(Class[type])
            boss.team = -2
            boss.seeInvisible = true
            boss.settings.leaderboardable = false
            return boss
        }
    });
const doomwalkers = (function () {
        // MAP SET UP //
        const doors = [];
        let buttons = [];
        function makeDoor(loc, team = -101) {
            const door = new Entity(loc);
            door.define(Class.creepyObstacle);
            door.team = team;
            door.SIZE = (room.width / room.xgrid) / 2;
            door.protect();
            door.life();
            door.color = 34;
            doors.push(door);
            const doorID = doors.indexOf(door);
            door.onDead = function () {
                for (const button of buttons) {
                    if (button.doorID === doorID) {
                        button.ignoreButtonKill = 2;
                        button.kill();
                    }
                }
            }
        }
        function makeButton(loc, open, doorID) {
            const button = new Entity(loc);
            button.define(Class.button);
            button.pushability = button.PUSHABILITY = 0;
            button.team = -101;
            button.doorID = doorID;
            button.color = (open ? 12 : 11);
            button.onDead = function () {
                buttons = buttons.filter(instance => instance.id !== button.id);
                if (!button.ignoreButtonKill) {
                    const door = doors[button.doorID];
                    if (open) {
                        door.alpha = 0.2;
                        door.passive = true;
                        if (door.isAlive() && door.alpha === .2 && door.passive) {
                            let toKill = buttons.find(newButton => newButton.doorID === button.doorID);
                            if (toKill) {
                                toKill.kill();
                            }
                        }
                    } else {
                        door.alpha = 1;
                        door.passive = false;
                    }
                    for (const other of buttons) {
                        if (button !== other && button.doorID === other.doorID) {
                            other.ignoreButtonKill = true;
                            other.kill();
                        }
                    }
                }
                if (button.ignoreButtonKill !== 2) {
                    setTimeout(() => {
                        makeButton(loc, !open, doorID);
                    }, 2500)
                }
            }
            buttons.push(button);
        }
        function makeButtons() {
            buttonLocs = [
            ]
            let i = 0;
            for (const loc of room.door) {
                makeDoor(loc);
                switch (i++) {
                    case 0:
                        buttonLocs.push({
                            x: loc.x,
                            y: loc.y + (room.height / room.ygrid) / 1.5
                        })
                        break;
                    case 1:
                        buttonLocs.push({
                            x: loc.x + (room.width / room.xgrid) / 1.5,
                            y: loc.y
                        })
                        break;
                    case 2:
                        buttonLocs.push({
                            x: loc.x - (room.width / room.xgrid) / 1.5,
                            y: loc.y
                        })
                        break;
                    case 3:
                        buttonLocs.push({
                            x: loc.x,
                            y: loc.y - (room.height / room.ygrid) / 1.5
                        })
                        break;
                }
            }
            i = 0
            for (const loc of buttonLocs) {
                makeButton(loc, 1, i++);
            }
        }
        makeButtons();
        function spawnDominator(location, team, type) {
            const o = new Entity(location);
            o.define(Class[type]);
            o.team = team;
            o.color = getTeamColor(team);
            o.name = "Innocent Tetrafras";
            o.isDominator = true;
            o.alwaysActive = true;
            o.settings.hitsOwnType = "pushOnlyTeam";
            o.FOV = .5;
        }
        spawnDominator(room["domm"][0], -1, "laserDomAI");

        // DIFFICULTY INCREASING LOOP //
        setInterval(() => {
            for (let player of players) {
                // Setup any new players
                if (!player.body || (player.body && !player.body.isAlive())) {
                    if (player.vw.crasherArray) {
                        while (player.vw.crasherArray.length) {
                            player.vw.crasherArray.shift().destroy()
                        }
                    }
                    if (player.vw.sentryArray) {
                        while (player.vw.sentryArray.length) {
                            player.vw.sentryArray.shift().destroy()
                        }
                    }
                    if (player.vw.bossArray) {
                        while (player.vw.bossArray.length) {
                            player.vw.bossArray.shift().destroy()
                        }
                    }
                    continue
                }
                if (!player.vw) {
                    player.vw = {
                        crasherArray: [],
                        sentryArray: [],
                        bossArray: [],
                    }
                    player.body.skill.level = 60
                    player.body.skill.points = 42
                    player.body.refreshBodyAttributes()
                }
                player.body.scoped = false
                player.body.settings.leaderboardable = true

                // Adjust caps based on difficulty
                player.body.skill.score = player.vw.distanceFromOutpost = util.getDistance(player.body, room["domm"][0])
                player.vw.difficulty = Math.min(1, player.vw.distanceFromOutpost / 75_000) // 100000 being the farthest till difficulty stays the same
                player.vw.crasherAmount = Math.round(185 * player.vw.difficulty)
                player.vw.sentryAmount = Math.round(26 * player.vw.difficulty)
                player.vw.bossAmount = Math.round(5 * player.vw.difficulty)

                // Adjust enemies based on the caps
                // CRASHERS //
                for (let i = 0; i < player.vw.crasherArray.length; i++) {
                    let crasher = player.vw.crasherArray[i]
                    if (util.getDistance(player.body, crasher) > 2000) {
                        player.vw.crasherArray.splice(i, 1)
                        crasher.destroy()
                    }
                }
                while (player.vw.crasherArray.length > player.vw.crasherAmount) {
                    let crasher = player.vw.crasherArray.shift()
                    crasher.destroy()
                }
                let crasherList = getCrasherList(player.vw.difficulty)
                while (player.vw.crasherArray.length < player.vw.crasherAmount) {
                    if (!crasherList.length) {
                        break;
                    }
                    let crasher = summonCrasher(player, crasherList)
                    targetableEntities.push(crasher)
                    player.vw.crasherArray.push(crasher)
                }

                // SENTERIES //
                for (let i = 0; i < player.vw.sentryArray.length; i++) {
                    let sentry = player.vw.sentryArray[i]
                    if (util.getDistance(player.body, sentry) > 2000) {
                        player.vw.sentryArray.splice(i, 1)
                        sentry.destroy()
                    }
                }
                while (player.vw.sentryArray.length > player.vw.sentryAmount) {
                    let sentry = player.vw.sentryArray.shift()
                    sentry.destroy()
                }
                let sentryList = getSentryList(player.vw.difficulty)
                while (player.vw.sentryArray.length < player.vw.sentryAmount) {
                    if (!sentryList.length) {
                        break;
                    }
                    let sentry = summonSentry(player, sentryList)
                    targetableEntities.push(sentry)
                    player.vw.sentryArray.push(sentry)
                }

                // BOSSES // 
                for (let i = 0; i < player.vw.bossArray.length; i++) {
                    let boss = player.vw.bossArray[i]
                    if (util.getDistance(player.body, boss) > 2000) {
                        player.vw.bossArray.splice(i, 1)
                        boss.destroy()
                    }
                }
                while (player.vw.bossArray.length > player.vw.bossAmount) {
                    let boss = player.vw.bossArray.shift()
                    boss.destroy()
                }
                let bossList = getBossList(player.vw.difficulty)
                while (player.vw.bossArray.length < player.vw.bossAmount) {
                    if (!bossList.length) {
                        break;
                    }
                    let boss = summonBoss(player, bossList)
                    targetableEntities.push(boss)
                    player.vw.bossArray.push(boss)
                }
            }
        }, 1000)

        // DIFFICULTY INCREASING LOOP FUNCTIONS //
        const buffer = 1000 + ran.randomRange(-100, 100)
        let crasherDifficultyList = {
            "0.01": [
                "voidCrasher",
                "Voidling1"
            ],
            "0.05": [
                "Voidling2"
            ],
            "0.10": [
                "Voidling3",
                "echorinth"
            ],
            "0.15": [
                "Voidling4"
            ],
            "0.25": [
                "Voidling5"
            ]
        }
        function getCrasherList(diff) {
            let list = []
            for (let val in crasherDifficultyList) {
                if (Number(val) > diff) {
                    return list
                }
                list = list.concat(crasherDifficultyList[val])
            }
            return list
        }
        function summonCrasher(player, crasherList) {
            const angle = Math.PI * 2 * Math.random();
            let spawnPos = {
                x: player.body.x + Math.cos(angle) * buffer,
                y: player.body.y + Math.sin(angle) * buffer
            }
            let crasher = new Entity(spawnPos)
            let type = ran.choose(crasherList)
            crasher.define(Class[type])
            crasher.team = -2
            if (ran.chance(0.5)) {
                crasher.seeInvisible = true
            }
            crasher.settings.leaderboardable = false
            return crasher
        }

        let sentryDifficultyList = {
            "0.05": [
                "Voidling6"
            ],
            "0.15": [
                "Voidling7"
            ],
            "0.20": [
                "Voidling8"
            ],
            "0.25": [
                "Voidling9",
                //"bot"
            ],
            "0.40": [
                "voidSentry",
                "Voidling10"
            ]
        }
        function getSentryList(diff) {
            let list = []
            for (let val in sentryDifficultyList) {
                if (Number(val) > diff) {
                    return list
                }
                list = list.concat(sentryDifficultyList[val])
            }
            return list
        }
        function summonSentry(player, sentryList) {
            const angle = Math.PI * 2 * Math.random();
            let spawnPos = {
                x: player.body.x + Math.cos(angle) * buffer,
                y: player.body.y + Math.sin(angle) * buffer
            }
            let sentry = new Entity(spawnPos)
            let type = ran.choose(sentryList)
            sentry.define(Class[type])
            sentry.team = -2
            if (ran.chance(0.75)) {
                sentry.seeInvisible = true
            }
            sentry.settings.leaderboardable = false
            return sentry
        }

        let bossDifficultyList = {
            "0.3": [
                "nyxaloth",
                "reflector",
            ],
            "0.4": [
                "viewerAI",
                "shadowShardAI"
            ],
            "0.6": [
                "bloodyMaryAI",
                "shadowCoreAI"
            ],
            "0.9": [
                  "supremeChaosMakerAI"
         ],
        }
        function getBossList(diff) {
            let list = []
            for (let val in bossDifficultyList) {
                if (Number(val) > diff) {
                    return list
                }
                list = list.concat(bossDifficultyList[val])
            }
            return list
        }
        function summonBoss(player, bossList) {
            const angle = Math.PI * 2 * Math.random();
            let spawnPos = {
                x: player.body.x + Math.cos(angle) * buffer,
                y: player.body.y + Math.sin(angle) * buffer
            }
            let boss = new Entity(spawnPos)
            let type = ran.choose(bossList)
            boss.define(Class[type])
            boss.team = -2
            boss.seeInvisible = true
            boss.settings.leaderboardable = false
            return boss
        }
    });
    const getEntity = id => entities.get(id);

    const trimName = name => (name || "").replace("‮", "").trim() ||  /*"Player " + this.socket.playerId;*/"An unnamed player";
    const quickCombine = stats => {
        if (stats == null) return "Please input a valid array of gun settings.";
        if (stats.length === 13) return "Please make sure to place the gun settings in an array.";
        let data = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        for (let value of stats)
            for (let i = 0; i < data.length; ++i) data[i] *= value[i];
        return data;
    };

    room.init();
    class IO {
        constructor(b) {
            this.body = b;
            this.acceptsFromTop = true;
        }
        think() {
            return {
                target: null,
                goal: null,
                fire: null,
                main: null,
                alt: null,
                power: null
            };
        }
    }
    const ioTypes = {};
    ioTypes.bossRushAI = class extends IO {
        constructor(body) {
            super(body);
            this.enabled = true;
            this.goal = room.randomType("nest");
        }
        think(input) {
            if (room.isIn("nest", this.body)) {
                this.enabled = false;
            }
            if (room.isIn("boss", this.body)) {
                this.enabled = true;
            }
            if (this.enabled) {
                return {
                    main: false,
                    fire: false,
                    alt: false,
                    goal: this.goal
                }
            } else if (!input.main && !input.alt) {
                if (room["bas1"] && room["bas1"].length) {
                    this.goal = room["bas1"][0];
                    return {
                        main: false,
                        fire: false,
                        alt: false,
                        goal: this.goal
                    }
                }
            }
        }
    }
    ioTypes.doNothing = class extends IO {
        constructor(b) {
            super(b);
            this.acceptsFromTop = false;
        }
        think() {
            return {
                goal: {
                    x: this.body.x,
                    y: this.body.y
                },
                main: false,
                alt: false,
                fire: false
            };
        }
    }
    ioTypes.droneTrap = class extends IO {
        constructor(b) {
            super(b);
            this.done = false;
        }
        think(input) {
            if (input.alt && !this.done) {
                this.done = true;
                this.body.define(Class.droneTrapTrap);
            }
        }
    }
    const quartPI = Math.PI / 4;
    ioTypes.moveInCircles = class extends IO {
        constructor(b) {
            super(b);
            this.acceptsFromTop = false;
            this.timer = ran.irandom(10) + 3;
            this.goal = {
                x: this.body.x + 7.5 * Math.cos(-this.body.facing),
                y: this.body.y + 7.5 * Math.sin(-this.body.facing)
            };
        }
        think() {
            if (!(this.timer--)) {
                this.timer = 10;
                this.goal = {
                    x: this.body.x + 7.5 * Math.cos(-this.body.facing),
                    y: this.body.y + 7.5 * Math.sin(-this.body.facing)
                };
            }
            return {
                goal: this.goal
            };
        }
    }
    ioTypes.listenToPlayer = class extends IO {
        constructor(b, p) {
            super(b);
            this.player = p;
            this.acceptsFromTop = false;
        }
        think() {
            let targ = {
                x: this.player.target.x,
                y: this.player.target.y
            };
            if (this.body.invuln && (this.player.command.right || this.player.command.left || this.player.command.up || this.player.command.down || this.player.command.lmb)) this.body.invuln = false;
            this.body.autoOverride = this.body.passive || this.player.command.override;
            if (this.body.aiSettings.isDigger) {
                let av = Math.sqrt(targ.x * targ.x, targ.y * targ.y);
                let x = targ.x /= av - 1;
                let y = targ.y /= av - 1;
                let p;
                if (!this.body.invuln) {
                    if (this.player.command.lmb) {
                        if (this.body.health.display() > 0.1) {
                            this.body.health.amount -= 1.5;
                            p = 1.75;
                        }
                    } else if (this.player.command.rmb) {
                        this.body.health.amount += 0.75;
                        p = 0.5;
                    } else p = 1;
                }
                if (p === 1) this.body.width = 1;
                else if (p > 1) this.body.width = 2;
                else this.body.width = 3;
                return {
                    target: {
                        x: x, y: y
                    },
                    _target: {
                        x: x, y: y
                    },
                    goal: {
                        x: this.body.x + x * !this.body.invuln,
                        y: this.body.y + y * !this.body.invuln
                    },
                    fire: this.player.command.lmb || this.player.command.autofire,
                    main: this.player.command.lmb || this.player.command.autospin || this.player.command.autofire,
                    alt: this.player.command.rmb,
                    power: p,
                }
            }
            if (this.player.command.autospin) {
                let kk = Math.atan2(this.body.control.target.y, this.body.control.target.x) + this.body.spinSpeed;
                targ = {
                    x: 275 * Math.cos(kk),
                    y: 275 * Math.sin(kk)
                };
            }
            return {
                target: targ,
                _target: targ,
                goal: {
                    x: this.body.x + (this.player.command.right - this.player.command.left),
                    y: this.body.y + (this.player.command.down - this.player.command.up)
                },
                fire: this.player.command.lmb || this.player.command.autofire,
                main: this.player.command.lmb || this.player.command.autospin || this.player.command.autofire,
                alt: this.player.command.rmb
            };
        }
    }
    ioTypes.listenToPlayerStatic = class extends IO {
        constructor(b, p) {
            super(b);
            this.player = p;
            this.acceptsFromTop = false;
        }
        think() {
            let targ = {
                x: this.player.target.x,
                y: this.player.target.y
            };
            if (this.player.command.autospin) {
                let kk = Math.atan2(this.body.control.target.y, this.body.control.target.x) + .02;
                targ = {
                    x: 275 * Math.cos(kk),
                    y: 275 * Math.sin(kk)
                };
            }
            if (this.body.invuln && (this.player.command.right || this.player.command.left || this.player.command.up || this.player.command.down || this.player.command.lmb)) this.body.invuln = false;
            this.body.autoOverride = this.body.passive || this.player.command.override;
            return {
                target: targ,
                fire: this.player.command.lmb || this.player.command.autofire,
                main: this.player.command.lmb || this.player.command.autospin || this.player.command.autofire,
                alt: this.player.command.rmb
            };
        }
    }
    ioTypes.mapTargetToGoal = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            if (input.main || input.alt) return {
                goal: {
                    x: input.target.x + this.body.x,
                    y: input.target.y + this.body.y
                },
                power: 1
            };
        }
    }

    ioTypes.guidedAlwaysTarget = class extends IO {
        constructor(b) {
            super(b);
            this.master = b.master
        }
        think(input) {
            return {
                target: {
                    x: this.master.control.target.x + this.master.x - this.body.x,
                    y: this.master.control.target.y + this.master.y - this.body.y
                },
                power: 1
            };
        }
    }
    ioTypes.guided = class extends IO {
        constructor(b) {
            super(b);
            this.master = b.master
        }
        think(input) {
            this.body.isGuided = true
            let main = undefined;
            for(let [key, child] of this.master.childrenMap){
                if(!child.isGuided) continue;
                main = child;
                break;
            }
            if (!main || !this.master.socket) {
                return
            }
            this.master.altCameraSource = [main.x, main.y]
        }
    }
    ioTypes.boomerang = class extends IO {
        constructor(b) {
            super(b);
            this.r = 0;
            this.b = b;
            this.m = b.master;
            this.turnover = false;
            this.myGoal = {
                x: 3 * b.master.control.target.x + b.master.x,
                y: 3 * b.master.control.target.y + b.master.y
            };
        }
        think(input) {
            if (this.b.range > this.r) this.r = this.b.range;
            let t = 1;
            if (!this.turnover) {
                if (this.r && this.b.range < this.r * .5) this.turnover = true;
                return {
                    goal: this.myGoal,
                    power: t
                };
            } else return {
                goal: {
                    x: this.m.x,
                    y: this.m.y
                },
                power: t
            };
        }
    }
    ioTypes.oscillate = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }

        think(input) {
            this.a += 0.21;
            this.offset = this.body.source.facing + this.body.bound.angle * this.body.source.acceleration;
            return {
                target: {
                    x: Math.cos(Math.sin(this.a) + this.offset),
                    y: Math.sin(Math.sin(this.a) + this.offset),
                },
            main: true,
            };
        }
    }
    ioTypes.oscillateAlt = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }

        think(input) {
            this.a -= 0.21;
            this.offset = this.body.source.facing + this.body.bound.angle * this.body.source.acceleration;
            return {
                target: {
                    x: Math.cos(Math.sin(this.a) + this.offset),
                    y: Math.sin(Math.sin(this.a) + this.offset),
                },
            main: true,
            };
        }
    }
    ioTypes.goToMasterTarget = class extends IO {
        constructor(body) {
            super(body);
            this.myGoal = {
                x: body.master.control.target.x + body.master.x,
                y: body.master.control.target.y + body.master.y
            };
            this.countdown = 5;
        }
        think() {
            if (this.countdown) {
                if (util.getDistance(this.body, this.myGoal) < 1) {
                    this.countdown--;
                }
                return {
                    goal: {
                        x: this.myGoal.x,
                        y: this.myGoal.y
                    }
                };
            }
        }
    }
    ioTypes.goAwayFromMasterTarget = class extends IO {
        constructor(body) {
            super(body);
            this.myGoal = {
                x: -body.master.control.target.x + body.master.x,
                y: -body.master.control.target.y + body.master.y
            };
            this.countdown = 5;
        }
        think() {
            if (this.countdown) {
                if (util.getDistance(this.body, this.myGoal) < 1) {
                    this.countdown--;
                }
                return {
                    goal: {
                        x: this.myGoal.x,
                        y: this.myGoal.y
                    }
                };
            }
        }
    }
    ioTypes.block = class extends IO {
        constructor(body) {
            super(body);
            this.blockAngle = Math.atan2(body.y - body.master.y, body.x - body.master.x) - Math.atan2(body.master.control.target.y, body.master.control.target.x);
            if (Math.abs(this.blockAngle) === Infinity) this.blockAngle = 0;
            this.myGoal = {
                x: body.master.control.target.x * Math.cos(this.blockAngle) - body.master.control.target.y * Math.sin(this.blockAngle) + body.master.x,
                y: body.master.control.target.x * Math.sin(this.blockAngle) + body.master.control.target.y * Math.cos(this.blockAngle) + body.master.y
            };
            this.countdown = 5;
        }
        think() {
            if (this.countdown) {
                if (util.getDistance(this.body, this.myGoal) < 1) {
                    this.countdown--;
                }
                return {
                    goal: {
                        x: this.myGoal.x,
                        y: this.myGoal.y
                    }
                };
            }
        }
    }
    ioTypes.portal2 = class extends IO {
        constructor(body) {
            super(body); this.portalAngle = Math.atan2(body.y - body.master.y, body.x - body.master.x) - Math.atan2(body.master.control.target.y, body.master.control.target.x);
            if (Math.abs(this.portalAngle) === Infinity) this.portalAngle = 0;
            this.myGoal = {
                x: body.master.control.target.x * Math.cos(this.portalAngle) - body.master.control.target.y * Math.sin(this.portalAngle) + body.master.x,
                y: body.master.control.target.x * Math.sin(this.portalAngle) + body.master.control.target.y * Math.cos(this.portalAngle) + body.master.y
        } 
    };
        think() {
            this.body.x = this.myGoal.x;
            this.body.y = this.myGoal.y;
            return {
                goal: {
                    x: this.myGoal.x,
                    y: this.myGoal.y
                }
            };
        }
    }
    ioTypes.triBoomerang = class extends IO {
        constructor(b) {
            super(b);
            this.r = 0;
            this.b = b;
            this.m = b.master;
            this.turnover = false;
            this.boomAngle = Math.atan2(b.y - b.master.y, b.x - b.master.x) - Math.atan2(b.master.control.target.y, b.master.control.target.x);
            if (Math.abs(this.boomAngle) === Infinity) this.boomAngle = 0;
            this.myGoal = {
                x: 3 * b.master.control.target.x * Math.cos(this.boomAngle) - 3 * b.master.control.target.y * Math.sin(this.boomAngle) + b.master.x,
                y: 3 * b.master.control.target.x * Math.sin(this.boomAngle) + 3 * b.master.control.target.y * Math.cos(this.boomAngle) + b.master.y,
            };
        }
        think(input) {
            if (this.b.range > this.r) this.r = this.b.range;
            let t = 1;
            if (!this.turnover) {
                if (this.r && this.b.range < this.r * .5) this.turnover = true;
                return {
                    goal: this.myGoal,
                    power: t
                };
            } else return {
                goal: {
                    x: this.m.x,
                    y: this.m.y
                },
                power: t
            };
        }
    }
    ioTypes.canRepel = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            if (input.alt && input.target && (util.getDistance(this.body, this.body.master) < this.body.master.fov / 1.5)) return {
                target: {
                    x: -input.target.x,
                    y: -input.target.y
                },
                main: true
            };
        }
    }
    ioTypes.mixedNumber = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            if (input.alt) {
                this.body.define(Class.mixedNumberTrap);
            }
        }
    }
    ioTypes.fireGunsOnAlt = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            if (input.alt) {
                for (let i = 0; i < this.body.guns.length; i++) {
                    let gun = this.body.guns[i];
                    let gx = gun.offset * Math.cos(gun.direction + gun.angle + gun.body.facing) + (1.35 * gun.length - gun.width * gun.settings.size / 2) * Math.cos(gun.angle + this.body.facing),
                        gy = gun.offset * Math.sin(gun.direction + gun.angle + gun.body.facing) + (1.35 * gun.length - gun.width * gun.settings.size / 2) * Math.sin(gun.angle + this.body.facing);
                    gun.fire(gx, gy, this.body.skill);
                }
                this.body.kill();
                let gun = this.body.master.guns[this.body.gunIndex];
                if (gun.countsOwnKids) gun.children = gun.children.filter(instance => instance == this);
            }
        }
    }
    ioTypes.killOnAlt = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            if (input.alt) {
                this.body.kill();
            }
        }
    }
    ioTypes.alwaysFire = class extends IO {
        constructor(body) {
            super(body);
        }
        think() {
            return {
                fire: true
            };
        }
    }
    ioTypes.targetSelf = class extends IO {
        constructor(body) {
            super(body);
        }
        think() {
            return {
                main: true,
                target: {
                    x: 0,
                    y: 0
                }
            };
        }
    }
    ioTypes.mapAltToFire = class extends IO {
        constructor(body) {
            super(body);
        }
        think(input) {
            if (input.alt) return {
                fire: true
            };
        }
    }
    ioTypes.onlyAcceptInArc = class extends IO {
        constructor(body) {
            super(body);
        }
        think(input) {
            if (input.target && this.body.firingArc != null && (Math.abs(util.angleDifference(Math.atan2(input.target.y, input.target.x), this.body.firingArc[0])) >= this.body.firingArc[1])) return {
                fire: false,
                alt: false,
                main: false
            };
        }
    }
    ioTypes.oaiaAlt = class extends IO {
        constructor(body) {
            super(body);
        }
        think(input) {
            if (input.target && this.body.firingArc != null && -(Math.abs(util.angleDifference(Math.atan2(input.target.y, input.target.x), this.body.firingArc[0])) >= this.body.firingArc[1])) return {
                fire: false,
                alt: false,
                main: false
            };
        }
    }
    ioTypes.onlyFireWhenInRange = class extends IO {
        constructor(body) {
            super(body);
        }
        think(input) {
            if (input.target && this.body.firingArc != null) {
                if (Math.abs(util.angleDifference(Math.atan2(input.target.y, input.target.x), this.body.facing)) >= .0334) {
                    return {
                        fire: false,
                        altOverride: true
                    };
                }
            }
        }
    }
    ioTypes.battleshipTurret = class extends IO {
        constructor(body) {
            super(body);
        }
        think(input) {
            if (input.target) {
                if (Math.abs(util.angleDifference(Math.atan2(input.target.y, input.target.x), this.body.facing)) >= .015) {
                    return {
                        fire: false,
                        altOverride: true
                    };
                }
            }
        }
    }
    ioTypes.skipBomb = class extends IO {
        constructor(body) {
            super(body);
            this.time = 15;
            this.initialAngle = body.velocity.direction;
        }
        think(input) {
            this.time--;
            if (this.time <= 0) {
                this.time = 15;
                let angle = this.initialAngle + (Math.random() * (Math.PI / 2) - (Math.PI / 4));
                this.body.velocity = new Vector(Math.cos(angle) * this.body.initialBulletSpeed, Math.sin(angle) * this.body.initialBulletSpeed);
            }
        }
    }
    ioTypes.nearestDifferentMaster = class extends IO {
    constructor(body) {
        super(body);
        this.target = null;
        this.tick = 0;
        this.lead = 0;
        this.validTargets = [];
        this.oldHealth = body.health.display();
        this.targetLock = undefined;
    }

    findTargets(range) {        
        // Precalculate frequently used values
        const pos = this.body.aiSettings.SKYNET ? this.body.master.master : this.body;
        const baseRange = this.body.aiSettings.SKYNET ? range * Math.sqrt(4 / 3) : range;
        const myTeam = this.body.master.master.team;
        const aiSettings = this.body.aiSettings;
        const bodySettings = this.body.settings;
        const seeInvisible = this.body.seeInvisible;
        const isArenaCloser = this.body.isArenaCloser;
        const firingArc = this.body.firingArc;
        const view360 = aiSettings.view360;

        // Create bounding box for hashgrid query
        const searchAABB = { _AABB: {
          x1: pos.x - baseRange,
          y1: pos.y - baseRange,
          x2: pos.x + baseRange,
          y2: pos.y + baseRange,
          currentQuery: -1
        }};
      
        // Use HashGrid to get potential targets
        const potentialTargets = grid.getCollisions(searchAABB);
      
        let highestDanger = 0;
        let output = [];
        
        // Early-exit checks as constants
        const checkRanked = c.RANKED_BATTLE;
        const checkSandbox = c.SANDBOX;
        const ignoreShapes = aiSettings.IGNORE_SHAPES;
        
        // Use Set features for faster lookups if targetLock exists
        const targetLockId = this.targetLock?.id;
        
        for (const entity of potentialTargets) {
            // Skip invalid entities
            if (entity.master.master.team == myTeam || entity.team === -101 // Teams
                || entity.isDead() || entity.passive || entity.invuln || (!isArenaCloser && !seeInvisible && entity.alpha <= .5) || // Statuses
                !Number.isFinite(entity.dangerValue) || entity.dangerValue < 0 || // Danger
                (checkRanked && entity.roomId !== this.body.roomId) || (checkSandbox && entity.sandboxId !== this.body.sandboxId) // Room
                ) continue;
                
            // Type checks
            const entityType = entity.type;
            if ((entityType === "miniboss" || entityType === "tank" || entityType === "crasher" || entityType === "minion" || entityType === "drone" || (!ignoreShapes && entityType === 'food')) === false) continue;
            
            // Skip farming logic if not dangerous enough
            if (!aiSettings.farm && entity.dangerValue < highestDanger) continue;
            
            // Position checks - more precise distance check
            /*if (!aiSettings.BLIND) {
                const dx = entity.x - myPos.x;
                const dy = entity.y - myPos.y;
                if (dx * dx + dy * dy >= sqrRange) continue;
            }*/
            
            // Firing arc check
            if (firingArc != null && !view360) {
                const angleDiff = Math.abs(util.angleDifference(
                    util.getDirection(this.body, entity), 
                    firingArc[0]
                ));
                if (angleDiff >= firingArc[1]) continue;
            }
            
            // If we got here, entity is valid
            highestDanger = Math.max(highestDanger, entity.dangerValue);
            output.push(entity);
            
            // Early return if we found our locked target
            if (targetLockId && entity.id === targetLockId) {
                return [entity]; // Return just the locked target
            }
        }
        
        //newLogs.buildList.stop();
        return output;
    }

    think(input) {
        // Early returns for manual control
        if (input.main || input.alt || 
            this.body.master.autoOverride || 
            this.body.master.master.passive || 
            this.body.master.master.invuln) {
            this.targetLock = undefined;
            return {};
        }
        
        
        // Calculate tracking and range once
        let tracking = this.body.topSpeed;
        let range =  this.body.aiSettings.SKYNET ? this.body.master.fov : this.body.fov;
        
        // Optimize gun loop - only need first shootable gun
        const guns = this.body.guns;
        for (let i = 0, l = guns.length; i < l; i++) {
            const gun = guns[i];
            if (gun.canShoot) {
                const v = gun.getTracking();
                tracking = v.speed;
                
                if (this.isBot) {
                    if (this.body.fov < range) range = this.body.fov;
                } else {
                    const rangeEstimate = (v.speed || 1.5) * 
                        (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                    if (rangeEstimate < range) range = rangeEstimate;
                }
                break;
            }
        }
        
        // Range sanity check
        if (range < this.body.size || !Number.isFinite(range)) {
            range = this.body.fov;
        }
        
        if (!Number.isFinite(tracking)) {
            tracking = this.body.topSpeed;
        }
        
        // Target processing timer
        if (++this.tick > 10) {
            this.tick = 0;
            
            // Bot range adjustment
            const adjustedRange = (this.body.isBot || this.body.isMothership) ? range * 0.65 : range;
            this.validTargets = this.findTargets(adjustedRange);
            
            //newLogs.targeting.start();
            
            // Check if current target is still valid
            if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                this.targetLock = undefined;
            }
            
            // Select new target if needed
            if (this.targetLock == null && this.validTargets.length) {
                this.targetLock = (this.validTargets.length === 1) ? 
                    this.validTargets[0] : 
                    nearest(this.validTargets, { x: this.body.x, y: this.body.y });
                this.tick = -5;
            }
        }
        
        // Bot damage response logic
        if (this.body.isBot) {
            const damageRef = this.body.bond || this.body;
            const currentHealth = damageRef.health.display();
            
            if (damageRef.collisionArray.length && currentHealth < this.oldHealth) {
                this.oldHealth = currentHealth;
                const collider = damageRef.collisionArray[0];
                
                if (this.validTargets.indexOf(collider) === -1) {
                    this.targetLock = collider.master.id === -1 ? 
                        collider.source : collider.master;
                }
            }
        }
        
        // Target tracking logic
        if (this.targetLock != null) {
            const radial = this.targetLock.velocity;
            const diff = {
                x: this.targetLock.x - this.body.x,
                y: this.targetLock.y - this.body.y,
            };
            
            // Calculate lead on even ticks
            if (this.tick % 2 === 0) {
                this.lead = 0;
                if (!this.body.aiSettings.CHASE) {
                    this.lead = timeOfImpact(diff, radial, tracking);
                }
            }
            
            // Lead sanity check
            if (!Number.isFinite(this.lead)) {
                this.lead = 0;
            }
            
            return {
                target: {
                    x: diff.x + this.lead * radial.x,
                    y: diff.y + this.lead * radial.y,
                },
                fire: true,
                main: true
            };
        }
        
        return {};
    }
};
 ioTypes.nearestDifferentMasterTeamless = class extends IO {
        // this is a bit of a hack, but it works
        constructor(body) {
            super(body);
            this.target = null;
            this.tick = 0;
            this.lead = 0;
            this.validTargets = [];
            this.oldHealth = body.health.display();
        }
        findTargets(range) {
            //newLogs.buildList.start();
            let highestDanger = 0,
                output = [],
                myPos = {
                    x: this.body.x,
                    y: this.body.y
                },
                masterPos = {
                    x: this.body.master.master.x,
                    y: this.body.master.master.y
                },
                sqrRange = range * range,
                sqrRangeMaster = range * range * 4 / 3;
            /*let targetable = targetingGrid.queryForCollisionPairs({
                id: this.body.id,
                _AABB: targetingGrid.getAABB({
                    x: myPos.x,
                    y: myPos.y,
                    size: sqrRange
                })
            });*/
            for (let i = 0, l = targetableEntities.length; i < l; i++) {
                let entity = targetableEntities[i];
                if (
                    (
                        entity !== this.body &&
                        (this.body.aiSettings.farm || entity.dangerValue >= highestDanger) &&
                        (!c.RANKED_BATTLE || (entity.roomId === this.body.roomId)) &&
                        (!c.SANDBOX || (entity.sandboxId === this.body.sandboxId)) &&
                        (this.body.seeInvisible || this.body.isArenaCloser || entity.alpha > 0.5) &&
                        (this.body.settings.targetPlanes ? (entity.isPlane && (entity.type === "drone" || entity.type === "minion")) : (entity.type === "miniboss" || entity.type === "tank" || entity.type === "crasher" || (!this.body.aiSettings.IGNORE_SHAPES && entity.type === 'food'))) &&
                        (this.body.aiSettings.BLIND || ((entity.x - myPos.x) * (entity.x - myPos.x) < sqrRange && (entity.y - myPos.y) * (entity.y - myPos.y) < sqrRange)) &&
                        (this.body.aiSettings.SKYNET || ((entity.x - masterPos.x) * (entity.x - masterPos.x) < sqrRangeMaster && (entity.y - masterPos.y) * (entity.y - masterPos.y) < sqrRangeMaster))
                    ) && (
                        this.body.firingArc == null ||
                        this.body.aiSettings.view360 ||
                        Math.abs(util.angleDifference(util.getDirection(this.body, entity), this.body.firingArc[0])) < this.body.firingArc[1]
                    )
                ) {
                    highestDanger = entity.dangerValue;
                    output.push(entity);
                    if (this.targetLock && entity.id === this.targetLock.id) {
                        break;
                    }
                }
            }
            //newLogs.buildList.stop();
            return output;
        }
        think(input) {
            if (input.main || input.alt || this.body.master.autoOverride || this.body.master.master.passive || this.body.master.master.invuln) {
                this.targetLock = undefined;
                return {};
            }
            //newLogs.targeting.start();
            let tracking = this.body.topSpeed,
                range = this.body.fov;
            for (let i = 0, l = this.body.guns.length; i < l; i++) {
                if (this.body.guns[i].canShoot) {
                    let v = this.body.guns[i].getTracking();
                    tracking = v.speed;
                    if (this.isBot) {
                        if (this.body.fov < range) {
                            range = this.body.fov;
                        }
                    } else {
                        let fuck = (v.speed || 1.5) * (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                        if (fuck < range) {
                            range = fuck;
                        }
                    }
                    break;
                }
            }
            if (range < this.body.size || !Number.isFinite(range)) {
                range = this.body.fov;
            }
            !Number.isFinite(tracking) && (tracking = this.body.topSpeed);
            // OK, now let's try reprocessing the targets!
            this.tick++;
            if (this.tick > 10) {
                this.tick = 0;
                //newLogs.targeting.stop();
                this.validTargets = this.findTargets((this.body.isBot || this.body.isMothership) ? range * .65 : range);
                //newLogs.targeting.start();
                if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                    this.targetLock = undefined;
                }
                if (this.targetLock == null && this.validTargets.length) {
                    this.targetLock = (this.validTargets.length === 1) ? this.validTargets[0] : nearest(this.validTargets, {
                        x: this.body.x,
                        y: this.body.y
                    });
                    this.tick = -5;
                }
            }
            if (this.body.isBot) {
                let damageRef = this.body.bond || this.body;
                if (damageRef.collisionArray.length && damageRef.health.display() < this.oldHealth) {
                    this.oldHealth = damageRef.health.display();
                    if (this.validTargets.indexOf(damageRef.collisionArray[0]) === -1) {
                        this.targetLock = damageRef.collisionArray[0].master.id === -1 ? damageRef.collisionArray[0].source : damageRef.collisionArray[0].master;
                    }
                }
            }
            if (this.targetLock != null) {
                let radial = this.targetLock.velocity,
                    diff = {
                        x: this.targetLock.x - this.body.x,
                        y: this.targetLock.y - this.body.y,
                    };
                if (this.tick % 2 === 0) {
                    this.lead = 0;
                    if (!this.body.aiSettings.CHASE) {
                        let toi = timeOfImpact(diff, radial, tracking);
                        this.lead = toi;
                    }
                }
                if (!Number.isFinite(this.lead)) {
                    this.lead = 0;
                }
                //newLogs.targeting.stop();
                return {
                    target: {
                        x: diff.x + this.lead * radial.x,
                        y: diff.y + this.lead * radial.y,
                    },
                    fire: true,
                    main: true
                };
            }
            //newLogs.targeting.stop();
            return {};
        }
    }
   ioTypes.nearestDifferentMasterHeal = class extends IO {
        // this is a bit of a hack, but it works
        constructor(body) {
            super(body);
            this.target = null;
            this.tick = 0;
            this.lead = 0;
            this.validTargets = [];
            this.oldHealth = body.health.display();
        }
        findTargets(range) {
            //newLogs.buildList.start();
            let highestDanger = 0,
                output = [],
                myPos = {
                    x: this.body.x,
                    y: this.body.y
                },
                masterPos = {
                    x: this.body.master.master.x,
                    y: this.body.master.master.y
                },
                sqrRange = range * range,
                sqrRangeMaster = range * range * 4 / 3;
            /*let targetable = targetingGrid.queryForCollisionPairs({
                id: this.body.id,
                _AABB: targetingGrid.getAABB({
                    x: myPos.x,
                    y: myPos.y,
                    size: sqrRange
                })
            });*/
            for (let i = 0, l = targetableEntities.length; i < l; i++) {
                let entity = targetableEntities[i];
                if (
                    (
                        entity.master.master.team == this.body.master.master.team &&
                        (this.body.aiSettings.farm || entity.dangerValue >= highestDanger) &&
                        (!c.RANKED_BATTLE || (entity.roomId === this.body.roomId)) &&
                        (!c.SANDBOX || (entity.sandboxId === this.body.sandboxId)) &&
                        (this.body.seeInvisible || this.body.isArenaCloser || entity.alpha > 0.5) &&
                        (this.body.settings.targetPlanes ? (entity.isPlane && (entity.type === "drone" || entity.type === "minion")) : (entity.type === "miniboss" || entity.type === "tank" || entity.type === "crasher" || (!this.body.aiSettings.IGNORE_SHAPES && entity.type === 'food'))) &&
                        (this.body.aiSettings.BLIND || ((entity.x - myPos.x) * (entity.x - myPos.x) < sqrRange && (entity.y - myPos.y) * (entity.y - myPos.y) < sqrRange)) &&
                        (this.body.aiSettings.SKYNET || ((entity.x - masterPos.x) * (entity.x - masterPos.x) < sqrRangeMaster && (entity.y - masterPos.y) * (entity.y - masterPos.y) < sqrRangeMaster))
                    ) && (
                        this.body.firingArc == null ||
                        this.body.aiSettings.view360 ||
                        Math.abs(util.angleDifference(util.getDirection(this.body, entity), this.body.firingArc[0])) < this.body.firingArc[1]
                    )
                ) {
                    highestDanger = entity.dangerValue;
                    output.push(entity);
                    if (this.targetLock && entity.id === this.targetLock.id) {
                        break;
                    }
                }
            }
            //newLogs.buildList.stop();
            return output;
        }
        think(input) {
            if (input.main || input.alt || this.body.master.autoOverride || this.body.master.master.passive || this.body.master.master.invuln) {
                this.targetLock = undefined;
                return {};
            }
            //newLogs.targeting.start();
            let tracking = this.body.topSpeed,
                range = this.body.fov;
            for (let i = 0, l = this.body.guns.length; i < l; i++) {
                if (this.body.guns[i].canShoot) {
                    let v = this.body.guns[i].getTracking();
                    tracking = v.speed;
                    if (this.isBot) {
                        if (this.body.fov < range) {
                            range = this.body.fov;
                        }
                    } else {
                        let fuck = (v.speed || 1.5) * (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                        if (fuck < range) {
                            range = fuck;
                        }
                    }
                    break;
                }
            }
            if (range < this.body.size || !Number.isFinite(range)) {
                range = this.body.fov;
            }
            !Number.isFinite(tracking) && (tracking = this.body.topSpeed);
            // OK, now let's try reprocessing the targets!
            this.tick++;
            if (this.tick > 10) {
                this.tick = 0;
                //newLogs.targeting.stop();
                this.validTargets = this.findTargets((this.body.isBot || this.body.isMothership) ? range * .65 : range);
                //newLogs.targeting.start();
                if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                    this.targetLock = undefined;
                }
                if (this.targetLock == null && this.validTargets.length) {
                    this.targetLock = (this.validTargets.length === 1) ? this.validTargets[0] : nearest(this.validTargets, {
                        x: this.body.x,
                        y: this.body.y
                    });
                    this.tick = -5;
                }
            }
            if (this.body.isBot) {
                let damageRef = this.body.bond || this.body;
                if (damageRef.collisionArray.length && damageRef.health.display() < this.oldHealth) {
                    this.oldHealth = damageRef.health.display();
                    if (this.validTargets.indexOf(damageRef.collisionArray[0]) === -1) {
                        this.targetLock = damageRef.collisionArray[0].master.id === -1 ? damageRef.collisionArray[0].source : damageRef.collisionArray[0].master;
                    }
                }
            }
            if (this.targetLock != null) {
                let radial = this.targetLock.velocity,
                    diff = {
                        x: this.targetLock.x - this.body.x,
                        y: this.targetLock.y - this.body.y,
                    };
                if (this.tick % 2 === 0) {
                    this.lead = 0;
                    if (!this.body.aiSettings.CHASE) {
                        let toi = timeOfImpact(diff, radial, tracking);
                        this.lead = toi;
                    }
                }
                if (!Number.isFinite(this.lead)) {
                    this.lead = 0;
                }
               // newLogs.targeting.stop();
                return {
                    target: {
                        x: diff.x + this.lead * radial.x,
                        y: diff.y + this.lead * radial.y,
                    },
                    fire: true,
                    main: true
                };
            }
            //newLogs.targeting.stop();
            return {};
        }
    }
  ioTypes.nearest2DifferentMaster = class extends IO {
        // this is a bit of a hack, but it works
        constructor(body) {
            super(body);
            this.target = null;
            this.tick = 0;
            this.lead = 0;
            this.validTargets = [];
            this.oldHealth = body.health.display();
        }
        findTargets(range) {
            //newLogs.buildList.start();
            let highestDanger = 0,
                output = [],
                myPos = {
                    x: this.body.x,
                    y: this.body.y
                },
                masterPos = {
                    x: this.body.master.master.x,
                    y: this.body.master.master.y
                },
                sqrRange = range * range,
                sqrRangeMaster = range * range * 4 / 3;
            /*let targetable = targetingGrid.queryForCollisionPairs({
                id: this.body.id,
                _AABB: targetingGrid.getAABB({
                    x: myPos.x,
                    y: myPos.y,
                    size: sqrRange
                })
            });*/
            for (let i = 0, l = targetableEntities.length; i < l; i++) {
                let entity = targetableEntities[i];
                if (
                    (
                        entity.master.master.team !== this.body.master.master.team &&
                        (this.body.aiSettings.farm || entity.dangerValue >= highestDanger) &&
                        (!c.RANKED_BATTLE || (entity.roomId === this.body.roomId)) &&
                        (!c.SANDBOX || (entity.sandboxId === this.body.sandboxId)) &&
                        (this.body.seeInvisible || this.body.isArenaCloser || entity.alpha > 0.5) &&
                        (this.body.settings.targetPlanes ? (entity.isPlane && (entity.type === "drone" || entity.type === "minion")) : (entity.type === "miniboss" || entity.type === "tank" || entity.type === "crasher" || (!this.body.aiSettings.IGNORE_SHAPES && entity.type === 'food'))) &&
                        (this.body.aiSettings.BLIND || ((entity.x - myPos.x) * (entity.x - myPos.x) < sqrRange && (entity.y - myPos.y) * (entity.y - myPos.y) < sqrRange)) &&
                        (this.body.aiSettings.SKYNET || ((entity.x - masterPos.x) * (entity.x - masterPos.x) < sqrRangeMaster && (entity.y - masterPos.y) * (entity.y - masterPos.y) < sqrRangeMaster))
                    ) && (
                        this.body.firingArc == null ||
                        this.body.aiSettings.view360 ||
                        Math.abs(util.angleDifference(util.getDirection(this.body, entity), this.body.firingArc[0])) < this.body.firingArc[1]
                    )
                ) {
                    highestDanger = entity.dangerValue;
                    output.push(entity);
                    if (this.targetLock && entity.id === this.targetLock.id) {
                        break;
                    }
                }
            }
            //newLogs.buildList.stop();
            return output;
        }
        think(input) {
            if (input.main || input.alt || this.body.master.autoOverride || this.body.master.master.passive || this.body.master.master.invuln/*|| this.body.master.master.isMothership*/) {//mine (btw the mothership)
                this.targetLock = undefined;
                return {};
            }
            //newLogs.targeting.start();
            let tracking = this.body.topSpeed,
                range = this.body.fov;
            for (let i = 0, l = this.body.guns.length; i < l; i++) {
                if (this.body.guns[i].canShoot) {
                    let v = this.body.guns[i].getTracking();
                    tracking = v.speed;
                    if (this.isBot) {
                        if (this.body.fov < range) {
                            range = this.body.fov;
                        }
                    } else {
                        let fuck = (v.speed || 1.5) * (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                        if (fuck < range) {
                            range = fuck;
                        }
                    }
                    break;
                }
            }
            if (range < this.body.size || !Number.isFinite(range)) {
                range = this.body.fov;
            }
            !Number.isFinite(tracking) && (tracking = this.body.topSpeed);
            // OK, now let's try reprocessing the targets!
            this.tick++;
            if (this.tick > 10) {
                this.tick = 0;
                //newLogs.targeting.stop();
                this.validTargets = this.findTargets((this.body.isBot || this.body.isMothership) ? range * .65 : range);
                //newLogs.targeting.start();
                if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                    this.targetLock = undefined;
                }
                if (this.targetLock == null && this.validTargets.length) {
                    this.targetLock = (this.validTargets.length === 1) ? this.validTargets[0] : nearest(this.validTargets, {
                        x: this.body.x,
                        y: this.body.y
                    }, 0, 1);
                    this.tick = -5;
                }
            }
            if (this.body.isBot) {
                let damageRef = this.body.bond || this.body;
                if (damageRef.collisionArray.length && damageRef.health.display() < this.oldHealth) {
                    this.oldHealth = damageRef.health.display();
                    if (this.validTargets.indexOf(damageRef.collisionArray[0]) === -1) {
                        this.targetLock = damageRef.collisionArray[0].master.id === -1 ? damageRef.collisionArray[0].source : damageRef.collisionArray[0].master;
                    }
                }
            }
            if (this.targetLock != null) {
                let radial = this.targetLock.velocity,
                    diff = {
                        x: this.targetLock.x - this.body.x,
                        y: this.targetLock.y - this.body.y,
                    };
                if (this.tick % 2 === 0) {
                    this.lead = 0;
                    if (!this.body.aiSettings.CHASE) {
                        let toi = timeOfImpact(diff, radial, tracking);
                        this.lead = toi;
                    }
                }
                if (!Number.isFinite(this.lead)) {
                    this.lead = 0;
                }
                //newLogs.targeting.stop();
                return {
                    target: {
                        x: diff.x + this.lead * radial.x,
                        y: diff.y + this.lead * radial.y,
                    },
                    fire: true,
                    main: true
                };
            }
            //newLogs.targeting.stop();
            return {};
        }
    }
    ioTypes.nearest3DifferentMaster = class extends IO {
        // this is a bit of a hack, but it works
        constructor(body) {
            super(body);
            this.target = null;
            this.tick = 0;
            this.lead = 0;
            this.validTargets = [];
            this.oldHealth = body.health.display();
        }
        findTargets(range) {
            //newLogs.buildList.start();
            let highestDanger = 0,
                output = [],
                myPos = {
                    x: this.body.x,
                    y: this.body.y
                },
                masterPos = {
                    x: this.body.master.master.x,
                    y: this.body.master.master.y
                },
                sqrRange = range * range,
                sqrRangeMaster = range * range * 4 / 3;
            /*let targetable = targetingGrid.queryForCollisionPairs({
                id: this.body.id,
                _AABB: targetingGrid.getAABB({
                    x: myPos.x,
                    y: myPos.y,
                    size: sqrRange
                })
            });*/
            for (let i = 0, l = targetableEntities.length; i < l; i++) {
                let entity = targetableEntities[i];
                if (
                    (
                        entity.master.master.team !== this.body.master.master.team &&
                        (this.body.aiSettings.farm || entity.dangerValue >= highestDanger) &&
                        (!c.RANKED_BATTLE || (entity.roomId === this.body.roomId)) &&
                        (!c.SANDBOX || (entity.sandboxId === this.body.sandboxId)) &&
                        (this.body.seeInvisible || this.body.isArenaCloser || entity.alpha > 0.5) &&
                        (this.body.settings.targetPlanes ? (entity.isPlane && (entity.type === "drone" || entity.type === "minion")) : (entity.type === "miniboss" || entity.type === "tank" || entity.type === "crasher" || (!this.body.aiSettings.IGNORE_SHAPES && entity.type === 'food'))) &&
                        (this.body.aiSettings.BLIND || ((entity.x - myPos.x) * (entity.x - myPos.x) < sqrRange && (entity.y - myPos.y) * (entity.y - myPos.y) < sqrRange)) &&
                        (this.body.aiSettings.SKYNET || ((entity.x - masterPos.x) * (entity.x - masterPos.x) < sqrRangeMaster && (entity.y - masterPos.y) * (entity.y - masterPos.y) < sqrRangeMaster))
                    ) && (
                        this.body.firingArc == null ||
                        this.body.aiSettings.view360 ||
                        Math.abs(util.angleDifference(util.getDirection(this.body, entity), this.body.firingArc[0])) < this.body.firingArc[1]
                    )
                ) {
                    highestDanger = entity.dangerValue;
                    output.push(entity);
                    if (this.targetLock && entity.id === this.targetLock.id) {
                        break;
                    }
                }
            }
            //newLogs.buildList.stop();
            return output;
        }
        think(input) {
            if (input.main || input.alt || this.body.master.autoOverride || this.body.master.master.passive || this.body.master.master.invuln/*|| this.body.master.master.isMothership*/) {//mine (btw the mothership)
                this.targetLock = undefined;
                return {};
            }
            //newLogs.targeting.start();
            let tracking = this.body.topSpeed,
                range = this.body.fov;
            for (let i = 0, l = this.body.guns.length; i < l; i++) {
                if (this.body.guns[i].canShoot) {
                    let v = this.body.guns[i].getTracking();
                    tracking = v.speed;
                    if (this.isBot) {
                        if (this.body.fov < range) {
                            range = this.body.fov;
                        }
                    } else {
                        let fuck = (v.speed || 1.5) * (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                        if (fuck < range) {
                            range = fuck;
                        }
                    }
                    break;
                }
            }
            if (range < this.body.size || !Number.isFinite(range)) {
                range = this.body.fov;
            }
            !Number.isFinite(tracking) && (tracking = this.body.topSpeed);
            // OK, now let's try reprocessing the targets!
            this.tick++;
            if (this.tick > 10) {
                this.tick = 0;
                //newLogs.targeting.stop();
                this.validTargets = this.findTargets((this.body.isBot || this.body.isMothership) ? range * .65 : range);
               // newLogs.targeting.start();
                if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                    this.targetLock = undefined;
                }
                if (this.targetLock == null && this.validTargets.length) {
                    this.targetLock = (this.validTargets.length === 1) ? this.validTargets[0] : nearest(this.validTargets, {
                        x: this.body.x,
                        y: this.body.y
                    }, 0, 2);
                    this.tick = -5;
                }
            }
            if (this.body.isBot) {
                let damageRef = this.body.bond || this.body;
                if (damageRef.collisionArray.length && damageRef.health.display() < this.oldHealth) {
                    this.oldHealth = damageRef.health.display();
                    if (this.validTargets.indexOf(damageRef.collisionArray[0]) === -1) {
                        this.targetLock = damageRef.collisionArray[0].master.id === -1 ? damageRef.collisionArray[0].source : damageRef.collisionArray[0].master;
                    }
                }
            }
            if (this.targetLock != null) {
                let radial = this.targetLock.velocity,
                    diff = {
                        x: this.targetLock.x - this.body.x,
                        y: this.targetLock.y - this.body.y,
                    };
                if (this.tick % 2 === 0) {
                    this.lead = 0;
                    if (!this.body.aiSettings.CHASE) {
                        let toi = timeOfImpact(diff, radial, tracking);
                        this.lead = toi;
                    }
                }
                if (!Number.isFinite(this.lead)) {
                    this.lead = 0;
                }
                //newLogs.targeting.stop();
                return {
                    target: {
                        x: diff.x + this.lead * radial.x,
                        y: diff.y + this.lead * radial.y,
                    },
                    fire: true,
                    main: true
                };
            }
            //newLogs.targeting.stop();
            return {};
        }
    }
    ioTypes.nearestDifferentMasterJFish = class extends IO {
    constructor(body) {
        super(body);
        this.target = null;
        this.tick = 0;
        this.lead = 0;
        this.validTargets = [];
        this.oldHealth = body.health.display();
        this.targetLock = undefined;
    }

    findTargets(range) {        
        // Precalculate frequently used values
        const pos = this.body.aiSettings.SKYNET ? this.body.master.master : this.body;
        const baseRange = this.body.aiSettings.SKYNET ? range * Math.sqrt(4 / 3) : range;
        const myTeam = this.body.master.master.team;
        const aiSettings = this.body.aiSettings;
        const bodySettings = this.body.settings;
        const seeInvisible = this.body.seeInvisible;
        const isArenaCloser = this.body.isArenaCloser;
        const firingArc = this.body.firingArc;
        const view360 = aiSettings.view360;
        // Create bounding box for hashgrid query
        const searchAABB = { _AABB: {
          x1: pos.x - baseRange,
          y1: pos.y - baseRange,
          x2: pos.x + baseRange,
          y2: pos.y + baseRange,
          currentQuery: -1
        }};     
        // Use HashGrid to get potential targets
        const potentialTargets = grid.getCollisions(searchAABB);      
        let highestDanger = 0;
        let output = [];        
        // Early-exit checks as constants
        const checkRanked = c.RANKED_BATTLE;
        const checkSandbox = c.SANDBOX;
        const ignoreShapes = aiSettings.IGNORE_SHAPES;       
        // Use Set features for faster lookups if targetLock exists
        const targetLockId = this.targetLock?.id;        
        for (const entity of potentialTargets) {
            // Skip invalid entities
            if (entity.master.master.team == myTeam || entity.team === -101 // Teams
                || entity.isDead() || entity.passive || entity.invuln || (!isArenaCloser && !seeInvisible && entity.alpha <= .5) || // Statuses
                !Number.isFinite(entity.dangerValue) || entity.dangerValue < 0 || // Danger
                (entity.size < 7.5) || // smaller than me
                (checkRanked && entity.roomId !== this.body.roomId) || (checkSandbox && entity.sandboxId !== this.body.sandboxId) // Room
                ) continue;
                
            // Criteria checks
            const entityType = entity.type;
            const entityName = entity.label;
            if ((entityType === "fish" || entityType === "crasher" || entityName === "Jellyfish" || (!ignoreShapes && entityType === 'aquaticFood')) === false) continue;           
            // Skip farming logic if not dangerous enough
            if (!aiSettings.farm && entity.dangerValue < highestDanger) continue;           
            // Position checks - more precise distance check
            /*if (!aiSettings.BLIND) {
                const dx = entity.x - myPos.x;
                const dy = entity.y - myPos.y;
                if (dx * dx + dy * dy >= sqrRange) continue;
            }*/           
            // Firing arc check
            if (firingArc != null && !view360) {
                const angleDiff = Math.abs(util.angleDifference(
                    util.getDirection(this.body, entity), 
                    firingArc[0]
                ));
                if (angleDiff >= firingArc[1]) continue;
            }            
            // If we got here, entity is valid
            highestDanger = Math.max(highestDanger, entity.dangerValue);
            output.push(entity);            
            // Early return if we found our locked target
            if (targetLockId && entity.id === targetLockId) {
                return [entity]; // Return just the locked target
            }
        }       
        //newLogs.buildList.stop();
        return output;
    }
    think(input) {
        // Early returns for manual control
        if (input.main || input.alt || 
            this.body.master.autoOverride || 
            this.body.master.master.passive || 
            this.body.master.master.invuln) {
            this.targetLock = undefined;
            return {};
        }       
        // Calculate tracking and range once
        let tracking = this.body.topSpeed;
        let range = this.body.fov;
        
        // Optimize gun loop - only need first shootable gun
        const guns = this.body.guns;
        for (let i = 0, l = guns.length; i < l; i++) {
            const gun = guns[i];
            if (gun.canShoot) {
                const v = gun.getTracking();
                tracking = v.speed;
                
                if (this.isBot) {
                    if (this.body.fov < range) range = this.body.fov;
                } else {
                    const rangeEstimate = (v.speed || 1.5) * 
                        (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                    if (rangeEstimate < range) range = rangeEstimate;
                }
                break;
            }
        }
        
        // Range sanity check
        if (range < this.body.size || !Number.isFinite(range)) {
            range = this.body.fov;
        }
        
        if (!Number.isFinite(tracking)) {
            tracking = this.body.topSpeed;
        }
        
        // Target processing timer
        if (++this.tick > 30) {
            this.tick = 0;
            
            // Bot range adjustment
            let adjustedRange = (this.body.isBot || this.body.isMothership) ? range * 0.65 : range;
            this.validTargets = this.findTargets(adjustedRange);
            
            
            // Check if current target is still valid
            if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                this.targetLock = undefined;
            }
            
            // Select new target if needed
            if (this.targetLock === undefined && this.validTargets.length) {
                this.targetLock = (this.validTargets.length === 1) ? 
                    this.validTargets[0] : 
                    nearest(this.validTargets, { x: this.body.x, y: this.body.y });
                this.tick = -5;
            }
        }
        
        // Bot damage response logic
        if (this.body.isBot) {
            const damageRef = this.body.bond || this.body;
            const currentHealth = damageRef.health.display();
            
            if (damageRef.collisionArray.length && currentHealth < this.oldHealth) {
                this.oldHealth = currentHealth;
                const collider = damageRef.collisionArray[0];
                
                if (this.validTargets.indexOf(collider) === -1) {
                    this.targetLock = collider.master.id === -1 ? 
                        collider.source : collider.master;
                }
            }
        }
        
        // Target tracking logic
        if (this.targetLock !== undefined) {
            const radial = this.targetLock.velocity;
            const diff = {
                x: this.targetLock.x - this.body.x,
                y: this.targetLock.y - this.body.y,
            };
            
            // Calculate lead on even ticks
            if (this.tick % 2 === 0) {
                this.lead = 0;
                if (!this.body.aiSettings.CHASE) {
                    this.lead = timeOfImpact(diff, radial, tracking);
                }
            }
            
            // Lead sanity check
            if (!Number.isFinite(this.lead)) {
                this.lead = 0;
            }
            
            return {
                target: {
                    x: diff.x + this.lead * radial.x,
                    y: diff.y + this.lead * radial.y,
                },
                fire: true,
                main: true
            };
        }
        
        return {};
    }
};
    ioTypes.nearestDifferentMasterDocile = class extends IO {
    constructor(body) {
        super(body);
        this.target = null;
        this.tick = 0;
        this.lead = 0;
        this.validTargets = [];
        this.oldHealth = body.health.display();
        this.targetLock = undefined;
    }

    findTargets(range) {        
        // Precalculate frequently used values
        const pos = this.body.aiSettings.SKYNET ? this.body.master.master : this.body;
        const baseRange = this.body.aiSettings.SKYNET ? range * Math.sqrt(4 / 3) : range;
        const myTeam = this.body.master.master.team;
        const aiSettings = this.body.aiSettings;
        const bodySettings = this.body.settings;
        const seeInvisible = this.body.seeInvisible;
        const isArenaCloser = this.body.isArenaCloser;
        const firingArc = this.body.firingArc;
        const view360 = aiSettings.view360;

        // Create bounding box for hashgrid query
        const searchAABB = { _AABB: {
          x1: pos.x - baseRange,
          y1: pos.y - baseRange,
          x2: pos.x + baseRange,
          y2: pos.y + baseRange,
          currentQuery: -1
        }};
      
        // Use HashGrid to get potential targets
        const potentialTargets = grid.getCollisions(searchAABB);
      
        let highestDanger = 0;
        let output = [];
        
        // Early-exit checks as constants
        const checkRanked = c.RANKED_BATTLE;
        const checkSandbox = c.SANDBOX;
        const ignoreShapes = aiSettings.IGNORE_SHAPES;
        
        // Use Set features for faster lookups if targetLock exists
        const targetLockId = this.targetLock?.id;
        
        for (const entity of potentialTargets) {
            // Skip invalid entities
            if (entity.master.master.team == myTeam || entity.team === -101 // Teams
                || entity.isDead() || entity.passive || entity.invuln || (!isArenaCloser && !seeInvisible && entity.alpha <= .5) || // Statuses
                !Number.isFinite(entity.dangerValue) || entity.dangerValue < 0 || // Danger
                (this.body.health.display() < 8/10) || // if im not at enough HP
                (checkRanked && entity.roomId !== this.body.roomId) || (checkSandbox && entity.sandboxId !== this.body.sandboxId) // Room
                ) continue;
                
            // Criteria checks
            const entityType = entity.type;
            if ((entityType === "miniboss" || entityType === "fish" || entityType === "tank" || entityType === "crasher" || (!ignoreShapes && entityType === 'food')) === false) continue;
            
            // Skip farming logic if not dangerous enough
            if (!aiSettings.farm && entity.dangerValue < highestDanger) continue;
            
            // Position checks - more precise distance check
            /*if (!aiSettings.BLIND) {
                const dx = entity.x - myPos.x;
                const dy = entity.y - myPos.y;
                if (dx * dx + dy * dy >= sqrRange) continue;
            }*/
            
            // Firing arc check
            if (firingArc != null && !view360) {
                const angleDiff = Math.abs(util.angleDifference(
                    util.getDirection(this.body, entity), 
                    firingArc[0]
                ));
                if (angleDiff >= firingArc[1]) continue;
            }
            
            // If we got here, entity is valid
            highestDanger = Math.max(highestDanger, entity.dangerValue);
            output.push(entity);
            
            // Early return if we found our locked target
            if (targetLockId && entity.id === targetLockId) {
                return [entity]; // Return just the locked target
            }
        }
        
        //newLogs.buildList.stop();
        return output;
    }

    think(input) {
        // Early returns for manual control
        if (input.main || input.alt || 
            this.body.master.autoOverride || 
            this.body.master.master.passive || 
            this.body.master.master.invuln) {
            this.targetLock = undefined;
            return {};
        }
        
        
        // Calculate tracking and range once
        let tracking = this.body.topSpeed;
        let range = this.body.fov;
        
        // Optimize gun loop - only need first shootable gun
        const guns = this.body.guns;
        for (let i = 0, l = guns.length; i < l; i++) {
            const gun = guns[i];
            if (gun.canShoot) {
                const v = gun.getTracking();
                tracking = v.speed;
                
                if (this.isBot) {
                    if (this.body.fov < range) range = this.body.fov;
                } else {
                    const rangeEstimate = (v.speed || 1.5) * 
                        (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                    if (rangeEstimate < range) range = rangeEstimate;
                }
                break;
            }
        }
        
        // Range sanity check
        if (range < this.body.size || !Number.isFinite(range)) {
            range = this.body.fov;
        }
        
        if (!Number.isFinite(tracking)) {
            tracking = this.body.topSpeed;
        }
        
        // Target processing timer
        if (++this.tick > 10) {
            this.tick = 0;
            
            // Bot range adjustment
            const adjustedRange = (this.body.isBot || this.body.isMothership) ? range * 0.65 : range;
            this.validTargets = this.findTargets(adjustedRange);
            
            //newLogs.targeting.start();
            
            // Check if current target is still valid
            if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                this.targetLock = undefined;
            }
            
            // Select new target if needed
            if (this.targetLock == null && this.validTargets.length) {
                this.targetLock = (this.validTargets.length === 1) ? 
                    this.validTargets[0] : 
                    nearest(this.validTargets, { x: this.body.x, y: this.body.y });
                this.tick = -5;
            }
        }
        
        // Bot damage response logic
        if (this.body.isBot) {
            const damageRef = this.body.bond || this.body;
            const currentHealth = damageRef.health.display();
            
            if (damageRef.collisionArray.length && currentHealth < this.oldHealth) {
                this.oldHealth = currentHealth;
                const collider = damageRef.collisionArray[0];
                
                if (this.validTargets.indexOf(collider) === -1) {
                    this.targetLock = collider.master.id === -1 ? 
                        collider.source : collider.master;
                }
            }
        }
        
        // Target tracking logic
        if (this.targetLock != null) {
            const radial = this.targetLock.velocity;
            const diff = {
                x: this.targetLock.x - this.body.x,
                y: this.targetLock.y - this.body.y,
            };
            
            // Calculate lead on even ticks
            if (this.tick % 2 === 0) {
                this.lead = 0;
                if (!this.body.aiSettings.CHASE) {
                    this.lead = timeOfImpact(diff, radial, tracking);
                }
            }
            
            // Lead sanity check
            if (!Number.isFinite(this.lead)) {
                this.lead = 0;
            }
            
            return {
                target: {
                    x: diff.x + this.lead * radial.x,
                    y: diff.y + this.lead * radial.y,
                },
                fire: true,
                main: true
            };
        }
        
        return {};
    }
};
ioTypes.nearestDifferentMasterAquaShape = class extends IO {
    constructor(body) {
        super(body);
        this.target = null;
        this.tick = 0;
        this.lead = 0;
        this.validTargets = [];
        this.oldHealth = body.health.display();
        this.targetLock = undefined;
    }

    findTargets(range) {        
        // Precalculate frequently used values
        const pos = this.body.aiSettings.SKYNET ? this.body.master.master : this.body;
        const baseRange = this.body.aiSettings.SKYNET ? range * Math.sqrt(4 / 3) : range;
        const myTeam = this.body.master.master.team;
        const aiSettings = this.body.aiSettings;
        const bodySettings = this.body.settings;
        const seeInvisible = this.body.seeInvisible;
        const isArenaCloser = this.body.isArenaCloser;
        const firingArc = this.body.firingArc;
        const view360 = aiSettings.view360;

        // Create bounding box for hashgrid query
        const searchAABB = { _AABB: {
          x1: pos.x - baseRange,
          y1: pos.y - baseRange,
          x2: pos.x + baseRange,
          y2: pos.y + baseRange,
          currentQuery: -1
        }};
      
        // Use HashGrid to get potential targets
        const potentialTargets = grid.getCollisions(searchAABB);
      
        let highestDanger = 0;
        let output = [];
        
        // Early-exit checks as constants
        const checkRanked = c.RANKED_BATTLE;
        const checkSandbox = c.SANDBOX;
        const ignoreShapes = aiSettings.IGNORE_SHAPES;
        
        // Use Set features for faster lookups if targetLock exists
        const targetLockId = this.targetLock?.id;
        
        for (const entity of potentialTargets) {
            // Skip invalid entities
            if (entity.master.master.team == myTeam || entity.team === -101 // Teams
                || entity.isDead() || entity.passive || entity.invuln || (!isArenaCloser && !seeInvisible && entity.alpha <= .5) || // Statuses
                !Number.isFinite(entity.dangerValue) || entity.dangerValue < 0 || // Danger
                (checkRanked && entity.roomId !== this.body.roomId) || (checkSandbox && entity.sandboxId !== this.body.sandboxId) // Room
                ) continue;
                
            // Type checks
            const entityType = entity.type;
            if ((!ignoreShapes && entityType === 'aquaticFood') === false) continue;
            
            // Skip farming logic if not dangerous enough
            if (!aiSettings.farm && entity.dangerValue < highestDanger) continue;
            
            // Position checks - more precise distance check
            /*if (!aiSettings.BLIND) {
                const dx = entity.x - myPos.x;
                const dy = entity.y - myPos.y;
                if (dx * dx + dy * dy >= sqrRange) continue;
            }*/
            
            // Firing arc check
            if (firingArc != null && !view360) {
                const angleDiff = Math.abs(util.angleDifference(
                    util.getDirection(this.body, entity), 
                    firingArc[0]
                ));
                if (angleDiff >= firingArc[1]) continue;
            }
            
            // If we got here, entity is valid
            highestDanger = Math.max(highestDanger, entity.dangerValue);
            output.push(entity);
            
            // Early return if we found our locked target
            if (targetLockId && entity.id === targetLockId) {
                return [entity]; // Return just the locked target
            }
        }
        
        //newLogs.buildList.stop();
        return output;
    }

    think(input) {
        // Early returns for manual control
        if (input.main || input.alt || 
            this.body.master.autoOverride || 
            this.body.master.master.passive || 
            this.body.master.master.invuln) {
            this.targetLock = undefined;
            return {};
        }
        
        
        // Calculate tracking and range once
        let tracking = this.body.topSpeed;
        let range = this.body.fov;
        
        // Optimize gun loop - only need first shootable gun
        const guns = this.body.guns;
        for (let i = 0, l = guns.length; i < l; i++) {
            const gun = guns[i];
            if (gun.canShoot) {
                const v = gun.getTracking();
                tracking = v.speed;
                
                if (this.isBot) {
                    if (this.body.fov < range) range = this.body.fov;
                } else {
                    const rangeEstimate = (v.speed || 1.5) * 
                        (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                    if (rangeEstimate < range) range = rangeEstimate;
                }
                break;
            }
        }
        
        // Range sanity check
        if (range < this.body.size || !Number.isFinite(range)) {
            range = this.body.fov;
        }
        
        if (!Number.isFinite(tracking)) {
            tracking = this.body.topSpeed;
        }
        
        // Target processing timer
        if (++this.tick > 10) {
            this.tick = 0;
            
            // Bot range adjustment
            const adjustedRange = (this.body.isBot || this.body.isMothership) ? range * 0.65 : range;
            this.validTargets = this.findTargets(adjustedRange);
            
            //newLogs.targeting.start();
            
            // Check if current target is still valid
            if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                this.targetLock = undefined;
            }
            
            // Select new target if needed
            if (this.targetLock == null && this.validTargets.length) {
                this.targetLock = (this.validTargets.length === 1) ? 
                    this.validTargets[0] : 
                    nearest(this.validTargets, { x: this.body.x, y: this.body.y });
                this.tick = -5;
            }
        }
        
        // Bot damage response logic
        if (this.body.isBot) {
            const damageRef = this.body.bond || this.body;
            const currentHealth = damageRef.health.display();
            
            if (damageRef.collisionArray.length && currentHealth < this.oldHealth) {
                this.oldHealth = currentHealth;
                const collider = damageRef.collisionArray[0];
                
                if (this.validTargets.indexOf(collider) === -1) {
                    this.targetLock = collider.master.id === -1 ? 
                        collider.source : collider.master;
                }
            }
        }
        
        // Target tracking logic
        if (this.targetLock != null) {
            const radial = this.targetLock.velocity;
            const diff = {
                x: this.targetLock.x - this.body.x,
                y: this.targetLock.y - this.body.y,
            };
            
            // Calculate lead on even ticks
            if (this.tick % 2 === 0) {
                this.lead = 0;
                if (!this.body.aiSettings.CHASE) {
                    this.lead = timeOfImpact(diff, radial, tracking);
                }
            }
            
            // Lead sanity check
            if (!Number.isFinite(this.lead)) {
                this.lead = 0;
            }
            
            return {
                target: {
                    x: diff.x + this.lead * radial.x,
                    y: diff.y + this.lead * radial.y,
                },
                fire: true,
                main: true
            };
        }
        
        return {};
    }
};
//test mine
ioTypes.nearestEntity = class extends IO {
    // this is a bit of a hack, but it works
    constructor(body) {
        super(body);
        this.target = null;
        this.tick = 0;
        this.lead = 0;
        this.validTargets = [];
        this.oldHealth = body.health.display();
    }
    findTargets(range) {
        //newLogs.buildList.start();
        let highestDanger = 0,
            output = [],
            myPos = {
                x: this.body.x,
                y: this.body.y
            },
            masterPos = {
                x: this.body.master.master.x,
                y: this.body.master.master.y
            },
            sqrRange = range * range,
            sqrRangeMaster = range * range * 4 / 3;
        /*let targetable = targetingGrid.queryForCollisionPairs({
            id: this.body.id,
            _AABB: targetingGrid.getAABB({
                x: myPos.x,
                y: myPos.y,
                size: sqrRange
            })
        });*/
        for (let i = 0, l = targetableEntities.length; i < l; i++) {
            let entity = targetableEntities[i];
            if (
                (
                    //entity.master.master.team !== this.body.master.master.team &&
                    (this.body.aiSettings.farm || entity.dangerValue >= highestDanger) &&
                    (!c.RANKED_BATTLE || (entity.roomId === this.body.roomId)) &&
                    (!c.SANDBOX || (entity.sandboxId === this.body.sandboxId)) &&
                    (this.body.seeInvisible || this.body.isArenaCloser || entity.alpha > 0.5) &&
                    (this.body.settings.targetPlanes ? (entity.isPlane && (entity.type === "drone" || entity.type === "minion")) : (entity.type === "miniboss" || entity.type === "tank" || entity.type === "crasher" || (!this.body.aiSettings.IGNORE_SHAPES && entity.type === 'food'))) &&
                    (this.body.aiSettings.BLIND || ((entity.x - myPos.x) * (entity.x - myPos.x) < sqrRange && (entity.y - myPos.y) * (entity.y - myPos.y) < sqrRange)) &&
                    (this.body.aiSettings.SKYNET || ((entity.x - masterPos.x) * (entity.x - masterPos.x) < sqrRangeMaster && (entity.y - masterPos.y) * (entity.y - masterPos.y) < sqrRangeMaster))
                ) && (
                    this.body.firingArc == null ||
                    this.body.aiSettings.view360 ||
                    Math.abs(util.angleDifference(util.getDirection(this.body, entity), this.body.firingArc[0])) < this.body.firingArc[1]
                )
            ) {
                highestDanger = entity.dangerValue;
                output.push(entity);
                if (this.targetLock && entity.id === this.targetLock.id) {
                    break;
                }
            }
        }
        //newLogs.buildList.stop();
        return output;
    }
    think(input) {
        if (input.main || input.alt || this.body.master.autoOverride || this.body.master.master.passive || this.body.master.master.invuln/*|| this.body.master.master.isMothership*/) {//mine (btw the mothership)
            this.targetLock = undefined;
            return {};
        }
        //newLogs.targeting.start();
        let tracking = this.body.topSpeed,
            range = this.body.fov;
        for (let i = 0, l = this.body.guns.length; i < l; i++) {
            if (this.body.guns[i].canShoot) {
                let v = this.body.guns[i].getTracking();
                tracking = v.speed;
                if (this.isBot) {
                    if (this.body.fov < range) {
                        range = this.body.fov;
                    }
                } else {
                    let fuck = (v.speed || 1.5) * (v.range < (this.body.size * 2) ? this.body.fov : v.range);
                    if (fuck < range) {
                        range = fuck;
                    }
                }
                break;
            }
        }
        if (range < this.body.size || !Number.isFinite(range)) {
            range = this.body.fov;
        }
        !Number.isFinite(tracking) && (tracking = this.body.topSpeed);
        // OK, now let's try reprocessing the targets!
        this.tick++;
        if (this.tick > 10) {
            this.tick = 0;
            //newLogs.targeting.stop();
            this.validTargets = this.findTargets((this.body.isBot || this.body.isMothership) ? range * .65 : range);
            //newLogs.targeting.start();
            if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                this.targetLock = undefined;
            }
            if (this.targetLock == null && this.validTargets.length) {
                this.targetLock = (this.validTargets.length === 1) ? this.validTargets[0] : nearest(this.validTargets, {
                    x: this.body.x,
                    y: this.body.y
                });
                this.tick = -5;
            }
        }
        if (this.body.isBot) {
            let damageRef = this.body.bond || this.body;
            if (damageRef.collisionArray.length && damageRef.health.display() < this.oldHealth) {
                this.oldHealth = damageRef.health.display();
                if (this.validTargets.indexOf(damageRef.collisionArray[0]) === -1) {
                    this.targetLock = damageRef.collisionArray[0].master.id === -1 ? damageRef.collisionArray[0].source : damageRef.collisionArray[0].master;
                }
            }
        }
        if (this.targetLock != null) {
            let radial = this.targetLock.velocity,
                diff = {
                    x: this.targetLock.x - this.body.x,
                    y: this.targetLock.y - this.body.y,
                };
            if (this.tick % 2 === 0) {
                this.lead = 0;
                if (!this.body.aiSettings.CHASE) {
                    let toi = timeOfImpact(diff, radial, tracking);
                    this.lead = toi;
                }
            }
            if (!Number.isFinite(this.lead)) {
                this.lead = 0;
            }
            //newLogs.targeting.stop();
            return {
                target: {
                    x: diff.x + this.lead * radial.x,
                    y: diff.y + this.lead * radial.y,
                },
                fire: true,
                main: true
            };
        }
        //newLogs.targeting.stop();
        return {};
    }
}
    ioTypes.targetOwnTeam = class extends IO {
    constructor(body) {
        super(body);
        this.targetLock = undefined;
        this.tick = ran.irandom(30);
        this.lead = 0;
        this.validTargets = this.buildList(body.fov);
        this.oldHealth = body.health.display();
    }
    validate(e, m, mm, sqrRange, sqrRangeMaster) {
        return (e.health.amount > 0) &&
        (!isNaN(e.dangerValue)) &&
        (!e.invuln && !e.master.master.passive && !this.body.master.master.passive) &&
        (e.master.master.team == this.body.master.master.team) &&
        (e.master.master.health.display() < 8/10) &&
        //(e.master.master.team !== -101) &&
        (!e.master.master.isDominator) &&
        (this.body.aiSettings.seeInvisible || this.body.isArenaCloser || e.alpha > 0.5) &&
        (e.type === "miniboss" || e.type === "tank" || e.type === "drone" || e.type === "minion") &&
        (this.body.aiSettings.BLIND || ((e.x - m.x) * (e.x - m.x) < sqrRange && (e.y - m.y) * (e.y - m.y) < sqrRange)) &&
        (this.body.aiSettings.SKYNET || ((e.x - mm.x) * (e.x - mm.x) < sqrRangeMaster && (e.y - mm.y) * (e.y - mm.y) < sqrRangeMaster));
    }
    buildList(range) {
        // Establish whom we judge in reference to
        let mostDangerous = 0,
            keepTarget = false;
        // Filter through everybody...
        let out = entities.filter(e => {
            // Only look at those within our view, and our parent's view, not dead, not invisible, not our kind, not a bullet/trap/block etc
            return this.validate(e, {
                    x: this.body.x,
                    y: this.body.y,
                }, {
                    x: this.body.master.master.x,
                    y: this.body.master.master.y,
                }, range * range, range * range * 4 / 3);
        }).filter((e) => {
            // Only look at those within range and arc (more expensive, so we only do it on the few)
            if (this.body.firingArc == null || this.body.aiSettings.view360 || Math.abs(util.angleDifference(util.getDirection(this.body, e), this.body.firingArc[0])) < this.body.firingArc[1]) {
                mostDangerous = Math.max(e.dangerValue, mostDangerous);
                return true;
            }
            return false;
        }).filter((e) => {
            // Only return the highest tier of danger
            if (this.body.aiSettings.farm || e.dangerValue === mostDangerous) {
                if (this.targetLock && e.id === this.targetLock.id) keepTarget = true;
                return true;
            }
            return false;
        });
        // Reset target if it's not in there
        if (!keepTarget) this.targetLock = undefined;
        return out;
    }
    think(input) {
        // Override target lock upon other commands
        if (input.main || input.alt || this.body.master.autoOverride) {
            this.targetLock = undefined;
            return {};
        }
        // Otherwise, consider how fast we can either move to ram it or shoot at a potiential target.
        let tracking = this.body.topSpeed,
            range = this.body.fov;
        // Use whether we have functional guns to decide
        for (let i = 0; i < this.body.guns.length; i++) {
            if (this.body.guns[i].canShoot && !this.body.aiSettings.SKYNET) {
                let v = this.body.guns[i].getTracking();
                if (v.speed == 0 || v.range == 0) continue;
                tracking = v.speed;
                //if (!this.body.isPlayer || this.body.type === "miniboss" || this.body.master !== this.body) range = 640 * this.body.FOV;
                //else range = Math.min(range, (v.speed || 1) * (v.range || 90));
                range = Math.min(range, (v.speed || 1.5) * (v.range < (this.body.size * 2) ? this.body.fov : v.range));
                break;
            }
        }
        if (!Number.isFinite(tracking)) {
            tracking = this.body.topSpeed + .01;
        }
        if (!Number.isFinite(range)) {
            range = 640 * this.body.FOV;
        }
        // Check if my target's alive
        if (this.targetLock) {
            if (!this.validate(this.targetLock, {
                    x: this.body.x,
                    y: this.body.y,
                }, {
                    x: this.body.master.master.x,
                    y: this.body.master.master.y,
                }, range * range, range * range * 4 / 3)) {
                this.targetLock = undefined;
                this.tick = 100;
            }
        }
        // Think damn hard
        if (this.tick++ > 15 * room.speed) {
            this.tick = 0;
            this.validTargets = this.buildList(range);
            // Ditch our old target if it's invalid
            if (this.targetLock && this.validTargets.indexOf(this.targetLock) === -1) {
                this.targetLock = undefined;
            }
            // Lock new target if we still don't have one.
            if (this.targetLock == null && this.validTargets.length) {
                this.targetLock = (this.validTargets.length === 1) ? this.validTargets[0] : nearest(this.validTargets, {
                    x: this.body.x,
                    y: this.body.y
                });
                this.tick = -90;
            }
        }
        // Lock onto whoever's shooting me.
        // let damageRef = (this.body.bond == null) ? this.body : this.body.bond
        // if (damageRef.collisionArray.length && damageRef.health.display() < this.oldHealth) {
        //     this.oldHealth = damageRef.health.display()
        //     if (this.validTargets.indexOf(damageRef.collisionArray[0]) === -1) {
        //         this.targetLock = (damageRef.collisionArray[0].master.id === -1) ? damageRef.collisionArray[0].source : damageRef.collisionArray[0].master
        //     }
        // }
        // Consider how fast it's moving and shoot at it
        if (this.targetLock != null) {
            let radial = this.targetLock.velocity;
            let diff = {
                x: this.targetLock.x - this.body.x,
                y: this.targetLock.y - this.body.y,
            }
            /// Refresh lead time
            if (this.tick % 4 === 0) {
                this.lead = 0
                // Find lead time (or don't)
                if (!this.body.aiSettings.chase) {
                    let toi = timeOfImpact(diff, radial, tracking)
                    this.lead = toi
                }
            }
            if (!Number.isFinite(this.lead)) {
                this.lead = 0;
            }
            // And return our aim
            return {
                target: {
                    x: diff.x + this.lead * radial.x,
                    y: diff.y + this.lead * radial.y,
                },
                fire: true,
                main: true
            };
        }
        return {};
    }
}
    ioTypes.roamWhenIdle = class extends IO {
        constructor(body) {
            super(body);
            this.goal = room.randomType("norm");;
        }
        think(input) {
            if (input.main || input.alt || this.body.master.autoOverride) {
                return {};
            }
            while (util.getDistance(this.goal, this.body) < this.body.SIZE * 2) {
                this.goal = room.randomType(Math.random() > .8 ? "nest" : "norm");
            }
            if (this.body.aiSettings.isDigger) return {
                goal: this.goal, target: {
                    x: -(this.body.x - this.goal.x),
                    y: -(this.body.y - this.goal.y)
                }
            };
            else return {
                goal: this.goal
            };
        }
    }
    ioTypes.roamWhenIdleWater = class extends IO {
        constructor(body) {
            super(body);
            this.goal = room.randomType("watr" || "barn");
        }
        think(input) {
            if (input.main || input.alt || this.body.master.autoOverride) {
                return {};
            }
            while (util.getDistance(this.goal, this.body) < this.body.SIZE * 2) {
                this.goal = room.randomType(Math.random() > .8 ? "barn" : "watr");
            }
            if (this.body.aiSettings.isDigger) return {
                goal: this.goal, target: {
                    x: -(this.body.x - this.goal.x),
                    y: -(this.body.y - this.goal.y)
                }
            };
            else return {
                goal: this.goal
            };
        }
    }
      ioTypes.wanderWhenIdle = class extends IO {
        constructor(body) {
            super(body);
            this.goal = room.randomType("bas1");;
        }
        think(input) {
            if (input.main || input.alt || this.body.master.autoOverride) {
                return {};
            }
            while (util.getDistance(this.goal, this.body) < this.body.SIZE * 2) {
                this.goal = room.randomType(Math.random() > .8 ? "bas1" : "bas1");
            }
            if (this.body.aiSettings.isDigger) return {
                goal: this.goal, target: {
                    x: -(this.body.x - this.goal.x),
                    y: -(this.body.y - this.goal.y)
                }
            };
            else return {
                goal: this.goal
            };
        }
    }
    ioTypes.minion = class extends IO {
        constructor(body) {
            super(body);
            this.turnwise = 1;
        }
        think(input) {
            if (input.target != null && (input.alt || input.main)) {
                let sizeFactor = Math.sqrt(this.body.master.size / this.body.master.SIZE),
                    fovFactor = this.body.master.FOV * 2.2,
                    leash = 60 * sizeFactor,
                    orbit = 130 * sizeFactor * fovFactor,
                    repel = 135 * sizeFactor,
                    goal,
                    power = 1,
                    target = new Vector(input.target.x, input.target.y);
                if (input.alt) {
                    if (target.length < leash) goal = {
                        x: this.body.x + target.x,
                        y: this.body.y + target.y
                    };
                    else if (target.length < repel) {
                        let dir = -this.turnwise * target.direction + Math.PI / 5;
                        goal = {
                            x: this.body.x + Math.cos(dir),
                            y: this.body.y + Math.sin(dir)
                        };
                    } else goal = {
                        x: this.body.x - target.x,
                        y: this.body.y - target.y
                    };
                } else if (input.main) {
                    let dir = this.turnwise * target.direction + .01;
                    goal = {
                        x: this.body.x + target.x - orbit * Math.cos(dir),
                        y: this.body.y + target.y - orbit * Math.sin(dir)
                    };
                    if (Math.abs(target.length - orbit) < this.body.size * 2) power = .7;
                }
                return {
                    goal: goal,
                    power: power
                };
            }
        }
    }
    ioTypes.minionNoRepel = class extends IO {
        constructor(body) {
            super(body);
            this.turnwise = 1;
        }
        think(input) {
            if (input.target != null && input.main) {
                let sizeFactor = Math.sqrt(this.body.master.size / this.body.master.SIZE),
                    orbit = 120 * sizeFactor,
                    goal,
                    power = 1,
                    target = new Vector(input.target.x, input.target.y);
                if (input.main) {
                    let dir = this.turnwise * target.direction + .01;
                    goal = {
                        x: this.body.x + target.x - orbit * Math.cos(dir),
                        y: this.body.y + target.y - orbit * Math.sin(dir)
                    };
                    if (Math.abs(target.length - orbit) < this.body.size * 2) power = .7;
                }
                return {
                    goal: goal,
                    power: power
                };
            }
        }
    }
    ioTypes.hangOutNearMaster = class extends IO {
        constructor(body) {
            super(body);
            this.acceptsFromTop = false;
            this.orbit = 30;
            this.currentGoal = {
                x: this.body.source.x,
                y: this.body.source.y
            };
            this.timer = 0;
        }
        think(input) {
            if (this.body.source !== this.body) {
                let bound1 = this.orbit * .8 + this.body.source.size + this.body.size,
                    bound2 = this.orbit * 1.5 + this.body.source.size + this.body.size,
                    dist = util.getDistance(this.body, this.body.source) + Math.PI / 8,
                    output = {
                        target: {
                            x: this.body.velocity.x,
                            y: this.body.velocity.y
                        },
                        goal: this.currentGoal,
                        power: undefined
                    };
                if (dist > bound2 || this.timer > 30) {
                    this.timer = 0;
                    let dir = util.getDirection(this.body, this.body.source) + Math.PI * ran.random(.5),
                        len = ran.randomRange(bound1, bound2),
                        x = this.body.source.x - len * Math.cos(dir),
                        y = this.body.source.y - len * Math.sin(dir);
                    this.currentGoal = {
                        x: x,
                        y: y
                    };
                }
                if (dist < bound2) {
                    output.power = .15;
                    if (ran.chance(.3)) this.timer++;
                }
                return output;
            }
        }
    }
        ioTypes.hangOutNearMaster2 = class extends IO {
        constructor(body) {
            super(body);
            this.acceptsFromTop = false;
            this.orbit = 40;
            this.currentGoal = {
                x: this.body.source.x,
                y: this.body.source.y
            };
            this.timer = 0;
        }
        think(input) {
            if (this.body.source !== this.body) {
                let bound1 = this.orbit * 3.75 + this.body.source.size + this.body.size,
                    bound2 = this.orbit * 4.25 + this.body.source.size + this.body.size,
                    dist = util.getDistance(this.body, this.body.source) + Math.PI / 8,
                    output = {
                        target: {
                            x: this.body.velocity.x,
                            y: this.body.velocity.y
                        },
                        goal: this.currentGoal,
                        power: undefined
                    };
                if (dist > bound2 || this.timer > 30) {
                    this.timer = 0;
                    let dir = util.getDirection(this.body, this.body.source) + Math.PI * ran.random(.5),
                        len = ran.randomRange(bound1, bound2),
                        x = this.body.source.x - len * Math.cos(dir),
                        y = this.body.source.y - len * Math.sin(dir);
                    this.currentGoal = {
                        x: x,
                        y: y
                    };
                }
                if (dist < bound2) {
                    output.power = .15;
                    if (ran.chance(.3)) this.timer++;
                }
                return output;
            }
        }
    }
    ioTypes.wayPoint = class extends IO {
        constructor(body, wayPoints) {
            super(body);
            this.wayPointIndex = 0
            this.wayPoints = wayPoints
        }
        think(input) {
            let x = this.wayPoints[this.wayPointIndex]
            let y = this.wayPoints[this.wayPointIndex + 1]
            let output = {
                target: {
                    x: x,
                    y: y
                },
                goal: { x, y },
                power: 1
            };

            if (util.getDistance(this, { x, y }) < 3) {
                if (this.wayPointIndex + 2 >= this.wayPoints.length) {
                    this.wayPointIndex = 0
                } else {
                    this.wayPointIndex += 2
                }
            }
            return output
        }
    }
    ioTypes.orbitAroundPlayer = class extends IO {
        constructor(body) {
            super(body);
            this.direction = this.body.velocity.direction;
        }
        think(input) {
            let rad = 4;
            if (this.body.source.control.main) rad += 2;
            else if (this.body.source.control.alt) rad -= 2;
            this.orbit = this.body.source.size * (rad);
            let target = new Vector(this.body.source.x, this.body.source.y);
            let dir = (this.direction += 0.15);
            return {
                goal: {
                    x: target.x - this.orbit * Math.cos(dir),
                    y: target.y - this.orbit * Math.sin(dir),
                },
                power: 15,
            };
        }
    }
    ioTypes.circleTarget = class extends IO {
        constructor(body) {
            super(body);
        }

        think(input) {
            if (input.target != null && (input.alt || input.main)) {
                let orbit = 280;
                let goal;
                let power = 5;
                let target = new Vector(input.target.x, input.target.y);
                let dir = target.direction + power;
                if (input.alt) {
                    orbit /= 2
                    this.body.range -= 0.5
                }
                // Orbit point
                goal = {
                    x: this.body.x + target.x - orbit * Math.cos(dir),
                    y: this.body.y + target.y - orbit * Math.sin(dir),
                };
                return {
                    goal: goal,
                    power: power,
                };
            }
        }
    }
    ioTypes.spin = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a += .05;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.slowSpin = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a += .025;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }

    ioTypes.slowSpineeeee = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a += .0025;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
        ioTypes.slowSpinWeb = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a += .00125;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.slowSpinReverse = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a -= .025;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.slowSpinReverse2 = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a -= .01;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.slowSpin2 = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            this.body.facing += .00375;
            return {
                target: {
                    x: Math.cos(this.body.facing),
                    y: Math.sin(this.body.facing)
                },
                main: true
            };
        }
    }
    ioTypes.fastSpin = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a += .072;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.heliSpin = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a += Math.PI / 5.5;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.reverseSpin = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a -= .05;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.reverseFastSpin = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a -= .072;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.reverseHeliSpin = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            this.a -= Math.PI / 5.5;
            let offset = 0;
            if (this.body.bond != null) offset = this.body.bound.angle;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset)
                },
                main: true
            };
        }
    }
    ioTypes.dontTurn = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            return {
                target: {
                    x: 1,
                    y: 0
                },
                main: true
            };
        }
    }
    ioTypes.dontTurn2 = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            return {
                target: {
                    x: 0,
                    y: 1
                },
                main: true
            };
        }
    }
    ioTypes.spinWhileIdle = class extends IO {
        constructor(b) {
            super(b);
            this.a = 0;
        }
        think(input) {
            if (input.target) {
                this.a = Math.atan2(input.target.y, input.target.x);
                return input;
            }
            this.a += .015;
            return {
                target: {
                    x: Math.cos(this.a),
                    y: Math.sin(this.a)
                },
                main: true
            };
        }
    }
    ioTypes.fleeAtLowHealth = class extends IO {
        constructor(b) {
            super(b);
            this.fear = util.clamp(ran.gauss(.7, .15), .1, .9) * .75;
        }
        think(input) {
            if (input.fire && input.target != null && this.body.health.amount < this.body.health.max * this.fear) return {
                goal: {
                    x: this.body.x - input.target.x,
                    y: this.body.y - input.target.y
                }
            };
        }
    }
    ioTypes.fleeAtLowHealth2 = class extends IO {
        constructor(b) {
            super(b);
            this.fear = util.clamp(ran.gauss(.7, .15), .1, .9) * .45;
        }
        think(input) {
            if (input.fire && input.target != null && this.body.health.amount < this.body.health.max * this.fear) return {
                goal: {
                    x: this.body.x - input.target.x,
                    y: this.body.y - input.target.y
                },
                target: {
                    x: this.body.velocity.x,
                    y: this.body.velocity.y
                }
            };
        }
    }
    ioTypes.orion = class extends IO {
        constructor(b) {
            super(b);
            this.turnwise = 1;
            this.r = 0;
            this.turnover = false;
        }
        think(input) {
            let sizeFactor = Math.sqrt(this.body.master.size / this.body.master.SIZE),
                orbit = 45 * sizeFactor,
                power = 1;
            this.body.x += this.body.source.velocity.x;
            this.body.y += this.body.source.velocity.y;
            let dir = this.turnwise * util.getDirection(this.body, this.body.source) + .01,
                goal = {
                    x: this.body.source.x - orbit * Math.cos(dir),
                    y: this.body.source.y - orbit * Math.sin(dir)
                };
            return {
                goal: goal,
                power: power
            };
        }
    }
    ioTypes.orion2 = class extends IO {
        constructor(b) {
            super(b);
            this.turnwise = 1;
            this.r = 0;
            this.turnover = false;
        }
        think(input) {
            let sizeFactor = Math.sqrt(this.body.master.size / this.body.master.SIZE),
                orbit = 15 * sizeFactor,
                power = 1;
            this.body.x += this.body.source.velocity.x;
            this.body.y += this.body.source.velocity.y;
            let dir = this.turnwise * util.getDirection(this.body, this.body.source),
                goal = {
                    x: this.body.source.x - orbit * Math.cos(dir) + 50,
                    y: this.body.source.y - orbit * Math.sin(dir) + 50
                };
            return {
                goal: goal,
                power: power
            };
        }
    }
    ioTypes.sizething = class extends IO {
        constructor(b) {
            super(b);
            this.div = 20;
            this.origS = 230;
            this.time = this.div;
        }
        think(input) {
            this.body.SIZE = this.time * this.origS * (1 / this.div);
            if (this.body.SIZE <= 0) this.body.kill();
            this.time--;
        }
    }
    ioTypes.rlyfastspin2 = class extends IO {
        constructor(b) {
            super(b);
            this.a = 360 * Math.random();
            this.b = 31 * (Math.sin(Math.PI * Math.round(-1 + Math.random()) + Math.PI / 2));
        }
        think(input) {
            this.a += this.b * Math.PI / 180;
            let offset = 0;
            if (this.body.bond != null) offset = 0;
            return {
                target: {
                    x: Math.cos(this.a + offset),
                    y: Math.sin(this.a + offset),
                },
                main: true,
            };
        }
    }
    ioTypes.mRot = class extends IO {
        constructor(b) {
            super(b);
        }
        think(input) {
            return {
                target: {
                    x: this.body.master.control.target.x,
                    y: this.body.master.control.target.y,
                },
                main: true,
            };
        }
    }
    ioTypes.sineA = class extends IO {
        constructor(b) {
            super(b);
            this.phase = 5;
            this.wo = this.body.master.facing;
        }
        think(input) {
            this.phase += .5;
            setTimeout(() => {
            this.body.x += this.phase * Math.cos(this.wo) - 10 * Math.cos(this.phase) * Math.sin(this.wo);
            this.body.y += this.phase * Math.sin(this.wo) + 10 * Math.cos(this.phase) * Math.cos(this.wo);
            }, 150);
            return {
                power: 1
            };
        }
    }
    ioTypes.curveBack = class extends IO {
        constructor(b) {
            super(b);
            this.phase = 5;
            this.wo = this.body.master.facing;
        }
        think(input) {
            this.phase += 2;
            //this.body.x += this.phase * Math.cos(-2) + 10 * Math.sin(this.wo);
            this.body.y += this.phase * Math.sin(-7) + 10 * Math.cos(this.wo);
            return {
                power: 1
            };
        }
    };
    ioTypes.curveBack2 = class extends IO {
        constructor(b) {
            super(b);
            this.phase = 5;
            this.wo = this.body.master.facing;
        }
        think(input) {
            this.phase += 2;
            //this.body.x += this.phase * Math.cos(-2) + 10 * Math.sin(this.wo);
            this.body.y -= this.phase * Math.sin(-7) + 10 * Math.cos(this.wo);
            return {
                power: 1
            };
        }
    };
    ioTypes.sineB = class extends IO {
        constructor(b) {
            super(b);
            this.phase = 5;
            this.wo = this.body.master.facing;
        }
        think(input) {
            this.phase += .5;
            setTimeout(() => {
            this.body.x += this.phase * Math.cos(this.wo) + 10 * Math.cos(this.phase) * Math.sin(this.wo);
            this.body.y += this.phase * Math.sin(this.wo) - 10 * Math.cos(this.phase) * Math.cos(this.wo);
            }, 150);
        }
    }
    ioTypes.sineC = class extends IO {
        constructor(b) {
            super(b);
            this.phase = -5;
            this.wo = this.body.master.facing;
        }
        think(input) {
            this.phase -= .5;
            setTimeout(() => {
            this.body.x += this.phase * Math.cos(this.wo) + 10 * Math.cos(this.phase) * Math.sin(this.wo);
            this.body.y += this.phase * Math.sin(this.wo) - 10 * Math.cos(this.phase) * Math.cos(this.wo);
            }, 150);
            return {
                power: 1
            };
        }
    }
    ioTypes.sineD = class extends IO {
        constructor(b) {
            super(b);
            this.phase = -5;
            this.wo = this.body.master.facing;
        }
        think(input) {
            this.phase -= .5;
            setTimeout(() => {
            this.body.x += this.phase * Math.cos(this.wo) - 10 * Math.cos(this.phase) * Math.sin(this.wo);
            this.body.y += this.phase * Math.sin(this.wo) + 10 * Math.cos(this.phase) * Math.cos(this.wo);
            }, 150);
        }
    }
    ioTypes.portal = class extends IO {
        constructor(body) {
            super(body);
            this.myGoal = {
                x: body.master.control.target.x + body.master.x,
                y: body.master.control.target.y + body.master.y
            };
        }
        think() {
            this.body.x = this.myGoal.x;
            this.body.y = this.myGoal.y;
            return {
                goal: {
                    x: this.myGoal.x,
                    y: this.myGoal.y
                }
            };
        }
    }
    const skcnv = {
        rld: 0,
        pen: 1,
        str: 2,
        dam: 3,
        spd: 4,
        shi: 5,
        atk: 6,
        hlt: 7,
        rgn: 8,
        mob: 9
    };
    const levelers = [
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
        13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
        23, 24, 25, 26, 27, 28, 29, 30, 32, 34,
        36, 38, 40, 42, 44, 46, 48, 50, 55, 60,/*mine after this*/ //61, 63, 65, 67, 70, 73, 76, 79, 82, 85, 89, 93, 97, 98, 99,100,100,100
    ];
    const curve = (() => {
        const make = x => Math.log(4 * x + 1) / Math.log(5);
        let a = [];
        for (let i = 0; i < c.MAX_SKILL * 2; i++) a.push(make(i / c.MAX_SKILL));
        return x => a[x * c.MAX_SKILL];
    })();
    const apply = (f, x) => x < 0 ? 1 / (1 - x * f) : f * x + 1;
    class Skill {
        constructor(inital = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) {
            this.raw = inital;
            this.caps = [];
            this.setCaps([c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL, c.MAX_SKILL]);
            this.name = ["Reload", "Bullet Penetration", "Bullet Health", "Bullet Damage", "Bullet Speed", "Shield Capacity", "Body Damage", "Max Health", "Shield Regeneration", "Movement Speed"];
            this.atk = 0;
            this.hlt = 0;
            this.spd = 0;
            this.str = 0;
            this.pen = 0;
            this.dam = 0;
            this.rld = 0;
            this.mob = 0;
            this.rgn = 0;
            this.shi = 0;
            this.rst = 0;
            this.brst = 0;
            this.ghost = 0;
            this.acl = 0;
            this.reset();
        }
        reset() {
            this.points = 0;
            this.score = 0;
            this.deduction = 0;
            this.level = 0;
            this.update();
            this.maintain();
        }
        /*update() {
            for (let i = 0; i < 10; i++)
                if (this.raw[i] > this.caps[i]) {
                    this.points += this.raw[i] - this.caps[i];
                    this.raw[i] = this.caps[i];
                }
            let attrib = [];
            for (let i = 0; i < 10; i++) {
                attrib[i] = curve(this.raw[i] / c.MAX_SKILL);
            }
            this.rld = Math.pow(0.5, attrib[skcnv.rld]);
            this.pen = apply(2.5, attrib[skcnv.pen]);
            this.str = apply(2.3, attrib[skcnv.str]);
            this.dam = apply(3, attrib[skcnv.dam]);
            this.spd = 0.5 + apply(1.5, attrib[skcnv.spd]);
            this.acl = apply(0.5, attrib[skcnv.rld]);
            this.rst = 0.5 * attrib[skcnv.str] + 2.5 * attrib[skcnv.pen];
            this.ghost = attrib[skcnv.pen];
            this.shi = c.GLASS_HEALTH_FACTOR * apply(3 / c.GLASS_HEALTH_FACTOR - 1, attrib[skcnv.shi]);
            this.atk = apply(0.021, attrib[skcnv.atk]);
            this.hlt = c.GLASS_HEALTH_FACTOR * apply(2 / c.GLASS_HEALTH_FACTOR - 1, attrib[skcnv.hlt]);
            this.mob = apply(0.8, attrib[skcnv.mob]);
            this.rgn = apply(25, attrib[skcnv.rgn]);
            this.brst = 0.3 * (0.5 * attrib[skcnv.atk] + 0.5 * attrib[skcnv.hlt] + attrib[skcnv.rgn]);
        }*/
        update() {
            for (let i = 0; i < 10; i++)
                if (this.raw[i] > this.caps[i]) {
                    this.points += this.raw[i] - this.caps[i];
                    this.raw[i] = this.caps[i];
                }
            let attrib = [];
            for (let i = 0; i < 10; i++) {
                attrib[i] = curve(this.raw[i] / c.MAX_SKILL);
            }
            this.rld = Math.pow(0.5, attrib[skcnv.rld]);
            this.pen = apply(2.5, attrib[skcnv.pen]);
            this.str = apply(3, attrib[skcnv.str]);
            this.dam = apply(3.4, attrib[skcnv.dam]);
            this.spd = 0.5 + apply(1.5, attrib[skcnv.spd]);
            this.acl = apply(0.5, attrib[skcnv.rld]);
            this.rst = 0.5 * attrib[skcnv.str] + 2.5 * attrib[skcnv.pen];
            this.ghost = attrib[skcnv.pen];
            this.shi = c.GLASS_HEALTH_FACTOR * apply(3 / c.GLASS_HEALTH_FACTOR - 1, attrib[skcnv.shi]);
            this.atk = apply(0.027, attrib[skcnv.atk]);
            this.hlt = c.GLASS_HEALTH_FACTOR * apply(2 / c.GLASS_HEALTH_FACTOR - 1, attrib[skcnv.hlt]);
            this.mob = apply(0.8, attrib[skcnv.mob]);
            this.rgn = apply(25, attrib[skcnv.rgn]);
            this.brst = 0.3 * (0.5 * attrib[skcnv.atk] + 0.5 * attrib[skcnv.hlt] + attrib[skcnv.rgn]);
        }
        set(thing) {
            this.raw[0] = thing[0];
            this.raw[1] = thing[1];
            this.raw[2] = thing[2];
            this.raw[3] = thing[3];
            this.raw[4] = thing[4];
            this.raw[5] = thing[5];
            this.raw[6] = thing[6];
            this.raw[7] = thing[7];
            this.raw[8] = thing[8];
            this.raw[9] = thing[9];
            this.update();
        }
        setCaps(thing) {
            this.caps[0] = thing[0];
            this.caps[1] = thing[1];
            this.caps[2] = thing[2];
            this.caps[3] = thing[3];
            this.caps[4] = thing[4];
            this.caps[5] = thing[5];
            this.caps[6] = thing[6];
            this.caps[7] = thing[7];
            this.caps[8] = thing[8];
            this.caps[9] = thing[9];
            this.update();
        }
        maintain() {
            if (this.level < c.SKILL_CAP && this.score - this.deduction >= this.levelScore) {
                this.deduction += this.levelScore;
                this.level += 1;
                this.points += this.levelPoints;
                //this.update();
                return true;
            }
            return false;
        }
        get levelScore() {
            return Math.ceil(1.8 * Math.pow(this.level + 1, 1.8) - 2 * this.level + 1);
        }
        get progress() {
            return this.levelScore ? (this.score - this.deduction) / this.levelScore : 0;
        }
        get levelPoints() {
            if ((c.serverName === "Squidward's Tiki Land" && this.level <= 90) || levelers.indexOf(this.level) !== -1) return 1;
            return 0;
        }
        cap(skill, real = false) {
            if (!real && this.level < c.SKILL_SOFT_CAP) return Math.round(this.caps[skcnv[skill]] * c.SOFT_MAX_SKILL);
            return this.caps[skcnv[skill]];
        }
        bleed(i, j) {
            let a = (i + 2) % 5 + 5 * j,
                b = (i + (j === 1 ? 1 : 4)) % 5 + 5 * j,
                value = 0,
                denom = Math.max(c.MAX_SKILL, this.caps[i + 5 * j]);
            value += (1 - Math.pow(this.raw[a] / denom - 1, 2)) * this.raw[a] * c.SKILL_LEAK;
            value -= Math.pow(this.raw[b] / denom, 2) * this.raw[b] * c.SKILL_LEAK;
            return value;
        }
        upgrade(stat) {
            if (this.points && this.amount(stat) < this.cap(stat)) {
                this.change(stat, 1);
                this.points -= 1;
                return true;
            }
            return false;
        }
        title(stat) {
            return this.name[skcnv[stat]];
        }
        amount(skill) {
            return this.raw[skcnv[skill]];
        }
        change(skill, levels) {
            this.raw[skcnv[skill]] += levels;
            this.update();
        }
    }
    const realSizes = (() => {
        let o = [1, 1, 1];
        for (let i = 3; i < 17; i++) o.push(Math.sqrt((2 * Math.PI / i) * (1 / Math.sin(2 * Math.PI / i))));
        return o;
    })();
    class Gun {
        constructor(body, info, gunIndex) {
            this.lastShot = {
                time: 0,
                power: 0
            };
            this.body = body;
            this.master = body.source;
            this.gunIndex = gunIndex;
            this.label = "";
            this.labelOverride = "";
            this.controllers = [];
            this.children = [];
            this.control = {
                target: new Vector(0, 0),
                _target: new Vector(0, 0),
                goal: new Vector(0, 0),
                main: false,
                alt: false,
                fire: false
            };
            this.canShoot = false;
            this.skin = 0;
            this.color_unmix = 0;
            this.color = 16;
            this.colorOverride = null;
            this.shootOnDeath = false;
            //this.alpha = 1
            let PROPERTIES = info.PROPERTIES;
            if (PROPERTIES != null && PROPERTIES.TYPE != null) {
                this.canShoot = true;
                this.shootOnce = PROPERTIES.SHOOT_ONCE;
                this.label = PROPERTIES.LABEL || "";
                if (Array.isArray(PROPERTIES.TYPE)) {
                    this.bulletTypes = PROPERTIES.TYPE;
                    this.natural = PROPERTIES.TYPE.BODY;
                } else this.bulletTypes = [PROPERTIES.TYPE];
                let natural = {};
                const setNatural = type => {
                    if (type.PARENT != null)
                        for (let i = 0; i < type.PARENT.length; i++) setNatural(type.PARENT[i]);
                    if (type.BODY != null)
                        for (let index in type.BODY) natural[index] = type.BODY[index];
                };
                for (let type of this.bulletTypes) setNatural(type);
                this.natural = natural;
                this.autofire = PROPERTIES.AUTOFIRE == null ? false : PROPERTIES.AUTOFIRE;
                this.altFire = PROPERTIES.ALT_FIRE == null ? false : PROPERTIES.ALT_FIRE;
                this.duoFire = PROPERTIES.DUO_FIRE == null ? false : PROPERTIES.DUO_FIRE;
                this.settings = PROPERTIES.SHOOT_SETTINGS || [];
                this.settings2 = (info.PROPERTIES.SHOOT_SETTINGS2 == null) ? [] : info.PROPERTIES.SHOOT_SETTINGS2;
                this.settings3 = (info.PROPERTIES.SHOOT_SETTINGS3 == null) ? [] : info.PROPERTIES.SHOOT_SETTINGS3;
                this.onShoot = PROPERTIES.ON_SHOOT;
                this.onFire = PROPERTIES.ON_FIRE;
                this.timesToFire = PROPERTIES.TIMES_TO_FIRE || 1;
                this.calculator = PROPERTIES.STAT_CALCULATOR || "default";
                this.waitToCycle = PROPERTIES.WAIT_TO_CYCLE == null ? false : PROPERTIES.WAIT_TO_CYCLE;
                this.countsOwnKids = PROPERTIES.COUNTS_OWN_KIDS != null ? PROPERTIES.COUNTS_OWN_KIDS : PROPERTIES.MAX_CHILDREN == null ? false : PROPERTIES.MAX_CHILDREN;
                this.syncsSkills = PROPERTIES.SYNCS_SKILLS == null ? false : PROPERTIES.SYNCS_SKILLS;
                this.useHealthStats = PROPERTIES.USE_HEALTH_STATS == null ? false : PROPERTIES.USE_HEALTH_STATS;
                this.negRecoil = PROPERTIES.NEGATIVE_RECOIL == null ? false : PROPERTIES.NEGATIVE_RECOIL;
                this.ammoPerShot = (info.PROPERTIES.AMMO_PER_SHOT == null) ? 0 : info.PROPERTIES.AMMO_PER_SHOT;
                this.destroyOldestChild = PROPERTIES.DESTROY_OLDEST_CHILD == null ? false : PROPERTIES.DESTROY_OLDEST_CHILD;
                this.shootOnDeath = PROPERTIES.SHOOT_ON_DEATH == null ? false : PROPERTIES.SHOOT_ON_DEATH;
                this.onDealtDamage = PROPERTIES.ON_DEALT_DAMAGE == null ? null : PROPERTIES.ON_DEALT_DAMAGE;
                if (this.shootOnDeath && !this.skipShootOnDeath) this.body.onDead = () => {
                    let self = this;
                    for (let i = 0; i < self.body.guns.length; i++) {
                        let gun = self.body.guns[i];
                        if (gun.shootOnDeath) {
                            let gx = gun.offset * Math.cos(gun.direction + gun.angle + gun.body.facing) + (1.35 * gun.length - gun.width * gun.settings.size / 2) * Math.cos(gun.angle + self.body.facing),
                                gy = gun.offset * Math.sin(gun.direction + gun.angle + gun.body.facing) + (1.35 * gun.length - gun.width * gun.settings.size / 2) * Math.sin(gun.angle + self.body.facing);
                            gun.fire(gx, gy, self.body.skill);
                        }
                    }
                };
                if (PROPERTIES.COLOR_OVERRIDE != null) this.colorOverride = PROPERTIES.COLOR_OVERRIDE;
                if (PROPERTIES.CAN_SHOOT != null) this.canShoot = PROPERTIES.CAN_SHOOT;
            }
            if (PROPERTIES != null && PROPERTIES.COLOR != null) this.color = PROPERTIES.COLOR;
            if (PROPERTIES != null && PROPERTIES.COLOR_UNMIX != null) this.color_unmix = PROPERTIES.COLOR_UNMIX;
            if (PROPERTIES != null && PROPERTIES.SKIN != null) this.skin = PROPERTIES.SKIN;
            if (PROPERTIES != null && PROPERTIES.ALPHA != undefined) this.alpha = PROPERTIES.ALPHA;//1234567890
            let position = info.POSITION;
            this.length = position[0] / 10;
            this.width = position[1] / 10;
            this.aspect = position[2];
            let offset = new Vector(position[3], position[4]);
            this.angle = position[5] * Math.PI / 180;
            this.direction = offset.direction;
            this.offset = offset.length / 10;
            this.delay = position[6];
            this.position = 0;
            this.motion = 0;
            if (this.canShoot) {
                this.cycle = !this.waitToCycle - this.delay;
                this.destroyOldestChild = !!this.destroyOldestChild;
            }
            if(body.mockupGuns){
                this.shootOnDeath = false
                this.canShoot = false
            }
        }
        newRecoil() {
            if (!this.hasNoRecoil) {
            let recoilForce = this.settings.recoil * 2 / room.speed;
            this.recoilThing = 1;
            this.body.accel.x -= recoilForce * Math.cos(this.recoilDir ?? 0) * this.recoilThing;
            this.body.accel.y -= recoilForce * Math.sin(this.recoilDir ?? 0) * this.recoilThing;
            }
        }
        getSkillRaw() {
            return [ // Not this one
                this.body.skill.raw[0],
                this.body.skill.raw[1],
                this.body.skill.raw[2],
                this.body.skill.raw[3],
                this.body.skill.raw[4],
                0,
                0,
                0,
                0,
                0
            ];
        }
        liveButBetter() {
            if (this.canShoot) {
                if (this.countsOwnKids + this.destroyOldestChild - 1 <= this.children.length) {
                    for (let i = 0, l = this.children.length; i < l; i++) {
                        if (this.children[i] == null || this.children[i].isGhost || this.children[i].isDead()) {
                            this.children.splice(i, 1);
                        }
                    }
                }
                if (this.destroyOldestChild) {
                    if (this.children.length > (this.countsOwnKids || this.body.maxChildren)) {
                        this.destroyOldest();
                    }
                }
                let sk = this.body.skill,
                    shootPermission = this.countsOwnKids ? (this.countsOwnKids + this.destroyOldestChild) > this.children.length * (this.calculator === 7 ? sk.rld : 1) : this.body.maxChildren ? this.body.maxChildren > this.body.children.length * (this.calculator === 7 ? sk.rld : 1) : true;
                if (this.body.master.invuln) {
                    shootPermission = false;
                }
                if ((shootPermission || !this.waitToCycle) && this.cycle < 1) {
                    this.cycle += 1 / this.settings.reload / room.speed / this.body.master.reloadCoef / (this.calculator === 7 || this.calculator === 4 ? 1 : sk.rld);
                }
                if (shootPermission && (this.autofire || (this.duoFire ? this.body.control.alt || this.body.control.fire : this.altFire ? (this.body.control.alt && !this.body.control.altOverride) : this.body.control.fire))) {
                    if (this.cycle >= 1) {
                        if (this.ammoPerShot) {
                            if (this.body.master.ammo - this.ammoPerShot >= 0) {
                                this.body.master.ammo -= this.ammoPerShot;
                                if (this.body.master.displayAmmoText) {
                                    this.body.master.displayText = this.body.master.ammo + " Ammo left";
                                }
                            } else {
                                shootPermission = false;
                            }
                        }
                        let gx = this.offset * Math.cos(this.direction + this.angle + this.body.facing) + (1.35 * this.length - this.width * this.settings.size / 2) * Math.cos(this.angle + this.body.facing),
                            gy = this.offset * Math.sin(this.direction + this.angle + this.body.facing) + (1.35 * this.length - this.width * this.settings.size / 2) * Math.sin(this.angle + this.body.facing);
                        if (shootPermission && this.cycle >= 1) {
                            if (c.DO_BASE_DAMAGE && this.body.type !== "wall" && this.body.isInMyBase() && c.CANNOT_SHOOT_IN_BASE) {
                                if (this.body.childrenMap && this.body.childrenMap.size) this.body.childrenMap.forEach((k) => k.destroy())
                            } else {
                                if (!this.body.variables.emp || this.body.variables.emp == undefined || !this.body.master.variables.emp || this.body.master.variables.emp == undefined) {
                                    if (this.onFire) {
                                        this.onFire(this, [gx, gy, sk]);
                                    } else {
                                        for (let i = 0; i < this.timesToFire; i++) {
                                            this.fire(gx, gy, sk);
                                        }
                                    }
                                }
                            }
                            shootPermission = this.countsOwnKids ? (this.countsOwnKids + this.destroyOldestChild) > this.children.length : this.body.maxChildren ? this.body.maxChildren >= this.body.children.length : true;
                            this.cycle -= 1;
                            if (this.onShoot != null && this.body.master.isAlive()) {
                                this.body.master.runAnimations(this);
                            }
                        }
                    }
                } else if (this.cycle > !this.waitToCycle - this.delay) this.cycle = !this.waitToCycle - this.delay;
            }
        }
        destroyOldest() {
            this.children.shift().kill();
        }
        syncChildren() {
            if (this.syncsSkills) {
                let self = this;
                for (let o of this.children) {
                    o.define({
                        BODY: self.interpret(),
                        SKILL: self.getSkillRaw()
                    });
                    o.refreshBodyAttributes();
                }
            }
        }
        fire(gx, gy, sk) {
            if (this.shootOnce) {
                this.canShoot = false;
            }
            this.lastShot.time = util.time();
            this.lastShot.power = 3 * Math.log(Math.sqrt(sk.spd) + this.settings.recoil + 1) + 1;
            this.motion += this.lastShot.power;
            this.recoilDir = this.body.facing + this.angle;
            this.newRecoil();
            let ss = util.clamp(ran.gauss(0, Math.sqrt(this.settings.shudder, 1)), -1.5 * this.settings.shudder, 1.5 * this.settings.shudder),
                sd = util.clamp(ran.gauss(0, this.settings.spray * this.settings.shudder, 1), -.5 * this.settings.spray, .5 * this.settings.spray);
            sd *= Math.PI / 180;
            let speed = (this.negRecoil ? -1 : 1) * this.settings.speed * c.runSpeed * sk.spd * (1 + ss);
            let s = new Vector(speed * Math.cos(this.angle + this.body.facing + sd), speed * Math.sin(this.angle + this.body.facing + sd));
            if (this.body.velocity.length) {
                let extraBoost = Math.max(0, s.x * this.body.velocity.x + s.y * this.body.velocity.y) / this.body.velocity.length / s.length;
                if (extraBoost) {
                    let len = s.length;
                    s.x += this.body.velocity.length * extraBoost * s.x / len;
                    s.y += this.body.velocity.length * extraBoost * s.y / len;
                }
            }
            let o
            if (this.master.master.isGen) {
                o=new Entity({
                    x: this.body.x + this.body.size * gx - .75 * this.length * s.x,
                    y: this.body.y + this.body.size * gy - .75 * this.length * s.y

        });
        o.define(this.bulletTypes[0]);
        if (o.type === "food") {
            o.ACCELERATION = .015 /  (o.size * 0.2);
        }
        if (c.serverName.includes("Void Walkers")) {
            o.team = -2;
        } else {
            o.team = -100
        }
 if (c.serverName.includes("The Doom Walk")) {
            o.team = -2;
        } else {
            o.team = -100
        }
            
        o.velocity.null();
        o.accel.null();
        if (!o.type.includes("all")) {
            o.velocity = s;
            o.initialBulletSpeed = speed;
        }
    } else {

            
            
            o = new Entity({
                x: this.body.x + this.body.size * gx - .75 * this.length * s.x,
                y: this.body.y + this.body.size * gy - .75 * this.length * s.y
            }, this.master.master);
            o.roomId = this.body.roomId;
            o.velocity = s;
            o.initialBulletSpeed = speed;
            this.bulletInit(o);
            o.coreSize = o.SIZE;
        }
            return o;
        }
        bulletInit(o) {
            o.source = this.body;
            o.diesToTeamBase = !this.body.master.godmode;
            o.passive = this.body.master.passive;
            if (this.colorOverride === "rainbow") o.toggleRainbow();
            for (let type of this.bulletTypes) o.define(type);
            /*
                o.define({ // Define is slow as heck
                    BODY: this.interpret(),
                    SKILL: this.getSkillRaw(),
                    SIZE: this.body.size * this.width * this.settings.size / 2,
                    LABEL: this.master.label + (this.label ? " " + this.label : "") + " " + o.label
                });*/

            // Define body
            let settings = this.interpret()
            for (let set in settings) {
                if (set === "HETERO") {
                    o.heteroMultiplier = settings[set]
                    continue;
                }
                o[set] = settings[set]
            }
            o.refreshBodyAttributes()
            // Define skills
            o.skill.set(this.getSkillRaw());
            // Define size
            o.SIZE = (this.body.size * this.width * this.settings.size * 0.5) * o.squiggle
            // Define label
            o.label = this.master.label + (this.label ? " " + this.label : "") + "" + o.label

            if (o.type === "food") {
                o.ACCELERATION = .015 / (o.size * 0.2);
            };
            if (this.onDealtDamage != null) o.onDealtDamage = this.onDealtDamage;
            if (this.colorOverride != null && !isNaN(this.colorOverride)) o.color = this.colorOverride;
            else if (this.colorOverride === "random") o.color = Math.floor(42 * Math.random());
            else o.color = this.body.master.color;
            if (this.countsOwnKids) {
                o.parent = this;
                this.children.push(o);
            } else if (this.body.maxChildren) {
                o.parent = this.body;
                this.body.children.push(o);
                this.children.push(o);
            }
            this.body.childrenMap.set(o.id, o);
            o.facing = o.velocity.direction;
            let oo = o;
            o.gunIndex = this.gunIndex;
            o.refreshBodyAttributes();
            o.life();
        }
        getTracking() {
            return {
                speed: c.runSpeed * this.body.skill.spd * this.settings.maxSpeed * this.natural.SPEED,
                range: Math.sqrt(this.body.skill.spd) * this.settings.range * this.natural.RANGE
            };
        }
        interpret(alt = false) {
            let sizeFactor = this.master.size / this.master.SIZE,
                shoot = alt ? alt : this.settings,
                sk = this.body.skill,
                out = {
                    SPEED: shoot.maxSpeed * sk.spd,
                    HEALTH: 0.5 * shoot.health * sk.str,
                    RESIST: shoot.resist + sk.rst,
                    DAMAGE: 1.75 * shoot.damage * sk.dam,
                    PENETRATION: Math.max(1, shoot.pen * sk.pen),
                    RANGE: shoot.range / Math.sqrt(sk.spd),
                    DENSITY: shoot.density * sk.pen * sk.pen / sizeFactor,
                    PUSHABILITY: 1 / sk.pen,
                    HETERO: Math.max(0, 3 - 1.2 * sk.ghost),
                };
            switch (this.calculator) {
                case 6:
                case "sustained":
                    out.RANGE = shoot.range;
                    break;
                case 8:
                case "trap":
                    out.PUSHABILITY = 1 / Math.pow(sk.pen, .5);
                    out.RANGE = shoot.range * .5;
                    break;
                case 2:
                  /*out.PUSHABILITY = 1;
                  out.PENETRATION = Math.max(1, shoot.pen * (0.5 * (sk.pen - 1) + 1));
                  out.HEALTH = (shoot.health * sk.str + sizeFactor) / Math.pow(sk.pen, 0.8);
                  out.DAMAGE = shoot.damage * sk.dam * Math.sqrt(sizeFactor) * Math.sqrt(shoot.pen * sk.pen);*/
                    out.DAMAGE = shoot.damage * sk.dam;
                    out.HEALTH = 0.475 * shoot.health * sk.str;
                break;
            }
            for (let property in out) {
                if (this.natural[property] == null || !out.hasOwnProperty(property)) continue;
                out[property] *= this.natural[property];
            }
            return out;
        }
    }
    class Laser {
        constructor(body, info) {
            // basic info y'know
            this.body = body;
            this.master = body.source;
            this.control = {
                target: new Vector(0, 0),
                goal: new Vector(0, 0),
                main: false,
                alt: false,
                fire: false
            };
            // dimensions, basically ripped from guns
            let position = info.POSITION;
            this.length = position[0] / 10;
            this.width = position[1] / 10;
            this.aspect = position[2];
            let offset = new Vector(position[3], position[4]);
            this.angle = position[5] * Math.PI / 180;
            this.direction = offset.direction;
            this.offset = offset.length / 10;
            // if there are properties, use them
            if (info.PROPERTIES != null) {
                let props = info.PROPERTIES;
                this.color = props.COLOR;
                this.dps = props.DPS;
                this.laserWidth = props.WIDTH;
            }
        }
    }
    class Prop {
        constructor(info) {
            let pos = info.POSITION;
            this.size = pos[0];
            this.x = pos[1];
            this.y = pos[2];
            this.angle = pos[3] * Math.PI / 180;
            this.layer = pos[4];
            this.shape = info.SHAPE;
            this.color = info.COLOR || -1;
            this.fill = info.FILL == undefined ? true : false;
            this.loop = info.LOOP == undefined ? true : false;
            this.isAura = info.IS_AURA == undefined ? false : true;
            this.ring = info.RING;
            this.arclen = info.ARCLEN == undefined ? 1 : info.ARCLEN;
            this.rpm = info.RPM;
            this.specific = info.SPECIFIC == undefined ? 0 : info.SPECIFIC;
            this.dip = info.DIP === undefined ? 1 : info.DIP;
        }
    }
    let views = [],
        bots = [],
        entitiesToAvoid = [],
        entities = new Chain(),
        //targetableEntities = [],
        bot = null,
        players = [],
        clients = [],
        multitabIDs = [],
        connectedIPs = [],
        entitiesIdLog = 1,
        startingTank = c.serverName.includes("Testbed Event") ? "event_bed" : (c.TOURNEY ? "observer" : ran.chance(1 / 25000) ? "tonk" : "basic"),
        blockedNames = [ // I have a much longer list, across alot of languages. Might add it
            "fuck",
            "bitch",
            "cunt",
            "shit",
            "pussy",
            "penis",
            "nigg",
            "penis",
            "dick",
            "whore",
            "dumbass",
            "fag"
        ],
        bannedPhrases = [
            "fag",
            "nigg",
            "trann",
            "troon",
        ]
    sanctuaries = [];
    let grid = new HashGrid();/*new QuadTree({
        x: 0,
        y: 0,
        width: room.width,
        height: room.height
    }, 16, 16, 0),
        targetingGrid = new QuadTree({
            x: 0,
            y: 0,
            width: room.width,
            height: room.height
        }, 16, 16, 0);//new hshg.HSHG();*/

    const dirtyCheck = (p, r) => entitiesToAvoid.some(e => Math.abs(p.x - e.x) < r + e.size && Math.abs(p.y - e.y) < r + e.size);

    /*const purgeEntities = () => entities = entities.filter(e => {
        if (e.isGhost) {
            e.removeFromGrid();
            return false;
        }
        return true;
    });*/

    const purgeEntities = () =>{
        let ghosts = 0;
        entities.filterToChain(e => {
            if (e.isGhost) {
                ghosts++
                e.removeFromGrid();
                return false;
            }
            return true;
        });
    }

    class HealthType {
        constructor(health, type, resist = 0) {
            this.max = health || .01;
            this.amount = health || .01;
            this.type = type;
            this.resist = resist;
            this.regen = 0;
            this.lastDamage = 0;
            this.rMax = health || .01;
            this.rAmount = health || .01;
        }
        get max() {
            return this.rMax;
        }
        get amount() {
            return this.rAmount;
        }
        set max(value) {
            if (Number.isFinite(value)) {
                this.rMax = value;
            }
        }
        set amount(value) {
            if (Number.isFinite(value)) {
                this.rAmount = value;
            }
        }
        set(health, regen = 0) {
            if (health <= 0) {
                health = .01;
            }
            this.amount = (this.max) ? this.amount / this.max * health : health;
            this.max = health;
            this.regen = regen;
        }
        display() {
            return this.amount / this.max;
        }
        getDamage(amount, capped = true) {
            switch (this.type) {
                case "dynamic":
                    return capped ? Math.min(amount * this.permeability, this.amount) : amount * this.permeability;
                case "static":
                    return capped ? Math.min(amount, this.amount) : amount;
            }
        }
        regenerate(boost = false) {
            boost /= 2;
            let mult = c.REGEN_MULTIPLIER;
            switch (this.type) {
                case "static":
                    if (this.amount >= this.max || !this.amount) break;
                    this.amount += mult * (this.max / 10 / 60 / 2.5 + boost);
                    break;
                case "dynamic":
                    let r = util.clamp(this.amount / this.max, 0, 1);
                    if (!r) this.amount = .0001;
                    if (r === 1) this.amount = this.max;
                    else this.amount += mult * (this.regen * Math.exp(-50 * Math.pow(Math.sqrt(.5 * r) - .4, 2)) / 3 + r * this.max / 10 / 15 + boost);
                    break;
            }
            this.amount = util.clamp(this.amount, 0, this.max);
        }
        get permeability() {
            switch (this.type) {
                case "static":
                    return 1;
                case "dynamic":
                    return this.max ? util.clamp(this.amount / this.max, 0, 1) : 0;
            }
        }
        get ratio() {
            return this.max ? util.clamp(1 - Math.pow(this.amount / this.max - 1, 4), 0, 1) : 0;
        }
    }

    class Entity {
        constructor(position, master = this) {
            this.reloadCoef = 1 //mine
            this.isGhost = false;
            this.killCount = {
                solo: 0,
                assists: 0,
                bosses: 0,
                killers: []
            };
            this.creationTime = (new Date()).getTime();
            this.turretTraverseSpeed = 1;
            this.master = master;
            this.source = this;
            this.parent = this;
            this.roomId = master.roomId;
            this.control = {
                target: new Vector(0, 0),
                _target: new Vector(0, 0),
                goal: new Vector(0, 0),
                main: false,
                alt: false,
                fire: false,
                power: 0
            };
            let objectOutput = null;
            this.__defineSetter__("sandboxId", function set(value) {
                objectOutput = value;
                if (!c.SANDBOX) {
                    return;
                }
                if (!global.sandboxRooms.find(entry => entry.id === objectOutput)) {
                    if (clients.find(e => e.sandboxId === objectOutput)) {
                        global.sandboxRooms.push({
                            id: objectOutput,
                            botCap: 0,
                            bots: []
                        });
                    }
                }
            });
            this.__defineGetter__("sandboxId", function get() {
                return objectOutput;
            });
            if (this.master) {
                if (this.master.sandboxId != null) {
                    this.sandboxId = this.master.sandboxId;
                }
            }
            this.isInGrid = false;
            /*this.activation = (() => {
                let active = true,
                    timer = ran.irandom(15);
                return {
                    update: () => {
                        if (this.isDead()) {
                            this.removeFromGrid();
                            return 0;
                        }
                        if (!active) {
                            this.removeFromGrid();
                            if (this.settings.diesAtRange || this.type === "bullet" || this.type === "swarm" || this.type === "trap") {
                                this.kill();
                            }
                            if (!(timer--)) {
                                active = true;
                            }
                        } else {
                            this.addToGrid();
                            timer = 15;
                            active = this.alwaysActive || ((this.source && this.source.isPlayer) || this.isPlayer || views.some(a => a.check(this, .6)));
                        }
                    },
                    check: () => this.alwaysActive || active
                };
            })();*/
            this.invulnTime = [-1, -1];
            this.autoOverride = false;
            this.controllers = [];
            this.blend = {
                color: "#FFFFFF",
                amount: 0
            };
            this.skill = new Skill();
            this.health = new HealthType(1, "static", 0);
            this.shield = new HealthType(0, "dynamic");
            this.lastSavedHealth = {
                health: this.health.amount,
                shield: this.shield.amount
            };
            this.guns = [];
            this.turrets = [];
            this.lasers = [];
            this.props = [];
            this.upgrades = [];
            this.settings = {
                leaderboardable: true
            };
            this.aiSettings = {};
            this.children = [];
            this.childrenMap = new Map();
            this.SIZE = 1;
            this.define(Class.genericEntity);
            this.maxSpeed = 0;
            this.facing = 0;
            this.vfacing = 0;
            this.range = 0;
            this.damageReceived = 0;
            this.stepRemaining = 1;
            this.x = position.x;
            this.y = position.y;
            this.cx = position.x;
            this.cy = position.y;
            this.messages = [];
            this.velocity = new Vector(0, 0);
            this.accel = new Vector(0, 0);
            this.damp = .05;
            this.collisionArray = [];
            //this.collisionIDs = [];
            this.invuln = false;
            this.godmode = false;
            this.passive = false;
            this.alpha = 1;
            this.spinSpeed = .038;
            this.tierCounter = 0;
            this.killedByK = false;
            this.id = entitiesIdLog++;
            this.team = this === master ? this.id : master.team;
            this.rainbow = false;
            this.intervalID = null;
            this.rainbowLoop = this.rainbowLoop.bind(this);
            this.keyFEntity = ["egg", 0, false];
            this.isActive = false
            this.activation = (() => {
                let timer = 0;
                return () => {
                    if (timer--, timer < 0 && (timer = 30)) {
                        this.isActive = this.alwaysActive ||
                            this.isPlayer ||
                            (this.source && this.source.isPlayer) ||
                            (this.master !== this && this.master.isActive) ||
                            views.some(a => a.check(this, .6));
                    }
                };
            })();
            /*this.isActive = this.alwaysActive ||
                this.isPlayer ||
                (this.source && this.source.isPlayer) ||
                (this.master !== this && this.master.isActive) ||
                views.some(a => a.check(this, .6));
            this.activation = (() => {
                let timer = 30;
                this.isActive = this.alwaysActive ||
                    this.isPlayer ||
                    (this.source && this.source.isPlayer) ||
                    (this.master !== this && this.master.isActive) ||
                    views.some(a => a.check(this, .6));
                return () => {
                    if (this.isDead()) {
                        this.destroy();
                        return;
                    }
                    if (timer--, timer < 0 && (timer = 30)) {
                        this.isActive = this.alwaysActive ||
                            this.isPlayer ||
                            (this.source && this.source.isPlayer) ||
                            (this.master !== this && this.master.isActive) ||
                            views.some(a => a.check(this, .6));
                    }
                    if (!this.isActive && !this.isTurret && (this.settings.diesAtRange || this.type === "bullet" || this.type === "swarm" || this.type === "trap")) {
                        this.destroy();
                        return;
                    }
                };
            })();*/
            /*this.activation = (() => {
                let active = true,//((this.master == this) ? false : this.master.source.isActive) || this.alwaysActive || this.isPlayer || (this.source && this.source.isPlayer) || views.some(a => a.check(this, .6)),
                    tick = 25;
                return {
                    update: () => {
                        if (this.isDead()) {
                            this.removeFromGrid();
                            return;
                        }
                        if (!active) {
                            this.removeFromGrid();
                            if (!this.isTurret && (this.settings.diesAtRange || this.type === "bullet" || this.type === "swarm" || this.type === "trap")) {
                                this.kill();
                                return;
                            }
                            tick --;
                            if (tick <= 0) {
                                active = this.alwaysActive || this.isPlayer || (this.source && this.source.isPlayer) || views.some(a => a.check(this, .6));
                            }
                        } else {
                            this.addToGrid();
                            if (!this.alwaysActive && !this.isPlayer && !(this.source && this.source.isPlayer) && !views.some(a => a.check(this, .6))) {
                                active = false;
                                tick = 25;
                            }
                        }
                    },
                    check: () => true
                }
            })();*/
            //this.updateAABB = () => { };
            this.tank = "basic";
            this.nameColor = "#FFFFFF";
            this.rainbowSpeed = 30;
            this.onDead = null;
            this.canUseQ = true;
            this.multibox = {
                enabled: false,
                intervalID: null,
                controlledTanks: []
            };
            this.multiboxLoop = this.multiboxLoop.bind(this);
            /*this.getAABB = (() => {
                let data = {},
                    save = {
                        x: 0,
                        y: 0,
                        size: 0,
                        width: 1,
                        height: 1
                    },
                    savedSize = 0,
                    lastCheck = this.isActive;
                this.updateAABB = active => {
                    if (
                        (this.settings.hitsOwnType !== "shield" && this.bond != null) ||
                        (!active && !(data.active = false))
                    ) {
                        lastCheck = false;
                        return;
                    }
                    if (active === lastCheck &&
                        (
                            this.x === save.x && 
                            this.y === save.y &&
                            this.realSize === save.size &&
                            this.width === save.width &&
                            this.height === save.height
                        )
                    ) {
                        return;
                    }
                    lastCheck = true;
                    save.x = this.x;
                    save.y = this.y;
                    save.size = this.realSize;
                    save.width = this.width;
                    save.height = this.height;
                    let width = this.realSize * (this.width || 1),// + 5,
                        height = this.realSize * (this.height || 1),// + 5,
                        x = this.x + this.velocity.x + this.accel.x,
                        y = this.y + this.velocity.y + this.accel.y,
                        x1 = (this.x < x ? this.x : x) - width,
                        x2 = (this.x > x ? this.x : x) + width,
                        y1 = (this.y < y ? this.y : y) - height,
                        y2 = (this.y > y ? this.y : y) + height,
                        size = util.getLongestEdge(x1, y1, x2, y1),
                        sizeDiff = savedSize / this.size;
                    data = {
                        min: [x1, y1],
                        max: [x2, y2],
                        active: true,
                        size: size
                    };
                    if (sizeDiff > Math.SQRT2 || sizeDiff < Math.SQRT1_2) {
                        this.removeFromGrid();
                        this.addToGrid();
                        savedSize = data.size;
                    }
                };
                return () => data;
            })();
            this.updateAABB(true);*/
            this.immuneToAbilities = false;
            this.sanctuaryType = "None";
            this.isMothership = false;
            this.isDominator = false;
            this.isBot = false;
            this.underControl = false;
            this.stealthMode = false;
            this.miscIdentifier = "None";
            this.switcherooID = -1;
            this.gunIndex = undefined;
            //entities.push(this);
            entities.set(this.id, this);
            //for (let v of views) v.add(this);
            //this.activation.update();
            this.ableToBeInGrid = true;
        }
        get myCell() {
            return room.at({ x: this.x, y: this.y });
        }
        removeFromGrid() {
            this.ableToBeInGrid = false;
            /*if (this.isInGrid) {
                grid.removeObject(this);
                this.isInGrid = false;
            }*/
        }
        addToGrid() {
            this.ableToBeInGrid = true;
            /*if (!this.isInGrid && (this.settings.hitsOwnType === "shield" || this.bond == null)) {
                grid.addObject(this);
                this.isInGrid = true;
            }*/
        }
        life() {
            // New version of life, let's hope this fucking works
            if (this.SIZE !== this.coreSize) {
                this.coreSize = this.SIZE;
                this.refreshFOV();
            }
            let control = {
                altOverride: false
            }, faucet = {};
            if (!this.settings.independent && this.source != null && this.source !== this) {
                faucet = this.source.control;
                if (faucet.main || faucet.alt) {
                    control.target = {
                        x: faucet.target.x + this.source.x - this.x,
                        y: faucet.target.y + this.source.y - this.y
                    };
                    control.fire = faucet.fire;
                    control.main = faucet.main;
                    control.alt = faucet.alt;
                }
            }
            if (this.settings.attentionCraver && !faucet.main && this.range) {
                this.range--;
            }
            //newLogs.controllers.start();
            for (let i = 0, l = this.controllers.length; i < l; i++) {
                let output = this.controllers[i].think(control);
                if (!output) {
                    continue;
                }
                if (this.controllers[i].acceptsFromTop) {
                    if (output.target != null) {
                        control.target = output.target;
                    }
                    if (output.goal != null) {
                        control.goal = output.goal;
                    }
                    if (output.fire != null) {
                        control.fire = output.fire;
                    }
                    if (output.main != null) {
                        control.main = output.main;
                    }
                    if (output.alt != null) {
                        control.alt = output.alt;
                    }
                    if (output.altOverride != null) {
                        control.altOverride = output.altOverride;
                    }
                    if (output.power != null) {
                        control.power = output.power;
                    }
                } else {
                    if (output.target != null && !control.target) {
                        control.target = output.target;
                    }
                    if (output.goal != null && !control.goal) {
                        control.goal = output.goal;
                    }
                    if (output.fire != null && !control.fire) {
                        control.fire = output.fire;
                    }
                    if (output.main != null && !control.main) {
                        control.main = output.main;
                    }
                    if (output.alt != null && !control.alt) {
                        control.alt = output.alt;
                    }
                    if (output.altOverride != null) {
                        control.altOverride = output.altOverride;
                    }
                    if (output.power != null && !control.power) {
                        control.power = output.power;
                    }
                }
            }
            this.control.target = control.target == null ? this.control.target : control.target;
            this.control.goal = control.goal;
            this.control.fire = control.fire;
            this.control.main = control.main;
            this.control.alt = control.alt;
            this.control.altOverride = control.altOverride;
            this.control.power = control.power == null ? 1 : control.power;
            //newLogs.controllers.stop();
            //newLogs.moveFace.start();
            this.move();
            this.face();
            //newLogs.moveFace.stop();
            if (this.invuln && this.invulnTime[1] > -1) {
                if (Date.now() - this.invulnTime[0] > this.invulnTime[1]) {
                    this.invuln = false;
                    this.sendMessage("Your invulnerability has expired.");
                }
            }
            //newLogs.aspects.start();
            for (let i = 0, l = this.guns.length; i < l; i++) {
                if (this.guns[i]) { // This if statement shouldn't be here. This is purely here because Meijijingu would be broken without it.
                    this.guns[i].liveButBetter();
                }
            }
            //newLogs.aspects.stop();
            if (this.skill.maintain()) this.refreshBodyAttributes();
            if (this.invisible[1]) {
                this.alpha = Math.max(this.invisible[2] || 0, this.alpha - this.invisible[1]);
                if (this.damageReceived || !this.velocity.isShorterThan(0.15) || this.invuln) {
                    this.alpha = Math.min(1, this.alpha + this.invisible[0]);
                }
            }
            if (this.control.main && this.onMain) {
                this.onMain(this, entities);
            }
            if (!this.control.main && this.onNotMain) {
                this.onNotMain(this, entities);
            }
            if (this.control.alt && this.onAlt) {
                this.onAlt(this, entities);
            }
            if (this.master.control.alt && this.onMasterAlt) {
                this.onMasterAlt(this, entities);
            }
            if (!this.control.alt && this.onNotAlt) {
                this.onNotAlt(this, entities);
            }
            if (this.onTick) this.onTick(this);
            if (this.mutation) switch (this.mutation) {
                    case "SourceColor":
                        this.color = this.source.color
                        break;
                    case "Mad":
                        let a = global.getTimer(100);
                        if(a < 0.01) {
                            let o = new Entity({
                                x: this.x,
                                y: this.y
                            })
                            o.define(Class.zeppelinBullet)
                            o.color = 100
                            o.passive = true
                            o.roomId = this.roomId;
                            o.coreSize = o.SIZE;
                            o.RANGE = 1;
                            o.kill()
                        }
                        break;
                    case "Transgender":
                        //5 - pink #EF99C3,  8 - white #DBDBDB, 0 - teal #79D4DB
                        let t = global.getTimer(500); // how fast is the cycle?
                        const speedOfTransitions = 0.1
                        const tealEnd = 1/3 - speedOfTransitions;
                        const whiteStart = 1/3 + speedOfTransitions;
                        const whiteEnd = 2/3 - speedOfTransitions;
                        const pinkStart = 2/3 + speedOfTransitions;
                        
                        if (t <= tealEnd) {
                            this.color = "#7ADBBC"; // teal
                        } else if (t > tealEnd && t <= whiteStart) {
                            this.color = blendColors("#7ADBBC", "#DBDBDB", numberLocation(t, [tealEnd, whiteStart]));//transition
                        } else if (t > whiteStart && t <= whiteEnd) {
                            this.color = "#DBDBDB"; // white
                        } else if (t > whiteEnd && t <= pinkStart) {
                            this.color = blendColors("#DBDBDB", "#EF99C3", numberLocation(t, [whiteEnd, pinkStart]));//transition
                        } else {
                            this.color = "#EF99C3"; // pink
                        }
                        for (let p in this.props) p.color = this.color;
                    break;
                    case "Epilepsy":
                        let e = global.getTimer(10);
                        if (e <= 0.5) {
                            this.color = 10
                        } else {
                            this.color = 12
                        }
                        break;
                    case "Epilepsy2":
                        let e2 = global.getTimer(10);
                        if (e2 <= 0.5) {
                            this.color = 12
                        } else {
                            this.color = 10
                        }
                        break;
                    case "Electric":
                        let e3 = global.getTimer(10);
                        if (e3 <= 0.5) {
                            this.color = 13
                        } else {
                            this.color = 8
                        }
                        break;
                    case "Mythical":
                        let m = global.getTimer(2000);
                        this.color = blendColors("#BF00FF", "#A000FF", m);
                        break;
                    case "Sacred":
                        let s = global.getTimer(1000);
                        this.color = blendColors("#FF00A5", "#BF00FF", s);
                        break;
                    case "boom":
                        if (!this.variables.boomTimer) this.variables.boomTimer = 0
                        if (this.variables.boomTimer <= 0) {
                            this.color = 18
                        } else if (this.variables.boomTimer > 5 && this.variables.boomTimer <= 10) {
                            this.color = 53//12
                            this.variables.boomTimer = (this.variables.boomTimer + 1)  % 10
                        }
                        break;
                }
        }
        addController(newIO) {
            if (Array.isArray(newIO)) this.controllers = newIO.concat(this.controllers);
            else this.controllers.unshift(newIO);
        }
        isInMyBase(cell = this.myCell) {
            return cell === `bas${-this.team}` || cell === `n_b${-this.team}` || cell === `bad${-this.team}`;
            /*return (room[`bas${-this.team}`] && room.isIn(`bas${-this.team}`, {
                x: this.x,
                y: this.y
            })) || (room[`n_b${-this.team}`] && room.isIn(`n_b${-this.team}`, {
                x: this.x,
                y: this.y
            })) || (room[`bad${-this.team}`] && room.isIn(`bad${-this.team}`, {
                x: this.x,
                y: this.y
            }));*/
        }
        minimalReset() {
            this.shape = 0;
            this.shapeData = 0;
            this.color = 16;
            this.guns = [];
            for (let o of this.turrets) o.destroy();
            this.turrets = [];
            this.lasers = [];
            this.props = [];
        }
        minimalDefine(set) {
            if (set.PARENT != null){
                for (let i = 0; i < set.PARENT.length; i++){
                    if(this.index === set.PARENT[i].index){
                        continue;
                    }
                    this.minimalDefine(set.PARENT[i]);
                }
            }
            this.mockupGuns = true
            if (set.TRAVERSE_SPEED != null) this.turretTraverseSpeed = set.TRAVERSE_SPEED;
            if (set.index != null) this.index = set.index;
            if (set.NAME != null) this.name = set.NAME;
            if (set.LABEL != null) this.label = set.LABEL;
            if (set.COLOR != null) this.color = set.COLOR;
            if (set.PASSIVE != null) this.passive = set.PASSIVE;
            if (set.SHAPE != null) {
                this.shape = typeof set.SHAPE === 'number' ? set.SHAPE : 0
                this.shapeData = set.SHAPE;
            }
            if (set.SIZE != null) {
                this.SIZE = set.SIZE * this.squiggle;
                if (this.coreSize == null) this.coreSize = this.SIZE;
            }
            if (set.LAYER != null) this.LAYER = set.LAYER;
            this.settings.skillNames = set.STAT_NAMES || 6;
            if (set.INDEPENDENT != null) this.settings.independent = set.INDEPENDENT;
            if (set.UPGRADES_TIER_1 != null)
                for (let e of set.UPGRADES_TIER_1) this.upgrades.push({
                    class: exportNames[e.index],
                    level: c.LEVEL_ZERO_UPGRADES ? 0 : 15,//12,//15
                    index: e.index,
                    tier: 1
                });
            if (set.UPGRADES_TIER_2 != null)
                for (let e of set.UPGRADES_TIER_2) this.upgrades.push({
                    class: exportNames[e.index],
                    level: c.LEVEL_ZERO_UPGRADES ? 0 : 30,//24,//30
                    index: e.index,
                    tier: 2
                });
            if (set.UPGRADES_TIER_3 != null)
                for (let e of set.UPGRADES_TIER_3) this.upgrades.push({
                    class: exportNames[e.index],
                    level: c.LEVEL_ZERO_UPGRADES ? 0 : 45,//36,//45
                    index: e.index,
                    tier: 3
                });
            if (set.UPGRADES_TIER_4 != null)
                for (let e of set.UPGRADES_TIER_4) this.upgrades.push({
                    class: exportNames[e.index],
                    level: c.LEVEL_ZERO_UPGRADES ? 0 : 60,//48,//60
                    index: e.index,
                    tier: 4
                });
            if (set.UPGRADES_TIER_5 != null)
                for (let e of set.UPGRADES_TIER_5) this.upgrades.push({
                    class: exportNames[e.index],
                    level: c.LEVEL_ZERO_UPGRADES ? 0 : 60,//60,//75
                    index: e.index,
                    tier: 5
                });
            if (set.GUNS != null) {
                let newGuns = [];
                let i = 0;
                for (let def of set.GUNS) {
                    newGuns.push(new Gun(this, def, i));
                    i++;
                }
                this.guns = newGuns;
            };
            if (set.TURRETS != null) {
                for (let o of this.turrets) o.destroy();
                this.turrets = [];
                for (let def of set.TURRETS) {
                    let o = new Entity(this, this.master);
                    if (Array.isArray(def.TYPE)) {
                        for (let type of def.TYPE) o.minimalDefine(type);
                    } else o.minimalDefine(def.TYPE);
                    o.bindToMaster(def.POSITION, this);
                    // o.alwaysActive = this.alwaysActive;
                    if (!def.TARGETABLE_TURRET) {
                        o.dangerValue = 0;
                    }
                };
            };
            if (set.LASERS != null) {
                let newLasers = [];
                for (let def of set.LASERS) newLasers.push(new Laser(this, def));
                this.lasers = newLasers;
            }
            if (set.PROPS != null) {
                let newProps = [];
                for (let def of set.PROPS) newProps.push(new Prop(def));
                this.props = newProps;
            }
        }
        define(set, extra) {
            try {
                if (set.PARENT != null)
                    for (let i = 0; i < set.PARENT.length; i++) this.define(set.PARENT[i]);
                for (let thing in extra) this[thing] = extra[thing];
                if (set.TRAVERSE_SPEED != null) this.turretTraverseSpeed = set.TRAVERSE_SPEED;
                if (set.RIGHT_CLICK_TURRET != null) this.turretRightClick = set.RIGHT_CLICK_TURRET;
                if (set.index != null) this.index = set.index;
                if (set.NAME != null) this.name = set.NAME;
                if (set.TRANSFORM_EXPORT != null) this.transformExport = set.transformExport;
                if (set.HITS_OWN_TEAM != null) this.hitsOwnTeam = set.HITS_OWN_TEAM;
                if (set.LABEL != null) this.label = set.LABEL;
                this.labelOverride = "";
                if (set.TOOLTIP != null) this.socket?.talk("m", `${set.TOOLTIP}`, "#8cff9f");
                if (set.IS_WIRE != null) this.socket?.talk("m", `Made originally by WireWorld. Go play their mod when it's available.`, "#3D3D4D");
                if (set.TYPE != null) this.type = set.TYPE;
                if (set.SHAPE != null) {
                    this.shape = typeof set.SHAPE === 'number' ? set.SHAPE : 0
                    this.shapeData = set.SHAPE;
                }
                if (set.COLOR != null) this.color = set.COLOR;
                if (set.CONTROLLERS != null) {
                    let toAdd = [];
                    for (let ioName of set.CONTROLLERS) toAdd.push(new ioTypes[ioName](this));
                    this.addController(toAdd);
                }

                if (set.NO_SPEED_CALCUATION !== null) {
                    this.settings.speedNoEffect = set.NO_SPEED_CALCUATION;
                }

                /* FYI reason i dont just have it not added in the defs is because mockups would need to be generated to change upgrades
                if (set.IS_TESTBED_REMOVED && this.socket) {
                    if (!c.IS_DEV_SERVER && !c.serverName.includes("Sandbox") && this.socket.betaData.permissions !== 3) {
                        this.sendMessage("You cannot used removed tanks outside of a testing server.");
                        this.kill();
                    }
                }*/
                if (set.MOTION_TYPE != null) this.motionType = set.MOTION_TYPE;
                if (set.FACING_TYPE != null) this.facingType = set.FACING_TYPE;
                if (set.DRAW_HEALTH != null) this.settings.drawHealth = set.DRAW_HEALTH;
                if (set.DRAW_SELF != null) this.settings.drawShape = set.DRAW_SELF;
                if (set.DAMAGE_EFFECTS != null) this.settings.damageEffects = set.DAMAGE_EFFECTS;
                if (set.RATIO_EFFECTS != null) this.settings.ratioEffects = set.RATIO_EFFECTS;
                if (set.MOTION_EFFECTS != null) this.settings.motionEffects = set.MOTION_EFFECTS;
                if (set.GIVE_KILL_MESSAGE != null) this.settings.givesKillMessage = set.GIVE_KILL_MESSAGE;
                if (set.CAN_GO_OUTSIDE_ROOM != null) this.settings.canGoOutsideRoom = set.CAN_GO_OUTSIDE_ROOM;
                if (set.HITS_OWN_TYPE != null) this.settings.hitsOwnType = set.HITS_OWN_TYPE;
                if (set.DIE_AT_LOW_SPEED != null) this.settings.diesAtLowSpeed = set.DIE_AT_LOW_SPEED;
                if (set.DIE_AT_RANGE != null) this.settings.diesAtRange = set.DIE_AT_RANGE;
                if (set.INDEPENDENT != null) this.settings.independent = set.INDEPENDENT;
                if (set.PERSISTS_AFTER_DEATH != null) this.settings.persistsAfterDeath = set.PERSISTS_AFTER_DEATH;
                if (set.CLEAR_ON_MASTER_UPGRADE != null) this.settings.clearOnMasterUpgrade = set.CLEAR_ON_MASTER_UPGRADE;
                if (set.HEALTH_WITH_LEVEL != null) this.settings.healthWithLevel = set.HEALTH_WITH_LEVEL;
                if (set.ACCEPTS_SCORE != null) this.settings.acceptsScore = set.ACCEPTS_SCORE;
                if (set.HAS_NO_RECOIL != null) this.settings.hasNoRecoil = set.HAS_NO_RECOIL;
                if (set.CRAVES_ATTENTION != null) this.settings.attentionCraver = set.CRAVES_ATTENTION;
                if (set.BROADCAST_MESSAGE != null) this.settings.broadcastMessage = set.BROADCAST_MESSAGE || undefined;
                if (set.DAMAGE_CLASS != null) this.settings.damageClass = set.DAMAGE_CLASS;
                if (set.BUFF_VS_FOOD != null) this.settings.buffVsFood = set.BUFF_VS_FOOD;
                if (set.CAN_BE_ON_LEADERBOARD != null) this.settings.leaderboardable = set.CAN_BE_ON_LEADERBOARD;
                if (set.IS_SMASHER != null) this.settings.reloadToAcceleration = set.IS_SMASHER;
                if (set.IS_DIGGER != null) this.aiSettings.isDigger = set.IS_DIGGER;
                if (set.DIES_BY_OBSTACLES != null) this.settings.diesByObstacles = set.DIES_BY_OBSTACLES;
                this.settings.isHelicopter = set.IS_HELICOPTER || null;
                if (set.GO_THRU_OBSTACLES != null) this.settings.goThruObstacle = set.GO_THRU_OBSTACLES;
                if (set.GO_THRU_ROCKS != null) this.settings.goThruRock = set.GO_THRU_ROCKS;
                if (set.BOUNCE_ON_OBSTACLES != null) this.settings.bounceOnObstacles = set.BOUNCE_ON_OBSTACLES;
                if (set.STAT_NAMES != null) this.settings.skillNames = set.STAT_NAMES;
                if (set.HAS_ANIMATION != null) this.settings.hasAnimation = set.HAS_ANIMATION;
                if (set.INTANGIBLE != null) this.intangibility = set.INTANGIBLE;
                if (set.AI != null) this.aiSettings = set.AI;
                if (set.DANGER != null) this.dangerValue = set.DANGER;
                if (set.TEAM != null) this.team = set.TEAM;
                if (set.TARGET_PLANES != null) this.settings.targetPlanes = set.TARGET_PLANES;
                if (set.IS_SHIP != null) this.isShip = set.IS_SHIP;
                if (set.IS_SHIP2 != null) this.isShip2 = set.IS_SHIP2;
                if (set.IS_TROUT != null) this.isTrout = set.IS_TROUT;
                //if (set.IS_JAMMER != null) this.isJam = set.IS_JAMMER;
                //if (this.master.body.isShip) this.isShip = true;
                if (set.IS_AQUATIC != null) this.isAquatic = set.IS_AQUATIC;
                if (set.VARIES_IN_SIZE != null) {
                    this.settings.variesInSize = set.VARIES_IN_SIZE;
                    this.squiggle = this.settings.variesInSize ? ran.randomRange(.8, 1.2) : 1;
                }
                if (set.RESET_UPGRADES) this.upgrades = [];
                if (set.DIES_TO_TEAM_BASE != null) this.diesToTeamBase = set.DIES_TO_TEAM_BASE;
                if (set.GOD_MODE != null) this.godmode = set.GOD_MODE;
                if (set.PASSIVE != null) this.passive = set.PASSIVE;
                if (set.HAS_NO_SKILL_POINTS != null && set.HAS_NO_SKILL_POINTS) this.skill.points = 0;
                if (set.HAS_ALL_SKILL_POINTS != null && set.HAS_ALL_SKILL_POINTS) this.skill.points = 42;
                if (set.LAYER != null) this.LAYER = set.LAYER;
                if (set.ALPHA != null) this.alpha = set.ALPHA;
                if (set.TEAM != null && set.TEAM !== -1) this.team = set.TEAM;
                //if (set.color == "team-dependent") this.color = [10, 12, 11, 15, 3, 35, 36, 0][- set.TEAM + 1];
                if (set.BOSS_TIER_TYPE != null) this.bossTierType = set.BOSS_TIER_TYPE;
                if (set.SYNC_TURRET_SKILLS != null) this.syncTurretSkills = set.SYNC_TURRET_SKILLS;
                if (set.INVISIBLE != null && set.INVISIBLE.length > 0) {
                    if (set.INVISIBLE.length !== 3) throw ("Invalid invisibility values!");
                    this.invisible = set.INVISIBLE;
                } else this.invisible = [0, 0, 0];
                if (set.IS_PLANE != null) this.isPlane = set.IS_PLANE;
                if (set.TARGET_PLANES != null) this.settings.targetPlanes = set.TARGET_PLANES;
                if (set.SEE_INVISIBLE != null) this.seeInvisible = set.SEE_INVISIBLE;
                this.displayText = set.DISPLAY_TEXT || "";
                this.displayTextColor = set.DISPLAY_TEXT_COLOR || "#FFFFFF"
                if (set.AMMO != null) {
                    this.displayAmmoText = set.DISPLAY_AMMO_TEXT !== undefined ? set.DISPLAY_TEXT : true
                    if (this.displayAmmoText) {
                        this.displayText = `${set.AMMO} Ammo left`;
                    }
                    this.ammo = set.AMMO;
                }
                this.onCollide = set.ON_COLLIDE || null;
                this.onTick = set.ON_TICK || null;
                this.onDamaged = set.ON_DAMAGED || null;
                this.onDealtDamage = set.ON_DEALT_DAMAGE || null;
                this.onTorched = set.ON_TORCHED || null;
                this.doesTorch = set.DOES_TORCH || null;
                this.onDealtDamageUniv = set.ON_DEALT_DAMAGE_UNIVERSAL || null;
                this.onKill = set.ON_KILL || null;
                this.onDead = set.ON_DEAD || null;
                this.onMain = set.ON_MAIN || null;
                this.onNotMain = set.ON_NOT_MAIN ?? null;
                this.onAlt = set.ON_ALT || null;
                this.onMasterAlt = set.ON_MASTER_ALT || null;
                this.onQ = set.ON_Q || null
                this.onNotAlt = set.ON_NOT_ALT || null;
                this.isObserver = set.IS_OBSERVER;
                this.onOverride = set.ON_OVERRIDE;
                this.isSentry = set.IS_SENTRY || null;
                this.isGen = set.IS_GEN;
                this.mutation = set.MUTATION;
                if (set.BOSS_TYPE !== "None" && !room.noSplitters) switch (set.BOSS_TYPE) {
                    case "vivi":
                        this.settings.broadcastMessage = "A Vivisection has separated!";
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            let positions = [
                                [30, 30],
                                [-30, -30],
                                [30, -30],
                                [-30, 30]
                            ],
                                names = ran.chooseBossName("a", 4);

                            // Core
                            let core = new Entity({
                                x: x,
                                y: y
                            });
                            core.team = -100;
                            core.define(Class.vivisectionemptyAI);
                            core.name = "Core";

                            // Sections
                            for (let i = 0; i < 4; i++) {
                                let shard = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard.team = -100;
                                shard.define([Class.redsectionAI,Class.greensectionAI,Class.yellowsectionAI,Class.bluesectionAI][i]);
                                shard.name = names[i];
                            }
                        }
                        break;
                  case "V1":
                  case "V2":
                  case "V3":
                  case "V4":
                  case "V5":
                  case "V6":
                  case "V7":
                  case "V8":
                  case "V9":
                  break;
                  /*case "V1":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling1);
                            }
                        };
                        break;                   
                    case "V2":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling2);
                            }
                        };
                    case "V3":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling3);
                            }
                        };
                        break;                   
                    case "V4":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling4);
                            }
                        };
                    break;
                    case "V5":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling5);
                            }
                        };
                    break;                   
                    case "V6":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling6);
                            }
                        };
                    break;                   
                    case "V7":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 2; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling7);
                            }
                        };  
                    break;           
                    case "V8":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling8);
                            }
                        };
                    break;                 
                    case "V9":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 1; i++) {
                                let enraged = new Entity({
                                    x: x,
                                    y: y
                                });
                                enraged.team = -100;
                                enraged.define(Class.Voidling9);
                            }
                        };
                    break;*/
                      case "Chessboard":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 8; i++) {
                                let Wpawn = new Entity({
                                    x: x,
                                    y: y
                                });
                                Wpawn.team = this.team;
                                Wpawn.define(Class.pawnAI);
                                Wpawn.color = 8
                            }
                            for (let i = 0; i < 8; i++) {
                            let Bpawn = new Entity({
                                    x: x,
                                    y: y
                                });
                                Bpawn.team = this.team;
                                Bpawn.define(Class.pawnAI);
                                Bpawn.color = 34
                            }
                            for (let i = 0; i < 2; i++) {
                                let Brook = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    Brook.team = this.team;
                                    Brook.define(Class.rookAI);
                                    Brook.color = 34
                                }
                            for (let i = 0; i < 2; i++) {
                                let Wrook = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    Wrook.team = this.team;
                                    Wrook.define(Class.rookAI);
                                    Wrook.color = 8
                                }
                            for (let i = 0; i < 2; i++) {
                                let Bknight = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    Bknight.team = this.team;
                                    Bknight.define(Class.knightAI);
                                    Bknight.color = 34
                                }
                            for (let i = 0; i < 2; i++) {
                                let Wknight = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    Wknight.team = this.team;
                                    Wknight.define(Class.knightAI);
                                    Wknight.color = 8
                                }
                            for (let i = 0; i < 2; i++) {
                                let Bbishop = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    Bbishop.team = this.team;
                                    Bbishop.define(Class.bishopAI);
                                    Bbishop.color = 34
                                }
                            for (let i = 0; i < 2; i++) {
                                let Wbishop = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    Wbishop.team = this.team;
                                    Wbishop.define(Class.bishopAI);
                                    Wbishop.color = 8
                                }
                            let Bking = new Entity(
                                {
                                    x: x,
                                    y: y
                                }
                            );
                            Bking.team = this.team
                            Bking.define(Class.chessKingAI);
                            Bking.color = 34
                            let Wking = new Entity(
                                {
                                    x: x,
                                    y: y
                                }
                            );
                            Wking.team = this.team
                            Wking.define(Class.chessKingAI);
                            Wking.color = 8
                            let WQueen = new Entity(
                                {
                                    x: x,
                                    y: y
                                }
                            );
                            WQueen.team = this.team
                            WQueen.define(Class.chessQueenAI);
                            WQueen.color = 8
                            let BQueen = new Entity(
                                {
                                    x: x,
                                    y: y
                                }
                            );
                            BQueen.team = this.team
                            BQueen.define(Class.chessQueenAI);
                            BQueen.color = 34
                        };
                        break;
                    case "deletionist":
                        this.onDead = () => {
                            sockets.broadcast("The deletionist has been obliterated! This world is safe!");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("i lied lmfao");
                                for (let i = 0; i < 10; i++) {
                                    let boss = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    boss.team = this.team;
                                    boss.define([Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI,Class.supremeantimatAI][i]);
                                }
                            }, 7500);
                        };
                        break;
                        case "lbozo":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 2; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define([Class.fgh564536rsuhnidg4354353t3ret43453348t7ghdghsdy8try25h4y567958dyfg8s9hfdgy84r2y56h6y8tryd8gfhgsadyf7d8ry34758923h4yt598weyghfdhght9yj35498ykt9hgysdfbcxhbusdfnbygrweiot546246758t97er87543789543879dfsdfdsf89345udgjs35,Class.fgh564536rsuhnidg4354353t3ret43453348t7ghdghsdy8try25h4y567958dyfg8s9hfdgy84r2y56h6y8tryd8gfhgsadyf7d8ry34758923h4yt598weyghfdhght9yj35498ykt9hgysdfbcxhbusdfnbygrweiot546246758t97er87543789543879dfsdfdsf89345udgjs35][i]);
                            }
                        };
                        break;
                        
                        case "supremeantimat":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 6; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define([Class.antiminimat,Class.antiminimat,Class.shockminirifle,Class.shockminirifle,Class.shockminirifle,Class.shockminirifle][i]);
                            }
                        };
                        break;
                    case "unkillablesquare":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define(Class.unkillablesquare);
                        };
                        break;
                    case "unkillablesplitter":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 4; i++) {
                                let crash = new Entity({
                                    x: x,
                                    y: y
                                });
                                crash.team = -100;
                                crash.define(Class.unkillablesquare);
                            }
                            let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define(Class.unkillablesplitter);
                        };
                        break;
                    case "ascendsummon":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 4; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define([Class.obbysummonAI,Class.obbysummonAI,Class.ivorysummonAI,Class.ivorysummonAI][i]);
                            }
                        };
                        break;
                    case "checkboard1":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 4; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define([Class.checker1,Class.checker1,Class.checker2,Class.checker2][i]);
                            }
                        };
                        break;
                    case "checkboard2":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 9; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define([Class.checker1,Class.checker1,Class.checker1,Class.checker1,Class.checker1,Class.checker2,Class.checker2,Class.checker2,Class.checker2][i]);
                            }
                        };
                        break;
                    case "checkboard3":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 16; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define([Class.checker1,Class.checker1,Class.checker1,Class.checker1,Class.checker1,Class.checker1,Class.checker1,Class.checker1,Class.checker2,Class.checker2,Class.checker2,Class.checker2,Class.checker2,Class.checker2,Class.checker2,Class.checker2][i]);
                            }
                        };
                        break;
                    case "industropolis":
                                this.onDead = () => {
                                    let x = this.x,
                                        y = this.y;
                                        let core = new Entity({
                                            x: x,
                                            y: y
                                        });
                                        core.team = this.team;
                                        core.define(Class.alphaSentryAI);
                                        let boss1 = new Entity({
                                            x: x + 150,
                                            y: y
                                        });
                                        boss1.team = this.team;
                                        boss1.define(Class.alphaSentryAI);
                                        let boss2 = new Entity({
                                            x: x - 150,
                                            y: y
                                        });
                                        boss2.team = this.team;
                                        boss2.define(Class.alphaSentryAI);
                                        let boss3 = new Entity({
                                            x: x,
                                            y: y + 150
                                        });
                                        boss3.team = this.team;
                                        boss3.define(Class.alphaSentryAI);
                                        let boss4 = new Entity({
                                            x: x,
                                            y: y - 150
                                        });
                                        boss4.team = this.team;
                                        boss4.define(Class.alphaSentryAI);
                                        let boss5 = new Entity({
                                            x: x + 150,
                                            y: y + 150
                                        });
                                        boss5.team = this.team;
                                        boss5.define(Class.alphaSentryAI);
                                        let boss6 = new Entity({
                                            x: x - 150,
                                            y: y - 150
                                        });
                                        boss6.team = this.team;
                                        boss6.define(Class.alphaSentryAI);
                                        let boss7 = new Entity({
                                            x: x - 150,
                                            y: y + 150
                                        });
                                        boss7.team = this.team;
                                        boss7.define(Class.alphaSentryAI);
                                        let boss8 = new Entity({
                                            x: x + 150,
                                            y: y - 150
                                        });
                                        boss8.team = this.team;
                                        boss8.define(Class.alphaSentryAI);
                                }
                            break;
                    case "meteoroid":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                                        let com1 = new Entity({
                                            x: x,
                                            y: y
                                        });
                                        com1.team = this.team;
                                        com1.define(Class.cometAI);
                                        let com2 = new Entity({
                                            x: x+150,
                                            y: y
                                        });
                                        com2.team = this.team;
                                        com2.define(Class.cometAI);
                                        let com3 = new Entity({
                                            x: x-150,
                                            y: y
                                        });
                                        com3.team = this.team;
                                        com3.define(Class.cometAI);
                                        let com4 = new Entity({
                                            x: x,
                                            y: y+150
                                        });
                                        com4.team = this.team;
                                        com4.define(Class.cometAI);
                                        let com5 = new Entity({
                                            x: x,
                                            y: y-150
                                        });
                                        com5.team = this.team;
                                        com5.define(Class.cometAI);
                        };
                        break;
                    case "doublequintet":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                        sockets.broadcast("The Guardians have come.");
                        for (let i = 0; i < 3; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define(Class.pentaguardianAI);
                        }
                    }, 3000);
                };
                break;
                case "quad_messenger":
                this.onDead = () => {
                    let x = this.x,
                        y = this.y;
                    setTimeout(() => {
                    sockets.broadcast("The Messengers have come.");
                    for (let i = 0; i < 5; i++) {
                        let boss = new Entity({
                            x: x,
                            y: y
                        });
                        boss.team = this.team;
                        boss.define([Class.messengerAI,Class.messengerAI,Class.quadMessengerCoreAI,Class.messengerAI,Class.messengerAI][i]);
                    }
                }, 3000);
                };
                break;
                case "awppoly":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 8; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define([Class.triangle,Class.square,Class.pentagon,Class.sentryGunAI,Class.sentrySwarmAI,Class.sentrySwarmAI,Class.sentryRangerAI,Class.sentryRangerAI][i]);
                        }
                    };
                    break;
                case "awppolyspawns":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                                    let pol1 = new Entity({
                                        x: x+150,
                                        y: y
                                    });
                                    pol1.team = this.team;
                                    pol1.define(Class.awppolyAI);
                                    let pol2 = new Entity({
                                        x: x-150,
                                        y: y
                                    });
                                    pol2.team = this.team;
                                    pol2.define(Class.awppolyAI);
                    };
                    this.kill()
                    break;
                case "awpcc":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 12; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define([Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag,Class.awpccfrag][i]);
                        }
                    };
                    break;
                case "UMachine":                       
                this.onDead = () => {
                    let x = this.x,
                        y = this.y;
                        for (let i = 0; i < 6; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define(Class.UTriangleFragmentAI);
                        }
                    };
                break;
                case "UBasic":                       
                this.onDead = () => {
                    sockets.broadcast("An Ultra Basic May Have Been Destroyed, But It Hasn’t Ended Yet…");
                    let x = this.x,
                        y = this.y;
                    setTimeout(() => {
                        sockets.broadcast("An Elite Basic has arrived.");
                        let core = new Entity({
                            x: x,
                            y: y
                        });
                        core.team = -100;
                        core.control.target.x = core.control.target.y = 100;
                        core.define(Class.eliteBasicAI);
                        core.name = ran.chooseBossName("a", 1);
                        core.settings.broadcastMessage = "An Ultra Basic has met its end!";
                    }, 7500);
                };
                break;
                case "Easter":
                    this.onDead = () => {
                        sockets.broadcast("The Supreme Evolution Of The Egg Has Been Reached!","rainbow")
                        sockets.broadcast("'ßﬁ∂®√ƒﬁ†ê‚Ê’ıËπœî¢Å∞å⁄¢‚ø' - Last Words.")
                        sockets.broadcast("The One Who Created Me Is Going Crazy... Send Help... I Can't Fight Against Someone Who Controls Everything In This World...")
                    }
                    setTimeout(() => {
                        if (this.isAlive()) {
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                let boss1 = new Entity({
                                    x: x + 10,
                                    y: y
                                });
                                boss1.team = this.team;
                                boss1.define(Class.egg);
                                let boss2 = new Entity({
                                    x: x - 10,
                                    y: y
                                });
                                boss2.team = this.team;
                                boss2.define(Class.egg);
                                let boss3 = new Entity({
                                    x: x,
                                    y: y + 10
                                });
                                boss3.team = this.team;
                                boss3.define(Class.egg);
                                let boss4 = new Entity({
                                    x: x,
                                    y: y - 10
                                });
                                boss4.team = this.team;
                                boss4.define(Class.fakeegg);
                            }, 100);
                        }
                    }, 1);
                    break;
                case "treeApple":
                        //this.settings.broadcastMessage = "A Fruity Flavor has released its fruits in the nature!";
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            let positions = [
                                [30, 30],
                                [-30, -30],
                                [30, -30],
                                [-30, 30]
                            ],
                                names = ran.chooseBossName("a", 4);

                            // Summoners
                            for (let i = 0; i < 1; i++) {
                                let shard3 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard3.team = -100;
                                shard3.define(Class.applePoly);
                                shard3.name = names[i];
                            }
                        }
                        break;
                case "treeOrange":
                        //this.settings.broadcastMessage = "A Fruity Flavor has released its fruits in the nature!";
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            let positions = [
                                [30, 30],
                                [-30, -30],
                                [30, -30],
                                [-30, 30]
                            ],
                                names = ran.chooseBossName("a", 4);

                            // Summoners
                            for (let i = 0; i < 1; i++) {
                                let shard2 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard2.team = -100;
                                shard2.define(Class.orangePoly);
                                shard2.name = names[i];
                            }
                            for (let i = 0; i < 1; i++) {
                                let shard3 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard3.team = -100;
                                shard3.define(Class.applePoly);
                                shard3.name = names[i];
                            }
                        }
                        break;
                case "treeLemon":
                        //this.settings.broadcastMessage = "A Fruity Flavor has released its fruits in the nature!";
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            let positions = [
                                [30, 30],
                                [-30, -30],
                                [30, -30],
                                [-30, 30]
                            ],
                                names = ran.chooseBossName("a", 4);

                            // Summoners
                            for (let i = 0; i < 1; i++) {
                                let shard = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard.team = -100;
                                shard.define(Class.lemonPoly);
                                shard.name = names[i];
                            }
                            for (let i = 0; i < 1; i++) {
                                let shard2 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard2.team = -100;
                                shard2.define(Class.orangePoly);
                                shard2.name = names[i];
                            }
                            for (let i = 0; i < 1; i++) {
                                let shard3 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard3.team = -100;
                                shard3.define(Class.applePoly);
                                shard3.name = names[i];
                            }
                            for (let i = 0; i < 1; i++) {
                                let shard4 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard4.team = -100;
                                shard4.define(Class.applePoly);
                                shard4.name = names[i];
                            }
                        }
                        break;
                case "Radioactive Laser": 
                    this.onDead = () => {if(this.variables.hasCollided) {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 1; i++) {
                            let flak = new Entity({
                                x: x,
                                y: y
                            });
                            flak.team = this.team;
                            flak.define(Class.radioactiveFlak);
                            flak.SIZE = 50 * Math.random() + 10
                        }
                    }}
                break;
                case "Dragon":
                    this.onTick = (me) => {
                        if(me.health.amount < me.HEALTH/2) {
                            me.define(Class.devilishDragonLastPhaseAI)
                            //me.health.amount *= 0.5
                        }// else {me.define(Class.devilishDragonAI)}
                    }
                break;
                /*case "Fluor":
                    this.refreshBodyAttributes()
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 1; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.ballpartcrasher);
                        }
                    }
                    break;*/
                case "ballboss":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 1; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.ballpartcrasher);
                        }
                        for (let i = 0; i < 1; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.ballpartcrasher);
                        }
                        for (let i = 0; i < 1; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.ballcenter);
                        }
                    };
                    break; 
                case "sandSquare":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }];
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define(Class.sandSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                            shape.SIZE = this.SIZE / 2
                            shape.health.amount = shape.health.amount / 3
                            shape.shield.amount = 0
                            shape.isDesertFood = true
                            if(shape.SIZE < 10) {
                                shape.onDead = () => {}
                                shape.kill()
                            }
                        }
                    };
                    break;
                case "sandTriangle":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }];
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define(Class.sandTriangle);
                            shape.isDesertFood = true
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                            shape.SIZE = this.SIZE / 2
                            shape.health.amount = shape.health.amount / 4
                            shape.shield.amount = 0
                            if(shape.SIZE < 10) {
                                shape.onDead = () => {}
                                shape.kill()
                            }
                        }
                    };
                    break;
                case "sandPentagon":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }];
                        for (let i = 0; i < 5; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define(Class.sandPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                            shape.isDesertFood = true
                            shape.health.amount = shape.health.amount / 6
                            shape.shield.amount = 0
                            shape.SIZE = this.SIZE /2
                            if(shape.SIZE < 10) {
                                shape.onDead = () => {}
                                shape.kill()
                            }
                        }
                    };
                    break;
                    case "Sand Ghost":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y,
                                positions = [{
                                    x: x - 10,
                                    y: y - 10
                                }, {
                                    x: x - 10,
                                    y: y + 10
                                }];
                            for (let i = 0; i < 2; i++) {
                                let shape = new Entity(positions[i]);
                                shape.team = -100;
                                shape.define(Class.sandGhostAI);
                                //shape.ACCELERATION = .015 / (shape.size * 0.2);
                                //shape.isDesertFood = true
                                shape.health.amount = shape.health.amount / 2
                                shape.shield.amount = shape.shield.amount/ 4
                                shape.SIZE = this.SIZE /2
                                if(shape.SIZE < 10) {
                                    shape.onDead = () => {}
                                    shape.kill()
                                }
                            }
                        };
                        break;
                case "SCM":                       
                this.onDead = () => {
                    sockets.broadcast("The Supreme Maker has fallen... the evil's shadows are ready to fight for it...");
                    let x = this.x,
                        y = this.y;
                    setTimeout(() => {
                        sockets.broadcast("The Evil's Shadows have arrived!");
                        let positions = [
                            [x + 110, y, -110, 0],
                            [x - 110, y, 110, 0],
                            [x, y + 110, 0, -110],
                            [x, y - 110, 0, 110]
                        ],
                            names = ran.chooseBossName("customElite", 5);
                        for (let i = 0; i < 4; i++) {
                            let shard = new Entity({
                                x: positions[i][0],
                                y: positions[i][1]
                            });
                            shard.team = -100;
                            shard.control.target.x = positions[i][2];
                            shard.control.target.y = positions[i][3];
                            shard.define(Class.shadowShardAI);
                            shard.name = names[i];
                            shard.settings.broadcastMessage = "A Shadow Cultist has vanished forever...";
                        }
                        let core = new Entity({
                            x: x,
                            y: y
                        });
                        core.team = -100;
                        core.control.target.x = core.control.target.y = 100;
                        core.define(Class.shadowCoreAI);
                        core.name = names[4];
                        core.settings.broadcastMessage = "A Shadow Core has vanished forever...";
                    }, 7500);
                };
                break;
                case "Fruity Flavor":
                        this.settings.broadcastMessage = "A Fruity Flavor has released its fruits in the nature!";
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            let positions = [
                                [30, 30],
                                [-30, -30],
                                [30, -30],
                                [-30, 30]
                            ],
                                names = ran.chooseBossName("a", 4);

                            // Summoners
                            for (let i = 0; i < 1; i++) {
                                let shard = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard.team = -100;
                                shard.define(Class.applicusAI);
                                shard.name = names[i];
                            }
                            for (let i = 0; i < 1; i++) {
                                let shard2 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard2.team = -100;
                                shard2.define(Class.lemonicusAI);
                                shard2.name = names[i];
                            }
                            for (let i = 0; i < 1; i++) {
                                let shard3 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard3.team = -100;
                                shard3.define(Class.orangicusAI);
                                shard3.name = names[i];
                            }
                            for (let i = 0; i < 1; i++) {
                                let shard4 = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard4.team = -100;
                                shard4.define(Class.lavendicusAI);
                                shard4.name = names[i];
                            }
                        }
                        break;
                case "Constellation":
                    this.onDead = () => {
                        sockets.broadcast("A Constellation boss may have been defeated, but the battle is not won yet...");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("Constellation Shards have spawned to avenge the Constellation!");
                            let positions = [
                                [x + 110, y, -110, 0],
                                [x - 110, y, 110, 0],
                                [x, y + 110, 0, -110],
                                [x, y - 110, 0, 110]
                            ],
                                names = ran.chooseBossName("a", 5);
                            for (let i = 0; i < 4; i++) {
                                let shard = new Entity({
                                    x: positions[i][0],
                                    y: positions[i][1]
                                });
                                shard.team = -100;
                                shard.control.target.x = positions[i][2];
                                shard.control.target.y = positions[i][3];
                                shard.define(Class.constShard);
                                shard.name = names[i];
                                shard.settings.broadcastMessage = "A Constellation Shard has been defeated!";
                            }
                            let core = new Entity({
                                x: x,
                                y: y
                            });
                            core.team = -100;
                            core.control.target.x = core.control.target.y = 100;
                            core.define(Class.constCore);
                            core.name = names[4];
                            core.settings.broadcastMessage = "A Constellation Core has been defeated!";
                        }, 7500);
                    };
                    break;
case "boomFu":
                            /*if (this.isAlive && !this.invuln && "Boomerang Fu".includes(this.label)) */setTimeout(() => {
                                /*let core = new Entity({
                                    x: this.x,
                                    y: this.y
                                });
                                core.team = this.team;*/
                                let options = [
                                  Class.boomerangFu2,
                                  Class.boomerangFu3,
                                  Class.boomerangFu4,
                                  Class.boomerangFu5,
                                  Class.boomerangFu6,
                                  Class.boomerangFu7,
                                  Class.boomerangFu8,
                                  Class.boomerangFu9,
                                  Class.boomerangFu10
                                ];
                                this.define(ran.choose([...options]));
                            }, 19500); // 19.5 seconds between each switch 
                        break;  
                case "polyamorous":
                    this.onDead = () => {
                        sockets.broadcast("It will stop at nothing to seek what it came for, not even its own grave...");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("The Mysticals have arrived!");
                            let positions = [
                                [x + 110, y, -110, 0],
                                [x - 110, y, 110, 0],
                                [x, y + 110, 0, -110],
                                [x, y - 110, 0, 110]
                            ];
                            for (let i = 0; i < 4; i++) {
                                let mystical = new Entity({
                                    x: positions[i][0],
                                    y: positions[i][1]
                                });
                                mystical.team = this.team;
                                mystical.control.target.x = positions[i][2];
                                mystical.control.target.y = positions[i][3];
                                mystical.define([Class.sorcererAI, Class.summonerAI, Class.enchantressAI, Class.exorcistorAI][i]);
                            }
                        }, 4000);
                    };
                    break;
                case "Bow":
                    this.onDead = () => {
                        sockets.broadcast("A Bow may have been defeated, but the battle is not over yet...");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("Bow Shards have spawned to avenge the Bow!");
                            let positions = [
                                [x + 100, y, 100, 0],
                                [x - 100, y, -100, 0]
                            ],
                                names = ran.chooseBossName("a", 3);
                            for (let i = 0; i < 2; i++) {
                                let shard = new Entity({
                                    x: positions[i][0],
                                    y: positions[i][1]
                                });
                                shard.team = -100;
                                shard.control.target.x = positions[i][2];
                                shard.control.target.y = positions[i][3];
                                shard.define(Class.bowShard);
                                shard.name = names[i];
                                shard.settings.broadcastMessage = "A Bow Shard has been defeated!";
                            }
                            let core = new Entity({
                                x: x,
                                y: y
                            });
                            core.team = -100;
                            core.control.target.x = core.control.target.y = 100;
                            core.define(Class.bowCore);
                            core.name = names[2];
                            core.settings.broadcastMessage = "A Bow Core has been defeated!";
                        }, 5000);
                    };
                    break;
                case "Bow":
                    this.onDead = () => {
                        sockets.broadcast("A Bow may have been defeated, but the battle is not over yet...");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("Bow Shards have spawned to avenge the Bow!");
                            let positions = [
                                [x + 100, y, 100, 0],
                                [x - 100, y, -100, 0]
                            ],
                                names = ran.chooseBossName("a", 3);
                            for (let i = 0; i < 2; i++) {
                                let shard = new Entity({
                                    x: positions[i][0],
                                    y: positions[i][1]
                                });
                                shard.team = -100;
                                shard.control.target.x = positions[i][2];
                                shard.control.target.y = positions[i][3];
                                shard.define(Class.bowShard);
                                shard.name = names[i];
                                shard.settings.broadcastMessage = "A Bow Shard has been defeated!";
                            }
                            let core = new Entity({
                                x: x,
                                y: y
                            });
                            core.team = -100;
                            core.control.target.x = core.control.target.y = 100;
                            core.define(Class.bowCore);
                            core.name = names[2];
                            core.settings.broadcastMessage = "A Bow Core has been defeated!";
                        }, 5000);
                    };
                    break;
            
                    case "splitterSummoner":
                        this.settings.broadcastMessage = "A Splitter Summoner has shattered!";
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            let positions = [
                                [30, 30],
                                [-30, -30],
                                [30, -30],
                                [-30, 30]
                            ],
                                names = ran.chooseBossName("a", 4);

                            // Core
                            let core = new Entity({
                                x: x,
                                y: y
                            });
                            core.team = -100;
                            core.define(Class.splitSummonerCore);
                            core.name = "Core";
                            core.settings.broadcastMessage = "A Splitter Core has been defeated!";

                            // Summoners
                            for (let i = 0; i < 4; i++) {
                                let shard = new Entity({
                                    x: this.x+positions[i][0],
                                    y: this.y+positions[i][1]
                                });
                                shard.team = -100;
                                shard.define(Class.summonerAI);
                                shard.name = names[i];
                                shard.settings.broadcastMessage = "A Summoner has been defeated!";
                                shard.onDead = () => {
                                    for (let i = 0; i < 4; i++) {
                                        let e = new Entity({x:shard.x+positions[i][0],y:shard.y+positions[i][0]})
                                        e.define(Class.splitterSplitterSquare)
                                        e.ACCELERATION = .015 / (e.size * 0.2);
                                        let max = 20
                                        let min = -20
                                        e.velocity.x = Math.floor(Math.random() * (max - min + 1)) + min;
                                        e.velocity.y = Math.floor(Math.random() * (max - min + 1)) + min;
                                        e.team = -100
                                    }
                                }
                            }
                        }
                        break;
            
                        case "superSplitterSummoner":
                            this.settings.broadcastMessage = "A Super Splitter Summoner has shattered!";
                            this.onDead = () => {
                                let x = this.x,
                                    y = this.y;
                                let positions = [
                                    [30, 30],
                                    [-30, -30],
                                    [30, -30],
                                    [-30, 30]
                                ],
                                    names = ran.chooseBossName("a", 4);

                                // Core
                                let core = new Entity({
                                    x: x,
                                    y: y
                                });
                                core.team = -100;
                                core.define(Class.superSplitSummonerCore);
                                core.name = "Core";
                                core.settings.broadcastMessage = "A Super Splitter Core has been defeated!";

                                // Summoners
                                for (let i = 0; i < 4; i++) {
                                    let shard = new Entity({
                                        x: this.x+positions[i][0],
                                        y: this.y+positions[i][1]
                                    });
                                    shard.team = -100;
                                    shard.define(Class.splitterSummoner);
                                    shard.name = names[i];
                                    shard.settings.broadcastMessage = "A Splitter Summoner has been defeated!";
                                }
                            }
                            break;

                case "Snowflake":
                    this.onDead = () => {
                        sockets.broadcast("A Snowflake may have been defeated, but the battle is not over yet...");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("Snowflake Shards have spawned to avenge the Snowflake!");
                            let positions = [
                                [x, y + 100, 0, 100],
                                [x + 86.602, y + 50, 86.602, 50],
                                [x + 86.602, y - 50, 86.602, -50],
                                [x, y - 100, 0, -100],
                                [x - 86.602, y - 50, -86.602, -50],
                                [x - 86.602, y + 50, -86.602, 50]
                            ],
                                names = ran.chooseBossName("a", 7);
                            for (let i = 0; i < 6; i++) {
                                let shard = new Entity({
                                    x: positions[i][0],
                                    y: positions[i][1]
                                });
                                shard.team = -100;
                                shard.control.target.x = positions[i][2];
                                shard.control.target.y = positions[i][3];
                                shard.define(Class.snowflakeShard);
                                shard.name = names[i];
                                shard.settings.broadcastMessage = "A Snowflake Shard has been defeated!";
                            }
                            let core = new Entity({
                                x: x,
                                y: y
                            });
                            core.team = -100;
                            core.control.target.x = core.control.target.y = 100;
                            core.define(Class.snowflakeCore);
                            core.settings.broadcastMessage = "A Snowflake Core has been defeated!";
                            core.name = names[2];
                        }, 7500);
                    };
                    break;
                case "triguard":
                    this.onDead = () => {
                        sockets.broadcast("A Triguardian has been defeated, but the battle is not over yet...");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("Answer to me these Guardians three...");
                            for (let i = 0; i < 3; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define(Class.guardianAI);
                            }
                        }, 6000);
                    };
                    break;
                case "XYV":
                    this.onDead = () => {
                        sockets.broadcast("Xyv Wdtcfgzsezgk might have been defeated, but the battle is not over yet...");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("A Summoner, Guardian, and Defender have spawned to avenge the Xyv Wdtcfgzsezgk!");
                            let positions = [
                                [x, y + 100, 0, 100],
                                [x + 86.602, y - 50, 86.602, -50],
                                [x - 86.602, y - 50, -86.602, -50]
                            ],
                                names = ran.chooseBossName("a", 3);
                            for (let i = 0; i < 3; i++) {
                                let boss = new Entity({
                                    x: positions[i][0],
                                    y: positions[i][1]
                                });
                                boss.team = -100;
                                boss.define([Class.guardianAI, Class.summonerAI, Class.defenderAI][i]);
                                boss.name = names[i];
                            }
                        }, 7500);
                    };
                    break;
                case "Anti-Life":
                    this.onDead = () => {
                        sockets.broadcast("Beware the Anti-Life.");
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                            sockets.broadcast("Beware the Anti-Life eternally...");
                            for (let i = 0; i < 48; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define([Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI, Class.guardianAI, Class.summonerAI, Class.defenderAI][i]);
                            }
                        }, 7500);
                    };
                    break;
                case "supernova":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 12; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define([Class.quasarAI, Class.quasarAI, Class.pulsarAI, Class.magnetarAI, Class.magnetarAI, Class.magnetarAI, Class.pulsarAI, Class.magnetarAI, Class.pulsarAI, Class.magnetarAI, Class.pulsarAI, Class.magnetarAI][i]);
                        }
                    };
                    break;
                case "quintet":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        setTimeout(() => {
                        sockets.broadcast("The Guardians have arrived.");
                        for (let i = 0; i < 6; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define([Class.guardianAI, Class.guardianAI, Class.guardianAI, Class.guardianAI, Class.guardianAI, Class.pentaguardianAI][i]);
                        }
                    }, 3000);
                };
                break;
                case "pentaguardian":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                            setTimeout(() => {
                            sockets.broadcast("The Guardians have arrived.");
                            for (let i = 0; i < 5; i++) {
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.define(Class.guardianAI);
                            }
                        }, 3000);
                    };
                    break;
                case "hendecagon":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }];
                        for (let i = 0; i < 3; i++) {
                            let o = new Entity(positions[i]);
                            o.team = this.team;
                            o.define([Class.crasher, Class.square, Class.triangle][i]);
                        }
                    };
                    break;
                case "es5":
                    setTimeout(() => {
                        if (this.isAlive()) {
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                let boss1 = new Entity({
                                    x: x + 600,
                                    y: y
                                });
                                boss1.team = this.team;
                                boss1.define(Class.eggSpiritTier1AI);
                                let boss2 = new Entity({
                                    x: x - 600,
                                    y: y
                                });
                                boss2.team = this.team;
                                boss2.define(Class.eggSpiritTier1AI);
                                let boss3 = new Entity({
                                    x: x,
                                    y: y + 600
                                });
                                boss3.team = this.team;
                                boss3.define(Class.eggSpiritTier2AI);
                                let boss4 = new Entity({
                                    x: x,
                                    y: y - 600
                                });
                                boss4.team = this.team;
                                boss4.define(Class.eggSpiritTier3AI);
                            }, 100);
                        }
                    }, 100);
                    break;
                    case "ek5":
                        setTimeout(() => {
                            if (this.isAlive()) {
                                let x = this.x,
                                    y = this.y;
                                setTimeout(() => {
                                    let boss1 = new Entity({
                                        x: x + 600,
                                        y: y
                                    });
                                    boss1.team = this.team;
                                    boss1.define(Class.eggBossTier1AI);
                                    let boss2 = new Entity({
                                        x: x - 600,
                                        y: y
                                    });
                                    boss2.team = this.team;
                                    boss2.define(Class.eggBossTier1AI);
                                    let boss3 = new Entity({
                                        x: x,
                                        y: y + 600
                                    });
                                    boss3.team = this.team;
                                    boss3.define(Class.eggBossTier2AI);
                                    let boss4 = new Entity({
                                        x: x,
                                        y: y - 600
                                    });
                                    boss4.team = this.team;
                                    boss4.define(Class.EK_3AI);
                                }, 100);
                            }
                        }, 100);
                        break;
                    case "ek6":
                        setTimeout(() => {
                            if (this.isAlive()) {
                                let x = this.x,
                                    y = this.y;
                                setTimeout(() => {
                                    let boss1 = new Entity({
                                        x: x + 600,
                                        y: y
                                    });
                                    boss1.team = this.team;
                                    boss1.define(Class.eggBossTier1AI);
                                    let boss2 = new Entity({
                                        x: x - 600,
                                        y: y
                                    });
                                    boss2.team = this.team;
                                    boss2.define(Class.eggBossTier1AI);
                                    let boss3 = new Entity({
                                        x: x,
                                        y: y + 600
                                    });
                                    boss3.team = this.team;
                                    boss3.define(Class.eggBossTier1AI);
                                    let boss4 = new Entity({
                                        x: x,
                                        y: y - 600
                                    });
                                    boss4.team = this.team;
                                    boss4.define(Class.eggBossTier1AI);
                                    let boss5 = new Entity({
                                        x: x + 600,
                                        y: y + 600
                                    });
                                    boss5.team = this.team;
                                    boss5.define(Class.eggBossTier2AI);
                                    let boss6 = new Entity({
                                        x: x - 600,
                                        y: y - 600
                                    });
                                    boss6.team = this.team;
                                    boss6.define(Class.eggBossTier2AI);
                                    let boss7 = new Entity({
                                        x: x - 600,
                                        y: y + 600
                                    });
                                    boss7.team = this.team;
                                    boss7.define(Class.EK_3AI);
                                    let boss8 = new Entity({
                                        x: x + 600,
                                        y: y - 600
                                    });
                                    boss8.team = this.team;
                                    boss8.define(Class.eggBossTier4AI);
                                }, 100);
                            }
                        }, 100);
                        break;
                        case "delta_legion":
                            setTimeout(() => {
                                if (this.isAlive()) {
                                    let x = this.x,
                                        y = this.y;
                                    setTimeout(() => {
                                        let boss1 = new Entity({
                                            x: x + 600,
                                            y: y
                                        });
                                        boss1.team = this.team;
                                        boss1.define(Class.deltaDestroyerAI);
                                        let boss2 = new Entity({
                                            x: x + 600 * Math.cos((2*Math.PI)/7),
                                            y: y + 600 * Math.sin((2*Math.PI)/7)
                                        });
                                        boss2.team = this.team;
                                        boss2.define(Class.deltaGunnerAI);
                                        let boss3 = new Entity({
                                            x: x + 600 * Math.cos((4*Math.PI)/7),
                                            y: y + 600 * Math.sin((4*Math.PI)/7)
                                        });
                                        boss3.team = this.team;
                                        boss3.define(Class.deltaSprayerAI);
                                        let boss4 = new Entity({
                                            x: x + 600 * Math.cos((6*Math.PI)/7),
                                            y: y + 600 * Math.sin((6*Math.PI)/7)
                                        });
                                        boss4.team = this.team;
                                        boss4.define(Class.deltaBattleshipAI);
                                        let boss5 = new Entity({
                                            x: x + 600 * Math.cos((8*Math.PI)/7),
                                            y: y + 600 * Math.sin((8*Math.PI)/7)
                                        });
                                        boss5.team = this.team;
                                        boss5.define(Class.deltaSpawnerAI);
                                        let boss6 = new Entity({
                                            x: x + 600 * Math.cos((10*Math.PI)/7),
                                            y: y + 600 * Math.sin((10*Math.PI)/7)
                                        });
                                        boss6.team = this.team;
                                        boss6.define(Class.deltaTrapGuardAI);
                                        let boss7 = new Entity({
                                            x: x + 600 * Math.cos((12*Math.PI)/7),
                                            y: y + 600 * Math.sin((12*Math.PI)/7)
                                        });
                                        boss7.team = this.team;
                                        boss7.define(Class.deltaSpinnerAI);
                                    }, 100);
                                }
                            }, 100);
                        break;
                        case "moon":
                            this.onDead = () => {
                                let x = this.x,
                                    y = this.y;
                                setTimeout(() => {
                                    sockets.broadcast("The remnants of the Moon have activated!");
                                    let core = new Entity({
                                        x: x,
                                        y: y
                                    });
                                    core.team = this.team;
                                    core.define(Class.moonCoreAI);
                                    let boss1 = new Entity({
                                        x: x + 600,
                                        y: y
                                    });
                                    boss1.team = this.team;
                                    boss1.define(Class.moonShardAAI);
                                    let boss2 = new Entity({
                                        x: x - 600,
                                        y: y
                                    });
                                    boss2.team = this.team;
                                    boss2.define(Class.moonShardAAI);
                                    let boss3 = new Entity({
                                        x: x,
                                        y: y + 600
                                    });
                                    boss3.team = this.team;
                                    boss3.define(Class.moonShardAAI);
                                    let boss4 = new Entity({
                                        x: x,
                                        y: y - 600
                                    });
                                    boss4.team = this.team;
                                    boss4.define(Class.moonShardAAI);
                                    let boss5 = new Entity({
                                        x: x + 600,
                                        y: y + 600
                                    });
                                    boss5.team = this.team;
                                    boss5.define(Class.moonShardBAI);
                                    let boss6 = new Entity({
                                        x: x - 600,
                                        y: y - 600
                                    });
                                    boss6.team = this.team;
                                    boss6.define(Class.moonShardBAI);
                                    let boss7 = new Entity({
                                        x: x - 600,
                                        y: y + 600
                                    });
                                    boss7.team = this.team;
                                    boss7.define(Class.moonShardBAI);
                                    let boss8 = new Entity({
                                        x: x + 600,
                                        y: y - 600
                                    });
                                    boss8.team = this.team;
                                    boss8.define(Class.moonShardBAI);
                                }, 4900);
                            }
                        break;
                    case "eggfake":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                let boss = new Entity({
                                    x: this.x,
                                    y: this.y
                                });
                                sockets.broadcast("An Ultra Cannon has arrived.");
                                boss.team = this.team;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.ultraCannonAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss"; //kinda?
                                boss.sandboxId = this.sandboxId;
                            }, 3000);
                        };
                        break;
                case "crush":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;;
                        for (let i = 0; i < 3; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.crusherShards);
                        }
                    };
                    break;
                case "iceCrush":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 3; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.iceCrusherShards);
                        }
                    };
                    break;
                case "collide":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 3; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = this.team;
                            crash.define(Class.messengerAI);
                        }
                    };
                    break;
                case "coldcollide":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 3; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = this.team;
                            crash.define(Class.icemessengerAI);
                        }
                    };
                    break;
                case "boomCrusher":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 6; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.boomCrusherShards14);
                        }
                        for (let i = 0; i < 2; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.boomCrusherShards0);
                        }
                        for (let i = 0; i < 4; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.boomCrusherShards);
                        }
                    };
                    break;
                case "betapentaexplode":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 11; i++) {
                            let egg = new Entity({
                                x: x,
                                y: y
                            });
                            egg.team = this.team;
                            egg.define(Class.egggood);
                        }
                        for (let i = 0; i < 8; i++) {
                            let square = new Entity({
                                x: x,
                                y: y
                            });
                            square.team = this.team;
                            square.define(Class.squarebad);
                        }
                        for (let i = 0; i < 3; i++) {
                            let triangle = new Entity({
                                x: x,
                                y: y
                            });
                            triangle.team = this.team;
                            triangle.define(Class.triangleugly);
                        }
                        for (let i = 0; i < 1; i++) {
                            let triangle = new Entity({
                                x: x,
                                y: y
                            });
                            triangle.team = this.team;
                            triangle.define(Class.fuckinpentagon);
                        }
                    };
                    break;
                case "splitHexagon":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 2; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.trapezoidCrasher);
                        }
                    };
                    break;
                case "splitPentagon":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 5; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.crasher);
                        }
                    };
                    break;
                case "crashfuck":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 50; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.crasher);
                        }
                    };
                    break;
                case "elitefuck":
                    this.onDead = () => {
                        let elites = [Class.eliteBorerAI,
            Class.eliteDestroyerAI,
            Class.eliteGunnerAI, 
            Class.eliteSprayerAI, 
            Class.eliteTwinAI, 
            Class.eliteMachineAI, 
            Class.eliteTrapAI,
            Class.eliteSniperAI, 
            Class.eliteBasicAI, 
            Class.eliteInfernoAI,
            Class.eliteSidewindAI,
            Class.elitePelleterAI,
            Class.eliteEngieAI,
            Class.cutterAI,
            Class.alphaSentryAI]
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 50; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(elites[i % elites.length]);
                        }
                    };
                    break;
                case "splitBetaPentagon":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 5; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.sentryAI);
                        }
                    };
                    break;
                case "splitTriangle":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 4; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.redRunner1);
                        }
                    };
                    break;
                case "splitTriangleBoss":
                    this.onDead = () => {
                        sockets.broadcast("A Red Burst has split!");
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 4; i++) {
                            let boss = new Entity({
                                x: x,
                                y: y
                            });
                            boss.team = this.team;
                            boss.define(Class.rs1AI);
                        }
                    };
                    break;
                case "splitSquare":
                case "splitSquare2":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 4; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.summonerSquare);
                        }
                    };
                    break;
                case "greensplitSquare":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 4; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = this.team;
                            crash.define(Class.greensummonerSquare);
                        }
                    };
                    break;
                case "splitSplitSquare":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }];
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define(Class.splitterSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                    };
                    break;
                  case "hypersplitsquare":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y,
                                positions = [{
                                    x: x - 10,
                                    y: y - 10
                                }, {
                                    x: x - 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y - 10
                                }];
                            for (let i = 0; i < 4; i++) {
                                let shape = new Entity(positions[i]);
                                shape.team = -100;
                                shape.define(Class.splitterSplitterSquare);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                        };
                        break;
                    case "omegasplitsquare":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y,
                                positions = [{
                                    x: x - 10,
                                    y: y - 10
                                }, {
                                    x: x - 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y - 10
                                }];
                            for (let i = 0; i < 4; i++) {
                                let shape = new Entity(positions[i]);
                                shape.team = -100;
                                shape.define(Class.wtfsplittersquare);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                        };
                        break;
                    case "bruhsplitsquare":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y,
                                positions = [{
                                    x: x - 10,
                                    y: y - 10
                                }, {
                                    x: x - 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y - 10
                                }];
                            for (let i = 0; i < 4; i++) {
                                let shape = new Entity(positions[i]);
                                shape.team = -100;
                                shape.define(Class.fuckingstopsplittersquare);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                        };
                        break;
                    case "theendsplitsquare":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y,
                                positions = [{
                                    x: x - 10,
                                    y: y - 10
                                }, {
                                    x: x - 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y - 10
                                }];
                            for (let i = 0; i < 4; i++) {
                                let shape = new Entity(positions[i]);
                                shape.team = -100;
                                shape.define(Class.finalsplittersquare);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                        };
                        break;
                case "greensplitSplitSquare":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }];
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define(Class.greensplitterSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                    };
                    /*

                    */
                    break;
                case "ascendedsplitsquare":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y + 10
                            }, {
                                x: x + 10,
                                y: y - 10
                            }];
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define(Class.ascendedSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        sockets.broadcast("An Ascended Splitter Square has been destroyed!");
                    };
                break;
                case "splitSplitTriangle":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x - 5,
                                y: y + 5
                            }, {
                                x: x + 10,
                                y: y + 10
                            }];
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define(Class.splitterTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                    };
                    break;
                case "ribbonsplit":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            positions = [{
                                x: x - 10,
                                y: y - 10
                            }, {
                                x: x,
                                y: y
                            }, {
                                x: x + 10,
                                y: y + 10
                            }];
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity(positions[i]);
                            shape.team = -100;
                            shape.define([Class.stringPolygon, Class.knotPoly, Class.stringPolygon][i]);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                    };
                    break;
                    case "splitSplitPentagon":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y,
                                positions = [{
                                    x: x,
                                    y: y
                                }, {
                                    x: x - 10,
                                    y: y - 10
                                }, {
                                    x: x - 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y + 10
                                }, {
                                    x: x + 10,
                                    y: y - 10
                                }];
                            for (let i = 0; i < 5; i++) {
                                let shape = new Entity(positions[i]);
                                shape.team = -100;
                                shape.define(Class.splitterPentagon);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                        };
                        break;
                case "groupers":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 4; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            });
                            crash.team = -100;
                            crash.define(Class.grouperCrasher);
                        }
                    };
                    this.kill();
                    break;
                case "defender":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(Math.random() * 6 + 1) + 2;
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = -100;
                            crash.define(Class.bladeCrasher);
                        }
                    };
                    break;
                case "greendefender":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(Math.random() * 6 + 1) + 2;
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.poisonBlades);
                        }
                    };
                    break;
                case "friedsummon":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(Math.random() * 1000);
                        if (rand > 999) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.ascendedSquare);
                            }
                        }
                        else if (rand > 996) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.obsidianEgg);
                            }
                        }
                        else if (rand > 960) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.betaFriedEgg);
                            }
                        }
                        else if (rand > 900) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.friedEgg);
                            }
                        }
                        else if (rand > 800) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.square);
                            }
                        }
                        else if (rand > 790) { 
                          for (let i = 0; i < 10; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.egg);
                            }
                        }
                        else if (rand > 789) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.friedHardshellEgg);
                            }
                        }
                        else if (rand > 780) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.hardshellegg);
                            }
                        }
                        else if (rand > 750) { 
                          for (let i = 0; i < 5; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.egg);
                            }
                        }
                        else if (rand > 600) { 
                          for (let i = 0; i < 1; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.egg);
                            }
                        }
                        else if (rand > 590) { 
                          for (let i = 0; i < 3; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.friedEgg);
                            }
                        }
                        else if (rand > 590) { 
                          for (let i = 0; i < 3; i++) {
                              let crash = new Entity({
                                    x: x,
                                    y: y
                               })
                              crash.team = this.team;
                              crash.define(Class.friedEgg);
                            }
                        }
                    };
                    break;
                case "ascendedsquare":
                    this.onDead = () => {
                        sockets.broadcast("An Ascended Square has been destroyed!");
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(2);
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.obsidianSquare);
                        }
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.ivorySquare);
                        }
                    };
                    break;
                case "ascendedtriangle":
                    this.onDead = () => {
                        sockets.broadcast("+Enraged");
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(1);
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.enragedAscendedTriangle);
                        }
                    };
                    break;
                case "enragedascendedtriangle":
                    this.onDead = () => {
                        sockets.broadcast("An Ascended Triangle has been destroyed!");
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(6);
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.redRunner4);
                        }
                    };
                    break;
                case "enragedeye":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(1);
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.enragedEyeSentry);
                        }
                    };
                    break;
                case "ascendedpentagon":
                    this.onDead = () => {
                        sockets.broadcast("An Ascended Pentagon has been destroyed!");
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(1);
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.obsidianPentagon);
                        }
                    };
                    break;
                    case "ascendedtriangle2":
                        this.onDead = () => {
                            sockets.broadcast("+Enraged");
                            let x = this.x,
                                y = this.y,
                                rand = Math.floor(1);
                            for (let i = 0; i < rand; i++) {
                                let crash = new Entity({
                                    x: x,
                                    y: y
                                })
                                crash.team = this.team;
                                crash.define(Class.enragedAscendedDefenderAI);
                            }
                        };
                        break;
                case "enragedascendedtriangle2":
                    this.onDead = () => {
                        sockets.broadcast("An Ascended Defender has been destroyed!");
                        let x = this.x,
                            y = this.y,
                            rand = Math.floor(6);
                        for (let i = 0; i < rand; i++) {
                            let crash = new Entity({
                                x: x,
                                y: y
                            })
                            crash.team = this.team;
                            crash.define(Class.redRunner4);
                        }
                    };
                    break;
                case "eggColony":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 6; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 3),
                                y: y + 200 * Math.sin(i * Math.PI / 3)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 3);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 3);
                            crash.define(Class.eggCrasher);
                        }
                        for (let i = 0; i < 20; i++) {
                            let shape = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 10),
                                y: y + 250 * Math.sin(i * Math.PI / 10)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 250 * Math.cos(i * Math.PI / 10);
                            shape.control.target.y = 250 * Math.sin(i * Math.PI / 10);
                            shape.define(Class.egg);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 100 * Math.cos(i * Math.PI / 2),
                                y: y + 100 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 100 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 100 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.hardshellegg);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                    };
                    this.kill();
                    break;
                case "squareColony":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 6; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 3),
                                y: y + 200 * Math.sin(i * Math.PI / 3)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 3);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 3);
                            crash.define(Class.summonerSquare);
                        }
                        for (let i = 0; i < 3; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 1.5),
                                y: y + 200 * Math.sin(i * Math.PI / 1.5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 1.5);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 1.5);
                            crash.define(Class.cashCrash);
                        }
                        for (let i = 0; i < 2; i++) {
                            let shape = new Entity({
                                x: x + 100 * Math.cos(i * Math.PI / 1),
                                y: y + 100 * Math.sin(i * Math.PI / 1)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 100 * Math.cos(i * Math.PI / 1);
                            shape.control.target.y = 100 * Math.sin(i * Math.PI / 1);
                            shape.define(Class.splitterSplitterSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 125 * Math.cos(i * Math.PI / 2),
                                y: y + 125 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 125 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 125 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.splitterSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 125 * Math.cos(i * Math.PI / 2),
                                y: y + 125 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 125 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 125 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.lavenderSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 26; i++) {
                            let shape = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 13),
                                y: y + 400 * Math.sin(i * Math.PI / 13)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 150 * Math.cos(i * Math.PI / 13);
                            shape.control.target.y = 150 * Math.sin(i * Math.PI / 13);
                            shape.define(Class.square);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 5; i++) {
                            let shape = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                y: y + 275 * Math.sin(i * Math.PI / 2.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                            shape.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                            shape.define(Class.greenSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 300 * Math.cos(i * Math.PI / 2),
                                y: y + 300 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 300 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 300 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.boomsquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 1.5),
                                y: y + 250 * Math.sin(i * Math.PI / 1.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 250 * Math.cos(i * Math.PI / 1.5);
                            shape.control.target.y = 250 * Math.sin(i * Math.PI / 1.5);
                            shape.define(Class.orangeSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 1; i++) {
                            let shape = new Entity({
                                x: x + 225 * Math.cos(i * Math.PI / 1),
                                y: y + 225 * Math.sin(i * Math.PI / 1)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 225 * Math.cos(i * Math.PI / 1);
                            shape.control.target.y = 225 * Math.sin(i * Math.PI / 1);
                            shape.define(Class.scutiSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 2; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI),
                                y: y + 275 * Math.sin(i * Math.PI)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI);
                            sentry.control.target.y = 275 * Math.sin(i * Math.PI);
                            sentry.define(Class.squareGunSentry);
                        }
                        for (let i = 0; i < 1; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI),
                                y: y
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI);
                            sentry.control.target.y = y;
                            sentry.define(Class.summonerLiteAI);
                        }
                        for (let i = 0; i < 1; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI),
                                y: y
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI);
                            sentry.control.target.y = y;
                            sentry.define(Class.squareSwarmerAI);
                        }
                        for (let i = 0; i < 1; i++) {
                            let sentry = new Entity({
                                x: x,
                                y: y + 275 * Math.cos(i * Math.PI)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = x;
                            sentry.control.target.y = 275 * Math.cos(i * Math.PI);
                            sentry.define(Class.squareSwarmerAI);
                        }
                    };
                    this.kill();
                    break;
                case "triangleColony":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 6; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 3),
                                y: y + 200 * Math.sin(i * Math.PI / 3)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 3);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 3);
                            crash.define(Class.triangleCrasher);
                        }
                        for (let i = 0; i < 3; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 1.5),
                                y: y + 200 * Math.sin(i * Math.PI / 1.5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 1.5);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 1.5);
                            crash.define(Class.poisonBlades);
                        }
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 1.5),
                                y: y + 200 * Math.sin(i * Math.PI / 1.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 200 * Math.cos(i * Math.PI / 1.5);
                            shape.control.target.y = 200 * Math.sin(i * Math.PI / 1.5);
                            shape.define(Class.lavenderTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 8; i++) {
                            let shape = new Entity({
                                x: x + 100 * Math.cos(i * Math.PI / 4),
                                y: y + 100 * Math.sin(i * Math.PI / 4)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 100 * Math.cos(i * Math.PI / 4);
                            shape.control.target.y = 100 * Math.sin(i * Math.PI / 4);
                            shape.define(Class.splitterTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 30; i++) {
                            let shape = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 15),
                                y: y + 400 * Math.sin(i * Math.PI / 15)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 150 * Math.cos(i * Math.PI / 15);
                            shape.control.target.y = 150 * Math.sin(i * Math.PI / 15);
                            shape.define(Class.triangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 5; i++) {
                            let shape = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                y: y + 275 * Math.sin(i * Math.PI / 2.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                            shape.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                            shape.define(Class.greenTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 300 * Math.cos(i * Math.PI / 2),
                                y: y + 300 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 300 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 300 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.boomtriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 1.5),
                                y: y + 250 * Math.sin(i * Math.PI / 1.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 250 * Math.cos(i * Math.PI / 1.5);
                            shape.control.target.y = 250 * Math.sin(i * Math.PI / 1.5);
                            shape.define(Class.orangeTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 1; i++) {
                            let shape = new Entity({
                                x: x - 225 * Math.cos(i * Math.PI / 1),
                                y: y - 225 * Math.sin(i * Math.PI / 1)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 225 * Math.cos(i * Math.PI / 1);
                            shape.control.target.y = 225 * Math.sin(i * Math.PI / 1);
                            shape.define(Class.rightTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 1; i++) {
                            let shape = new Entity({
                                x: x + 225 * Math.cos(i * Math.PI / 1),
                                y: y + 225 * Math.sin(i * Math.PI / 1)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 225 * Math.cos(i * Math.PI / 1);
                            shape.control.target.y = 225 * Math.sin(i * Math.PI / 1);
                            shape.define(Class.carbonFiberTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 3; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 1.5),
                                y: y + 275 * Math.sin(i * Math.PI / 1.5)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI / 1.5);
                            sentry.control.target.y = 275 * Math.sin(i * Math.PI / 1.5);
                            sentry.define(Class.bladeSentryAI);
                        }
                        for (let i = 0; i < 3; i++) {
                            let sentry = new Entity({
                                x: x + 300 * Math.cos(i * Math.PI / 1.5),
                                y: y + 300 * Math.sin(i * Math.PI / 1.5)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 300 * Math.cos(i * Math.PI / 1.5);
                            sentry.control.target.y = 300 * Math.sin(i * Math.PI / 1.5);
                            sentry.define([Class.sentryGunAI, Class.sentryTrapAI, Class.sentrySwarmAI][i]);
                        }
                    };
                    this.kill();
                    break;
                    case "XMAS":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 5; i++) {
                                let shape = new Entity({
                                    x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                    y: y + 275 * Math.sin(i * Math.PI / 2.5)
                                });
                                shape.team = this.team;
                                shape.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                                shape.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                                shape.define(Class.present);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                        };
                        this.kill();
                    break;
                    case "Present":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            let yay = new Entity({
                                x: x,
                                y: y
                            })
                            yay.define(Class[global.exportNames[Math.floor(Math.random() * global.exportNames.length)]])//basically random entity?, yes.
                        }
                    break;
                    case "voidColony":
                        this.onDead = () => {
                            let x = this.x,
                                y = this.y;
                            for (let i = 0; i < 20; i++) {
                                let crash = new Entity({
                                    x: x + 200 * Math.cos(i * Math.PI / 1.5),
                                    y: y + 200 * Math.sin(i * Math.PI / 1.5)
                                });
                                crash.team = this.team;
                                crash.control.target.x = 200 * Math.cos(i * Math.PI / 1.5);
                                crash.control.target.y = 200 * Math.sin(i * Math.PI / 1.5);
                                crash.define(Class.voidCrasher);
                            }
                            for (let i = 0; i < 3; i++) {
                                let crash = new Entity({
                                    x: x + 200 * Math.cos(i * Math.PI / 1.5),
                                    y: y + 200 * Math.sin(i * Math.PI / 1.5)
                                });
                                crash.team = this.team;
                                crash.control.target.x = 200 * Math.cos(i * Math.PI / 1.5);
                                crash.control.target.y = 200 * Math.sin(i * Math.PI / 1.5);
                                crash.define(Class.ascendedSplitShoe);
                                crash.SIZE = 10
                                crash.color = 19
                                crash.kill()
                            }
                            for (let i = 0; i < 10; i++) {
                                let shape = new Entity({
                                    x: x + 100 * Math.cos(i * Math.PI / 4),
                                    y: y + 100 * Math.sin(i * Math.PI / 4)
                                });
                                shape.team = this.team;
                                shape.control.target.x = 100 * Math.cos(i * Math.PI / 4);
                                shape.control.target.y = 100 * Math.sin(i * Math.PI / 4);
                                shape.define(Class.voidSquare);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                            for (let i = 0; i < 30; i++) {
                                let shape = new Entity({
                                    x: x + 400 * Math.cos(i * Math.PI / 15),
                                    y: y + 400 * Math.sin(i * Math.PI / 15)
                                });
                                shape.team = this.team;
                                shape.control.target.x = 150 * Math.cos(i * Math.PI / 15);
                                shape.control.target.y = 150 * Math.sin(i * Math.PI / 15);
                                shape.define(Class.voidEgg);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                            for (let i = 0; i < 1; i++) {
                                let shape = new Entity({
                                    x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                    y: y + 275 * Math.sin(i * Math.PI / 2.5)
                                });
                                shape.team = this.team;
                                shape.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                                shape.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                                shape.define(Class.voidPentagonAIWeaker);
                                shape.ACCELERATION = .015 / (shape.size * 0.2);
                            }
                            for (let i = 0; i < 4; i++) {
                                let sentry = new Entity({
                                    x: x + 300 * Math.cos(i * Math.PI / 1.5),
                                    y: y + 300 * Math.sin(i * Math.PI / 1.5)
                                });
                                sentry.team = this.team;
                                sentry.control.target.x = 300 * Math.cos(i * Math.PI / 1.5);
                                sentry.control.target.y = 300 * Math.sin(i * Math.PI / 1.5);
                                sentry.define(Class.voidSentry);
                                sentry.color = 19
                            }
                        };
                        this.kill();
                                            break;
                case "pentagonColony":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 5),
                                y: y + 200 * Math.sin(i * Math.PI / 5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 5);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 5);
                            crash.define(Class.pentagonCrasher);
                        }
                        for (let i = 0; i < 20; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 10),
                                y: y + 200 * Math.sin(i * Math.PI / 10)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 10);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 10);
                            crash.define(Class.crasher);
                        }
                        for (let i = 0; i < 10; i++) {
                            let shape = new Entity({
                                x: x + 100 * Math.cos(i * Math.PI / 5),
                                y: y + 100 * Math.sin(i * Math.PI / 5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 100 * Math.cos(i * Math.PI / 5);
                            shape.control.target.y = 100 * Math.sin(i * Math.PI / 5);
                            shape.define(Class.splitterPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 1.5),
                                y: y + 200 * Math.sin(i * Math.PI / 1.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 200 * Math.cos(i * Math.PI / 1.5);
                            shape.control.target.y = 200 * Math.sin(i * Math.PI / 1.5);
                            shape.define(Class.lavenderPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 1; i++) {
                            let shape = new Entity({
                                x: x + 225 * Math.cos(i * Math.PI / 1),
                                y: y + 225 * Math.sin(i * Math.PI / 1)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 225 * Math.cos(i * Math.PI / 1);
                            shape.control.target.y = 225 * Math.sin(i * Math.PI / 1);
                            shape.define(Class.cranberryPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 100 * Math.cos(i * Math.PI / 4),
                                y: y + 100 * Math.sin(i * Math.PI / 4)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 100 * Math.cos(i * Math.PI / 4);
                            shape.control.target.y = 100 * Math.sin(i * Math.PI / 4);
                            shape.define(Class.splitterBetaPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 40; i++) {
                            let shape = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 20),
                                y: y + 400 * Math.sin(i * Math.PI / 20)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 150 * Math.cos(i * Math.PI / 20);
                            shape.control.target.y = 150 * Math.sin(i * Math.PI / 20);
                            shape.define(Class.pentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 10; i++) {
                            let shape = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 5),
                                y: y + 400 * Math.sin(i * Math.PI / 5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 150 * Math.cos(i * Math.PI / 5);
                            shape.control.target.y = 150 * Math.sin(i * Math.PI / 5);
                            shape.define(Class.betaPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 5; i++) {
                            let shape = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                y: y + 275 * Math.sin(i * Math.PI / 2.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                            shape.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                            shape.define([Class.greenPentagon, Class.greenPentagon, Class.greenPentagon, Class.greenBetaPentagon, Class.greenBetaPentagon][i]);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 5; i++) {
                            let shape = new Entity({
                                x: x + 300 * Math.cos(i * Math.PI / 2.5),
                                y: y + 300 * Math.sin(i * Math.PI / 2.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 300 * Math.cos(i * Math.PI / 2.5);
                            shape.control.target.y = 300 * Math.sin(i * Math.PI / 2.5);
                            shape.define(Class.boompentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 3; i++) {
                            let shape = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 1.5),
                                y: y + 250 * Math.sin(i * Math.PI / 1.5)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 250 * Math.cos(i * Math.PI / 1.5);
                            shape.control.target.y = 250 * Math.sin(i * Math.PI / 1.5);
                            shape.define([Class.orangePentagon, Class.orangePentagon, Class.orangeBetaPentagon][i]);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 2; i++) {
                            let shape = new Entity({
                                x: x - 225 * Math.cos(i * Math.PI / 1),
                                y: y - 225 * Math.sin(i * Math.PI / 1)
                            });
                            shape.team = this.team;
                            shape.control.target.x = 225 * Math.cos(i * Math.PI / 1);
                            shape.control.target.y = 225 * Math.sin(i * Math.PI / 1);
                            shape.define(Class.protpentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 5; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                y: y + 275 * Math.sin(i * Math.PI / 2.5)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                            sentry.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                            sentry.define(Class.crusaderCrash);
                        }
                        for (let i = 0; i < 6; i++) {
                            let sentry = new Entity({
                                x: x + 300 * Math.cos(i * Math.PI / 3),
                                y: y + 300 * Math.sin(i * Math.PI / 3)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 300 * Math.cos(i * Math.PI / 3);
                            sentry.control.target.y = 300 * Math.sin(i * Math.PI / 3);
                            sentry.define([Class.sentryGunAI, Class.sentryTrapAI, Class.sentrySwarmAI, Class.sentryGunAI, Class.sentryTrapAI, Class.sentrySwarmAI][i]);
                        }
                    };
                    this.kill();
                    break;
                case "crasherColony":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 30; i++) {
                            let crash = new Entity({
                                x: x + 450 * Math.cos(i * Math.PI / 15),
                                y: y + 450 * Math.sin(i * Math.PI / 15)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 450 * Math.cos(i * Math.PI / 15);
                            crash.control.target.y = 450 * Math.sin(i * Math.PI / 15);
                            crash.define(Class.redRunner1);
                        }
                        for (let i = 0; i < 20; i++) {
                            let crash = new Entity({
                                x: x + 500 * Math.cos(i * Math.PI / 10),
                                y: y + 500 * Math.sin(i * Math.PI / 10)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 500 * Math.cos(i * Math.PI / 10);
                            crash.control.target.y = 500 * Math.sin(i * Math.PI / 10);
                            crash.define(Class.longCrasher);
                        }
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 5),
                                y: y + 200 * Math.sin(i * Math.PI / 5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 5);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 5);
                            crash.define(Class.pentagonCrasher);
                        }
                        for (let i = 0; i < 15; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 7.5),
                                y: y + 200 * Math.sin(i * Math.PI / 7.5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 7.5);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 7.5);
                            crash.define(Class.triangleCrasher);
                        }
                        for (let i = 0; i < 20; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 10),
                                y: y + 200 * Math.sin(i * Math.PI / 10)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 10);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 10);
                            crash.define(Class.eggCrasher);
                        }
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: x + 100 * Math.cos(i * Math.PI / 5),
                                y: y + 100 * Math.sin(i * Math.PI / 5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 100 * Math.cos(i * Math.PI / 5);
                            crash.control.target.y = 100 * Math.sin(i * Math.PI / 5);
                            crash.define(Class.boomCrasher);
                        }
                        for (let i = 0; i < 5; i++) {
                            let crash = new Entity({
                                x: x + 100 * Math.cos(i * Math.PI / 2.5),
                                y: y + 100 * Math.sin(i * Math.PI / 2.5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 100 * Math.cos(i * Math.PI / 2.5);
                            crash.control.target.y = 100 * Math.sin(i * Math.PI / 2.5);
                            crash.define(Class.alphacrasherbutreal);
                        }
                        for (let i = 0; i < 40; i++) {
                            let crash = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 20),
                                y: y + 400 * Math.sin(i * Math.PI / 20)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 150 * Math.cos(i * Math.PI / 20);
                            crash.control.target.y = 150 * Math.sin(i * Math.PI / 20);
                            crash.define(Class.crasher);
                        }
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 5),
                                y: y + 400 * Math.sin(i * Math.PI / 5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 150 * Math.cos(i * Math.PI / 5);
                            crash.control.target.y = 150 * Math.sin(i * Math.PI / 5);
                            crash.define(Class.summonerSquare);
                        }
                        for (let i = 0; i < 5; i++) {
                            let crash = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                y: y + 275 * Math.sin(i * Math.PI / 2.5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                            crash.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                            crash.define(Class.megaCrushCrasher);
                        }
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: x + 300 * Math.cos(i * Math.PI / 2.5),
                                y: y + 300 * Math.sin(i * Math.PI / 2.5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 300 * Math.cos(i * Math.PI / 2.5);
                            crash.control.target.y = 300 * Math.sin(i * Math.PI / 2.5);
                            crash.define(Class.crushCrasher);
                        }
                        for (let i = 0; i < 3; i++) {
                            let crash = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 1.5),
                                y: y + 250 * Math.sin(i * Math.PI / 1.5)
                            });
                            crash.team = this.team;
                            crash.control.target.x = 250 * Math.cos(i * Math.PI / 1.5);
                            crash.control.target.y = 250 * Math.sin(i * Math.PI / 1.5);
                            crash.define(Class.kamikazeCrasher);
                        }
                        for (let i = 0; i < 12; i++) {
                            let sentry = new Entity({
                                x: x - 225 * Math.cos(i * Math.PI / 6),
                                y: y - 225 * Math.sin(i * Math.PI / 6)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 225 * Math.cos(i * Math.PI / 6);
                            sentry.control.target.y = 225 * Math.sin(i * Math.PI / 6);
                            sentry.define(Class.sentryAI);
                        }
                        for (let i = 0; i < 5; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 2.5),
                                y: y + 275 * Math.sin(i * Math.PI / 2.5)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI / 2.5);
                            sentry.control.target.y = 275 * Math.sin(i * Math.PI / 2.5);
                            sentry.define(Class.crusaderCrash);
                        }
                        for (let i = 0; i < 9; i++) {
                            let sentry = new Entity({
                                x: x + 300 * Math.cos(i * Math.PI / 4.5),
                                y: y + 300 * Math.sin(i * Math.PI / 4.5)
                            });
                            sentry.team = this.team;
                            sentry.control.target.x = 300 * Math.cos(i * Math.PI / 4.5);
                            sentry.control.target.y = 300 * Math.sin(i * Math.PI / 4.5);
                            sentry.define([Class.sentryGunAI, Class.sentryTrapAI, Class.sentrySwarmAI, Class.sentryGunAI, Class.sentryTrapAI, Class.sentrySwarmAI, Class.sentryGunAI, Class.sentryTrapAI, Class.sentrySwarmAI][i]);
                        }
                    };
                    this.kill();
                    break;
                case "squareNest":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 12; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 6),
                                y: y + 200 * Math.sin(i * Math.PI / 6)
                            });
                            crash.team = -100;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 6);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 6);
                            crash.define(Class.summonerSquare);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 2 + Math.PI / 4),
                                y: y + 250 * Math.sin(i * Math.PI / 2 + Math.PI / 4)
                            });
                            shape.team = -100;
                            shape.control.target.x = 250 * Math.cos(i * Math.PI / 2 + Math.PI / 4);
                            shape.control.target.y = 250 * Math.sin(i * Math.PI / 2 + Math.PI / 4);
                            shape.define(Class.greenSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 350 * Math.cos(i * Math.PI / 2),
                                y: y + 350 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = -100;
                            shape.control.target.x = 350 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 350 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.splitterSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 20; i++) {
                            let shape = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 10),
                                y: y + 400 * Math.sin(i * Math.PI / 10)
                            });
                            shape.team = -100;
                            shape.control.target.x = 400 * Math.cos(i * Math.PI / 10);
                            shape.control.target.y = 400 * Math.sin(i * Math.PI / 10);
                            shape.define(Class.singularSquare);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 2; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI),
                                y: y + 275 * Math.sin(i * Math.PI)
                            });
                            sentry.team = -100;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI);
                            sentry.control.target.y = 275 * Math.sin(i * Math.PI);
                            sentry.define(Class.squareGunSentry);
                        }
                    };
                    this.kill();
                    break;
                case "triangleNest":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 5),
                                y: y + 200 * Math.sin(i * Math.PI / 5)
                            });
                            crash.team = -100;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 5);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 5);
                            crash.define(Class.crasher);
                        }
                        for (let i = 0; i < 4; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 2),
                                y: y + 200 * Math.sin(i * Math.PI / 2)
                            });
                            crash.team = -100;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 2);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 2);
                            crash.define(Class.redRunner1);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 2),
                                y: y + 250 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = -100;
                            shape.control.target.x = 250 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 250 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.greenTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 8; i++) {
                            let crash = new Entity({
                                x: x + 350 * Math.cos(i * Math.PI / 4),
                                y: y + 350 * Math.sin(i * Math.PI / 4)
                            });
                            crash.team = -100;
                            crash.control.target.x = 350 * Math.cos(i * Math.PI / 4);
                            crash.control.target.y = 350 * Math.sin(i * Math.PI / 4);
                            crash.define(Class.bladeCrasher);
                        }
                        for (let i = 0; i < 20; i++) {
                            let shape = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 10),
                                y: y + 400 * Math.sin(i * Math.PI / 10)
                            });
                            shape.team = -100;
                            shape.control.target.x = 400 * Math.cos(i * Math.PI / 10);
                            shape.control.target.y = 400 * Math.sin(i * Math.PI / 10);
                            shape.define(Class.singularTriangle);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 2; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI),
                                y: y + 275 * Math.sin(i * Math.PI)
                            });
                            sentry.team = -100;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI);
                            sentry.control.target.y = 275 * Math.sin(i * Math.PI);
                            sentry.define(Class.sentryGunAI);
                        }
                    };
                    this.kill();
                    break;
                case "pentagonNest":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 5),
                                y: y + 200 * Math.sin(i * Math.PI / 5)
                            });
                            crash.team = -100;
                            crash.control.target.x = 200 * Math.cos(i * Math.PI / 5);
                            crash.control.target.y = 200 * Math.sin(i * Math.PI / 5);
                            crash.define(Class.semiCrushCrasher);
                        }
                        for (let i = 0; i < 5; i++) {
                            let shape = new Entity({
                                x: x + 200 * Math.cos(i * Math.PI / 2.5),
                                y: y + 200 * Math.sin(i * Math.PI / 2.5)
                            });
                            shape.team = -100;
                            shape.control.target.x = 200 * Math.cos(i * Math.PI / 2.5);
                            shape.control.target.y = 200 * Math.sin(i * Math.PI / 2.5);
                            shape.define(Class.splitterPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let shape = new Entity({
                                x: x + 250 * Math.cos(i * Math.PI / 2),
                                y: y + 250 * Math.sin(i * Math.PI / 2)
                            });
                            shape.team = -100;
                            shape.control.target.x = 250 * Math.cos(i * Math.PI / 2);
                            shape.control.target.y = 250 * Math.sin(i * Math.PI / 2);
                            shape.define(Class.greenPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 8; i++) {
                            let crash = new Entity({
                                x: x + 350 * Math.cos(i * Math.PI / 4),
                                y: y + 350 * Math.sin(i * Math.PI / 4)
                            });
                            crash.team = -100;
                            crash.control.target.x = 350 * Math.cos(i * Math.PI / 4);
                            crash.control.target.y = 350 * Math.sin(i * Math.PI / 4);
                            crash.define(Class.crushCrasher);
                        }
                        for (let i = 0; i < 18; i++) {
                            let shape = new Entity({
                                x: x + 400 * Math.cos(i * Math.PI / 9),
                                y: y + 400 * Math.sin(i * Math.PI / 9)
                            });
                            shape.team = -100;
                            shape.control.target.x = 400 * Math.cos(i * Math.PI / 9);
                            shape.control.target.y = 400 * Math.sin(i * Math.PI / 9);
                            shape.define(Class.singularPentagon);
                            shape.ACCELERATION = .015 / (shape.size * 0.2);
                        }
                        for (let i = 0; i < 4; i++) {
                            let sentry = new Entity({
                                x: x + 275 * Math.cos(i * Math.PI / 2),
                                y: y + 275 * Math.sin(i * Math.PI / 2)
                            });
                            sentry.team = -100;
                            sentry.control.target.x = 275 * Math.cos(i * Math.PI / 2);
                            sentry.control.target.y = 275 * Math.sin(i * Math.PI / 2);
                            sentry.define(Class.sentryGunAI);
                        }
                    };
                    this.kill();
                    break;
                case "crusade":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            size = this.size / 1.25;
                        for (let i = 0; i < 2; i++) {
                            let crash = new Entity({
                                x: size * Math.cos(i * Math.PI / 2) + x,
                                y: size * Math.sin(i * Math.PI / 2) + y
                            });
                            crash.team = -100;
                            crash.define(Class.crusaderCrash);
                            crash.control.target.x = 275 * Math.cos(i * Math.PI / 2);
                            crash.control.target.y = 275 * Math.sin(i * Math.PI / 2);
                            crash.facing += i * Math.PI / 2 + Math.PI;
                        }
                    };
                    break;
                case "longlong": // splitDecagon
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            size = this.size / 1.25;
                        for (let i = 0; i < 10; i++) {
                            let crash = new Entity({
                                x: size * Math.cos(i * Math.PI / 5) + x,
                                y: size * Math.sin(i * Math.PI / 5) + y
                            });
                            crash.team = -100;
                            crash.define(Class.longCrasher);
                            crash.facingType = "looseWithMotion";
                            crash.facing += i * Math.PI / 5 + Math.PI;
                        }
                    };
                    break;
                case "destroyer":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y,
                            crash = new Entity({
                                x: x,
                                y: y
                            });
                        crash.team = -100;
                        crash.define(Class.summonerSquare);
                    };
                    break;
                case "revo":
                    this.master.define(Class.baseThrowerFire)
                    this.onDead = () => {
                        if (this.master.isAlive()) this.master.define(Class.baseThrower);
                    };
                    break;
                    case "harpoon":
                        this.master.define(Class.harpoonNo)
                        this.onDead = () => {
                            if (this.master.isAlive()) this.master.define(Class.harpoon);
                        };
                        break;
                    case "leister":
                        this.master.define(Class.leisterNo)
                        this.onDead = () => {
                            if (this.master.isAlive()) this.master.define(Class.leister);
                        };
                        break;
                case "mei":
                    setTimeout(() => {
                        if (this.isAlive()) this.define(Class.mei);
                    }, 2000);
                    break;
                case "oxy":
                    setTimeout(() => {
                        if (this.isAlive()) this.define(Class.guardianLauncher);
                    }, 2000);
                    break;
                case "oxy2":
                    setTimeout(() => {
                        if (this.isAlive()) this.define(Class.miniGuardianLauncher);
                    }, 2000);
                    break;
                case "secret service":
                    setTimeout(() => {
                        if (this.isAlive()) {
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                let boss1 = new Entity({
                                    x: x + 450,
                                    y: y
                                });
                                boss1.team = this.team;
                                boss1.define(Class.confidentialAI);
                                boss1.name = 'Agent';
                                let boss2 = new Entity({
                                    x: x - 450,
                                    y: y
                                });
                                boss2.team = this.team;
                                boss2.define(Class.at4_bwAI);
                                boss2.name = 'Agent';
                            }, 100);
                        }
                    }, 100);
                    break;
                case "oppress": 
                    if (this.isAlive()) {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 4; i++) {
                            let tank = new Entity({
                                x: Math.cos(i * Math.PI / 5) + x,
                                y: Math.sin(i * Math.PI / 5) + y
                            });
                            tank.team = this.team;
                            tank.define(Class.keeperAI);
                        }
                    };
                    break;
                case "ENRAGED":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 1; i++) {
                            let enraged = new Entity({
                                x: x,
                                y: y
                            });
                            enraged.team = this.team;
                            enraged.define(Class.enragedmorningstarAI);
                        }
                    };
                    break;
                case "scorchedmorn":
                    this.onDead = () => {
                        let x = this.x,
                            y = this.y;
                        for (let i = 0; i < 1; i++) {
                            let enraged = new Entity({
                                x: x,
                                y: y
                            });
                            enraged.team = this.team;
                            enraged.define(Class.scorchedmorningstarAI);
                        }
                    };
                    break;
                case "mk6":
                    setTimeout(() => {
                        if (this.isAlive()) {
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                let boss1 = new Entity({
                                    x: x + 600,
                                    y: y
                                });
                                boss1.team = this.team;
                                boss1.define(Class.mk1AI);
                                let boss2 = new Entity({
                                    x: x - 600,
                                    y: y
                                });
                                boss2.team = this.team;
                                boss2.define(Class.mk2AI);
                                let boss3 = new Entity({
                                    x: x,
                                    y: y + 600
                                });
                                boss3.team = this.team;
                                boss3.define(Class.mk3AI);
                                let boss4 = new Entity({
                                    x: x,
                                    y: y - 600
                                });
                                boss4.team = this.team;
                                boss4.define(Class.mk4AI);
                            }, 100);
                        }
                    }, 100);
                    break;
                case "pk6":
                    setTimeout(() => {
                        if (this.isAlive()) {
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                let boss1 = new Entity({
                                    x: x + 600,
                                    y: y
                                });
                                boss1.team = this.team;
                                boss1.define(Class.pk1AI);
                                let boss2 = new Entity({
                                    x: x - 600,
                                    y: y
                                });
                                boss2.team = this.team;
                                boss2.define(Class.pk2AI);
                                let boss3 = new Entity({
                                    x: x,
                                    y: y + 600
                                });
                                boss3.team = this.team;
                                boss3.define(Class.pk3AI);
                                let boss4 = new Entity({
                                    x: x,
                                    y: y - 600
                                });
                                boss4.team = this.team;
                                boss4.define(Class.pk4AI);
                            }, 100);
                        }
                    }, 100);
                    break;
                case null:
                case undefined:
                    break;
                default:
                    util.warn("Invalid boss type: " + set.BOSS_TYPE + "!");
                }
            if (set.SANCTUARY_TYPE != null && set.SANCTUARY_TYPE !== "None") {
                this.sanctuaryType = set.SANCTUARY_TYPE;
                sockets.broadcast(util.addArticle(set.SANCTUARY_TYPE, true) + " Sanctuary has spawned!");
                this.miscIdentifier = "appearOnMinimap";
                switch (set.SANCTUARY_TYPE) {
                    case "Egg":
                        this.onDead = () => {
                            sockets.broadcast("The Egg Sanctuary seems to have left something in its demise...","#ffffff");
                            let x = this.x,
                                y = this.y;
                            //smoke(6000, x, y);
                            setTimeout(() => {
                                let boss = new Entity({
                                    x: this.x,
                                    y: this.y
                                });
                                sockets.broadcast("An EK-1 has spawned to avenge the Egg Sanctuary!");
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.eggBossTier1AI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                                setTimeout(() => {
                                    if (boss.isAlive()) {
                                        sockets.broadcast("The EK-1's wrath has remained unhindered for too long; it appears to be evolving...");
                                        setTimeout(() => {
                                            if (boss.isAlive()) {
                                                for (let i = 1; i < 22; i++) setTimeout(() => {
                                                    if (boss.isAlive()) {
                                                        boss.define(Class[`ekAnim${i}`]);
                                                        if (i === 21) boss.define(Class.eggBossTier2AI);
                                                    }
                                                }, 36 * i);
                                                boss.miscIdentifier = "Sanctuary Boss";
                                                sockets.broadcast("The EK-1 has evolved into an EK-2!");
                                            } else sockets.broadcast("The EK-1 has been consoled just in time...");
                                        }, 6000);
                                    }
                                }, 6e5);
                            }, 6000);
                        };
                        break;
                    case "Snowball":
                        this.onDead = () => {
                            sockets.broadcast("The Snowball Sanctuary seems to have left something in its demise...","#02ffee");
                            let x = this.x,
                                y = this.y;
                            //smoke(6000, x, y);
                            setTimeout(() => {
                                let boss = new Entity({
                                    x: this.x,
                                    y: this.y
                                });
                                sockets.broadcast("A Snowflake has spawned to avenge the Egg Sanctuary!");
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.snowflakeAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Square":
                        this.onDead = () => {
                            sockets.broadcast("The Square Sanctuary seems to have left something in its demise...","#ffe46b");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Summoner has spawned to avenge the Square Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.summonerAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Triangle":
                        this.onDead = () => {
                            sockets.broadcast("The Triangle Sanctuary seems to have left something in its demise...","#df5d00");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Defender has spawned to avenge the Triangle Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.defenderAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Pentagon":
                        this.onDead = () => {
                            sockets.broadcast("The Pentagon Sanctuary seems to have left something in its demise...","#7488f0");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Leviathan has spawned to avenge the Pentagon Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.leviathanAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Burnt":
                        this.onDead = () => {
                            sockets.broadcast("The Golden Sanctuary seems to have left something in its demise...","#fac577");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Golden Nonagon has spawned!");
                                let poly = new Entity({
                                    x: this.x,
                                    y: this.y
                                });
                                poly.team = -100;
                                poly.define(Class.burntNonagon);
                                poly.ACCELERATION = .015 / (poly.size * 0.2);
                                poly.miscIdentifier = "Sanctuary Boss";
                                poly.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Bow":
                        this.onDead = () => {
                            sockets.broadcast("The Bowed Sanctuary seems to have left something in its demise...","#eba300");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Bow has spawned to avenge the Bowed Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.bowAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Crasher":
                        this.onDead = () => {
                            sockets.broadcast("The Crasher Sanctuary seems to have left something in its demise...","#f177dd");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Guardian has spawned to avenge the Crasher Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.guardianAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Egg Sanctuary"://mine :)
                        this.onDead = () => {
                            sockets.broadcast("The Egg Sanctuary Sanctuary seems to have something surprising in its demise.........","#fffffff");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("An EK-5 has spawned to avenge the egg Sanctuary Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.eggBossTier5AI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Flower"://mine :)
                        this.onDead = () => {
                            sockets.broadcast("The flower sanctuary seems to suddently bloom!","yellow");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Cute Little Flower has spawned to avenge the flower sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.flowerAI);//temp
                                boss.name = ran.chooseBossName("player", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Sneaky"://mine :)
                        this.onDead = () => {
                            sockets.broadcast("The sneaky sanctuary has been busted... the invisible will rise...");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("The evil shadows arrived to put an end to this world!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = -100;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.supremeChaosMakerAI);
                                boss.name = ran.chooseBossName("customElite", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Elite":
                        this.onDead = () => {
                            sockets.broadcast("The Elite Sanctuary seems to have left something in its demise...","#ff00d4");
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Quintet has spawned to avenge the Elite Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.quintetAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 6000);
                        };
                        break;
                    case "Multi":
                        this.onDead = () => {
                            sockets.broadcast("The Multi Sanctuary seems to have left something in its demise...",'rainbow');
                            let x = this.x,
                                y = this.y;
                            setTimeout(() => {
                                sockets.broadcast("A Polyamorous has spawned to avenge the Multi Sanctuary!");
                                let boss = new Entity({
                                    x: x,
                                    y: y
                                });
                                boss.team = this.team;
                                boss.control.target.x = boss.control.target.y = 100;
                                boss.define(Class.polyamorousAI);
                                boss.name = ran.chooseBossName("a", 1)[0];
                                boss.miscIdentifier = "Sanctuary Boss";
                                boss.sandboxId = this.sandboxId;
                            }, 7000);
                        };
                        break;
                    default:
                        util.warn("Invalid sanctuary type: " + this.sanctuaryType + "!");
                        this.miscIdentifier = this.sanctuaryType = "None";
                }
            }
                if (set.UPGRADES_TIER_1 != null)
                    for (let e of set.UPGRADES_TIER_1) this.upgrades.push({
                        class: exportNames[e.index],
                        level: c.LEVEL_ZERO_UPGRADES ? 0 : 15,
                        index: e.index,
                        tier: 1
                    });
                if (set.UPGRADES_TIER_2 != null)
                    for (let e of set.UPGRADES_TIER_2) this.upgrades.push({
                        class: exportNames[e.index],
                        level: c.LEVEL_ZERO_UPGRADES ? 0 : 30,
                        index: e.index,
                        tier: 2
                    });
                if (set.UPGRADES_TIER_3 != null)
                    for (let e of set.UPGRADES_TIER_3) this.upgrades.push({
                        class: exportNames[e.index],
                        level: c.LEVEL_ZERO_UPGRADES ? 0 : 45,
                        index: e.index,
                        tier: 3
                    });
                if (set.UPGRADES_TIER_4 != null)
                    for (let e of set.UPGRADES_TIER_4) this.upgrades.push({
                        class: exportNames[e.index],
                        level: c.LEVEL_ZERO_UPGRADES ? 0 : 60,
                        index: e.index,
                        tier: 4
                    });
                if (set.UPGRADES_TIER_5 != null)
                    for (let e of set.UPGRADES_TIER_5) this.upgrades.push({
                        class: exportNames[e.index],
                        level: c.LEVEL_ZERO_UPGRADES ? 0 : 60,
                        index: e.index,
                        tier: 5
                    });
                if (set.SIZE != null) {
                    this.SIZE = set.SIZE * this.squiggle;
                    if (this.coreSize == null) this.coreSize = this.SIZE;
                }
                if (set.SKILL != null && set.SKILL.length > 0) {
                    if (set.SKILL.length !== 10) throw ("Invalid skill raws!");
                    this.skill.set(set.SKILL);
                }
                if (set.LEVEL != null) {
                    if (set.LEVEL === -1) this.skill.reset();
                    while (this.skill.level < c.SKILL_CHEAT_CAP && this.skill.level < set.LEVEL) {
                        this.skill.score += this.skill.levelScore;
                        this.skill.maintain();
                    }
                    this.refreshBodyAttributes();
                }
                if (set.SKILL_CAP != null && set.SKILL_CAP.length > 0) {
                    if (set.SKILL_CAP.length !== 10) throw ("Invalid skill caps!");
                    this.skill.setCaps(set.SKILL_CAP);
                }
                if (set.VALUE != null) this.skill.score = Math.max(this.skill.score, set.VALUE * this.squiggle);
                if (set.LABEL_OVERRIDE != null) this.labelOverride = set.LABEL_OVERRIDE
                if (set.SCOPED != null) {
                  this.scoped = set.SCOPED;
                  //this.scopedMult = 1
                }
                /*if (set.CAMERA_TO_MOUSE != null) {
                  this.scoped = true,
                  this.scopedMult = set.CAMERA_TO_MOUSE[1] - 1
                }*/
                if (set.ENTRY) {
                  if(c.serverName.includes("The Shattered Beyond")) {
                    if (set.LABEL == undefined) {
                      this.labelOverride = this.label + " - " + set.ENTRY[0]
                    } else {
                    this.labelOverride = set.LABEL + " - " + set.ENTRY[0]
                    }
                  }
                  this.vacoEntry = set.ENTRY[0]
                  this.scienceValue = set.ENTRY[1]
                }
                this.altCameraSource = false
                if (set.GUNS != null) {
                    let newGuns = [];
                    let i = 0;
                    for (let def of set.GUNS) {
                        newGuns.push(new Gun(this, def, i));
                        i++;
                    }
                    this.guns = newGuns;
                }
                if (set.LASERS != null) {
                    let newLasers = [];
                    for (let def of set.LASERS) newLasers.push(new Laser(this, def));
                    this.lasers = newLasers;
                }
                if (set.PROPS != null) {
                    let newProps = [];
                    for (let def of set.PROPS) newProps.push(new Prop(def));
                    this.props = newProps;
                }
                if (set.MAX_CHILDREN != null) this.maxChildren = set.MAX_CHILDREN;
                if (set.COUNTS_OWN_KIDS != null) this.countsOwnKids = set.COUNTS_OWN_KIDS;
                if (set.BODY != null) {
                    if (set.BODY.ACCELERATION != null) this.ACCELERATION = set.BODY.ACCELERATION;
                    if (set.BODY.SPEED != null) this.SPEED = set.BODY.SPEED;
                    if (set.BODY.HEALTH != null) this.HEALTH = set.BODY.HEALTH;
                    if (set.BODY.RESIST != null) this.RESIST = set.BODY.RESIST;//Math.cbrt(Math.max(set.BODY.RESIST, 0));
                    if (set.BODY.SHIELD != null) this.SHIELD = set.BODY.SHIELD;
                    if (set.BODY.REGEN != null) this.REGEN = set.BODY.REGEN;
                    if (set.BODY.DAMAGE != null) this.DAMAGE = set.BODY.DAMAGE;
                    if (set.BODY.PENETRATION != null) this.PENETRATION = set.BODY.PENETRATION;
                    if (set.BODY.FOV != null) this.FOV = set.BODY.FOV;
                    if (set.BODY.RANGE != null) this.RANGE = set.BODY.RANGE;
                    if (set.BODY.SHOCK_ABSORB != null) this.SHOCK_ABSORB = set.BODY.SHOCK_ABSORB;
                    if (set.BODY.DENSITY != null) this.DENSITY = set.BODY.DENSITY;
                    if (set.BODY.STEALTH != null) this.STEALTH = set.BODY.STEALTH;
                    if (set.BODY.PUSHABILITY != null) this.PUSHABILITY = set.BODY.PUSHABILITY;
                    if (set.BODY.HETERO != null) this.heteroMultiplier = set.BODY.HETERO;
                    this.refreshBodyAttributes();
                }
                if (set.TURRETS != null) {
                    for (let o of this.turrets) o.destroy();
                    this.turrets = [];
                    for (let def of set.TURRETS) {
                        let o = new Entity(this, this.master);
                        o.roomId === this.roomId;
                        if (Array.isArray(def.TYPE)) {
                            for (let type of def.TYPE) o.define(type);
                        } else o.define(def.TYPE);
                        o.bindToMaster(def.POSITION, this);
                        if (!def.TARGETABLE_TURRET) {
                            o.dangerValue = 0;
                        } else if (def.TARGETABLE_TURRET > 0) {
                            o.dangerValue = def.TARGETABLE_TURRET;
                        }
                    }
                }
                if (set.DIES_INSTANTLY != null) this.kill();
                if (set.RANDOM_TYPE != null && set.RANDOM_TYPE !== "None") {
                    let choices = [];
                    switch (set.RANDOM_TYPE) {
                        case "Cultist":
                            choices = [Class.trapmind.hivemindID, Class.poundHivemind.hivemindID, Class.psychosisProbe, Class.machHivemind.hivemindID, Class.auto2Probe, Class.propellerHivemind.hivemindID, Class.pelletHivemind.hivemindID, Class.lancemind.hivemindID, Class.flankmind.hivemindID, Class.minishotmind.hivemindID, Class.basebridMind.hivemindID, Class.twinmind.hivemindID, Class.submind.hivemindID].filter(i => !!i);;
                            break;
                        default:
                            util.warn("Invalid RANDOM_TYPE value: " + set.RANDOM_TYPE + "!");
                    }
                    choices = choices.filter(r => !!r);
                    this.define(choices[Math.floor(Math.random() * choices.length)]);
                }
                if (set.ABILITY_IMMUNE != null) this.immuneToAbilities = set.ABILITY_IMMUNE;
                if (set.SPAWNS_DECA != null) this.define(Class.decagon);
                if (set.ALWAYS_ACTIVE != null) this.alwaysActive = set.ALWAYS_ACTIVE;
                if (set.MISC_IDENTIFIER != null) this.miscIdentifier = set.MISC_IDENTIFIER;
                if (set.SWITCHEROO_ID != null) this.switcherooID = set.SWITCHEROO_ID;
                if (set.IS_FULLY_INVINCIBLE != null) {
                    this.isFullyInvincible = set.IS_FULLY_INVINCIBLE
                    if (this.isFullyInvincible) {
                        this.immuneToAbilities = true
                        this.mutation = "cantbeged"
                    }
                } //mine
                if (set.IS_ARENA_CLOSER != null) {
                    this.isArenaCloser = set.IS_ARENA_CLOSER;
                    if (this.isArenaCloser) this.immuneToAbilities = true;
                }
                this.variables = set.VARIABLES ? JSON.parse(JSON.stringify(set.VARIABLES)) : {};
                this.animation = null
                //vewy interessant
                if (this.isShiny){
/*                    this.color = -1
                    this.skill.score *= 3
                    this.SIZE += 2
                    this.label = "Woomy Shiny "+this.label
                    this.settings.givesKillMessage = true*/
                    this.color = Math.floor(100*Math.random()+100)
                    this.skill.score *= 3
                    this.SIZE += 2
                    this.label = "Mimic "+this.label
                    this.settings.givesKillMessage = true
                }
                if (set.MUTATION != null) {
                    this.mutation = set.MUTATION
                    switch (this.mutation)   {
                        case "Misshapen":
                            let SHAPE = [0, 3, 4, 5, 6, 7, -3, -4, -5, -6][Math.floor(Math.random()*10)]
                            this.shape = SHAPE
                            this.shapeData = SHAPE
                            break
                        case "Misscolored":
                            this.color = Math.floor(42 * Math.random())
                            break
                case "Magic": 
                    //this.color = Math.floor(100 * Math.random())
                    this.onTick = (me) => {
                        me.SIZE += 0.01
                        me.skill.score += 1
                    }
                break;
                /* case "Transgender":
                    this.variables.transTimer = 0
                    this.onTick = (me) => {
                        if (me.variables.transTimer <= 45) {
                            me.color = 5
                        } else if (me.variables.transTimer > 45 && me.variables.transTimer <= 60) {
                            me.color = 8
                        }   else if (me.variables.transTimer > 60 && me.variables.transTimer <= 105) {
                            me.color = 0
                        }   else if (me.variables.transTimer > 105 && me.variables.transTimer < 120) {
                            me.color = 8
                        }
                        me.variables.transTimer = (me.variables.transTimer + 1)  % 120
                    }   
                    break;
                case "Epilepsy":
                    this.variables.epilepsyTimer = 0
                    this.onTick = (me) => {
                        if (me.variables.epilepsyTimer <= 0) {
                            me.color = 10
                        } else if (me.variables.epilepsyTimer > 5 && me.variables.epilepsyTimer <= 10) {
                            me.color = 12}
                        me.variables.epilepsyTimer = (me.variables.epilepsyTimer + 1)  % 10
                    }
                    break;
                case "Epilepsy2":
                    this.variables.epilepsyTimer = 0
                    this.onTick = (me) => {
                        if (me.variables.epilepsyTimer <= 0) {
                            me.color = 12
                        } else if (me.variables.epilepsyTimer > 5 && me.variables.epilepsyTimer <= 10) {
                            me.color = 10}
                        me.variables.epilepsyTimer = (me.variables.epilepsyTimer + 1)  % 10
                    }
                    break;
                    case "Elec":
                        this.variables.elecTimer = 0
                        this.onTick = (me) => {
                            if (me.variables.elecTimer <= 0) {
                                me.color = 13
                            } else if (me.variables.elecTimer > 5 && me.variables.elecTimer <= 10) {
                                me.color = 18}
                            me.variables.elecTimer = (me.variables.elecTimer + 1)  % 10
                        }
                        break;
                    case "boom":
                        this.variables.boomTimer = 0
                        this.onTick = (me) => {
                            if (me.variables.boomTimer <= 0) {
                                me.color = 18
                            } else if (me.variables.boomTimer > 5 && me.variables.boomTimer <= 10) {
                                me.color = 53//12}
                            me.variables.boomTimer = (me.variables.boomTimer + 1)  % 10
                        }}
                        break; */
                case "greenGlow":
                    this.variables.glowTimer = 0
                    this.onTick = (me) => {
                        if (me.variables.glowTimer <= 45) {
                            me.color = 1
                        } else if (me.variables.glowTimer > 45 && me.variables.glowTimer <= 60) {
                            me.color = 18
                        }   else if (me.variables.glowTimer > 60 && me.variables.glowTimer <= 105) {
                            me.color = 1
                        }   else if (me.variables.glowTimer > 105 && me.variables.glowTimer < 120) {
                            me.color = 18
                        }
                        me.variables.glowTimer = (me.variables.glowTimer + 1)  % 120
                    }   
                    break;
                case "Ennemy Spawner":
                    this.variables.killTimer = 0
                    this.onTick = (me) => {
                        if (me.variables.killTimer = 2) {
                            me.kill()
                        }
                        me.variables.killTimer = (me.variables.killTimer + 1) % 3 
                    }
                    break;
                    case "Aura":
                        this.isRealAura = true
                        this.godmode = true
                        this.settings.goThruObstacle = true
                            this.onTick = (me) => {
                              me.density = 0
                              me.x = me.master.x
                              me.y = me.master.y
                            }   
                        break;
                    case "SourceAura":
                        this.isRealAura = true
                        this.godmode = true
                        this.settings.goThruObstacle = true
                        this.onTick = (me) => {
                            me.density = 0
                            me.x = me.source.x
                            me.y = me.source.y
                        }   
                        break;
                    case "SourceAuraOnCollide":
                        this.doesNotCollideWithSource = true
                        this.godmode = true
                        this.settings.goThruObstacle = true
                        this.onTick = (me) => {
                            me.density = 0
                            me.x = me.source.x
                            me.y = me.source.y
                        }   
                        break;
                    case "blindAura":
                        this.isRealAura = true;
                        this.settings.goThruObstacle = true
                        this.onTick = (me) => {
                            me.density = 0
                            me.x = me.source.x
                            me.y = me.source.y
                        }   
                        break;
                    case "OldAuraRelativeWeird":
                        this.isRealAura = true
                        this.godmode = true
                        this.settings.goThruObstacle = true
                        this.onTick = (me) => {
                            me.density = 0
                            me.velocity.x = me.source.velocity.x * 1.08
                            me.velocity.y = me.source.velocity.y * 1.08
                        }   
                        break;
                default:
                    break;
            }}
                if(this.evolutionTimeout) clearTimeout(this.evolutionTimeout);
                if (set.EVOLUTIONS?.length){
                    this.evolutionTimeout = setTimeout(()=>{
                        try {
                            if (!this.isAlive()) {
                                return
                            }
                            let options = [];
                            let chances = [];
                            for (let arr of set.EVOLUTIONS) {
                                options.push(arr[0])
                                chances.push(arr[1])
                            }
                            if (Math.random() < c.EVOLVE_HALT_CHANCE) {
                                return
                            }
                            this.define(Class[options[ran.chooseChance(...chances)]])
                        }catch(err){
                            util.error("Error while trying to evolve "+global.exportNames[this.index])
                        }
                    }, (c.EVOLVE_TIME + Math.random() * c.EVOLVE_TIME_RAN_ADDER) * ((this.type === "crasher" || this.isSentry)?0.5:1)) // Crashers evolve 2x as fast
                }
                if (set.ON_DEFINED) set.ON_DEFINED(this, entities, sockets);
            } catch (e) {
                if (this.isBot) console.error(this.tank);
                console.error("An error occured while trying to set " + trimName(this.name) + "'s parent entity, aborting! Index: " + this.index + "."+" Export: "+global.exportNames[this.index]);
                this.sendMessage("An error occured while trying to set your parent entity!");
                console.error(e.stack);
            }
        }
        refreshBodyAttributes() {
            let speedReduce = Math.pow(this.size / (this.coreSize || this.SIZE), 1);
            this.acceleration = c.runSpeed * this.ACCELERATION / speedReduce;
            if (this.settings.reloadToAcceleration) this.acceleration *= this.skill.acl;
            this.topSpeed = c.runSpeed * this.SPEED * this.skill.mob / speedReduce;
            if (this.settings.reloadToAcceleration) this.topSpeed /= Math.sqrt(this.skill.acl);
            this.health.set(((this.settings.healthWithLevel ? 1.5 /* 1.8 */ * this.skill.level : 0) + this.HEALTH) * (this.settings.reloadToAcceleration ? this.skill.hlt * 0.95 /*1.025*/ : this.skill.hlt));
            this.health.resist = 1 - 1 / (Math.max(1, this.RESIST + this.skill.brst)/1.15);//1.15 ? nah lets do 1.275
            this.shield.set(((this.settings.healthWithLevel ? .6 * this.skill.level : 0) + this.SHIELD) * this.skill.shi * (this.settings.reloadToAcceleration ? .85 : 1), Math.max(0, (((this.settings.healthWithLevel ? .006 * this.skill.level : 0) + 1) * this.REGEN) * this.skill.rgn) * (this.settings.reloadToAcceleration ? 0.9 : 1));
            this.damage = this.DAMAGE * (this.settings.reloadToAcceleration ? this.skill.atk * 1.1 /*1.1*/ /*1.25*/ : this.skill.atk)
            this.penetration = this.PENETRATION + 1.5 * (this.skill.brst + 0.8 * (this.skill.atk - 1));//this.PENETRATION + 1.5 * (this.skill.brst + .8 * (this.skill.atk - 1)) * .4;//(this.settings.reloadToAcceleration ? .1 : 1);
            this.range = this.RANGE;
            this.fov = 250 * this.FOV * Math.sqrt(this.size) * (1 + .003 * this.skill.level);
            this.density = (1 + 0.08 * this.skill.level) * this.DENSITY;//(1 + .08 * this.skill.level) * this.DENSITY * 2.334;//(this.settings.reloadToAcceleration ? 5 : 1);
            this.stealth = this.STEALTH;
            this.pushability = this.PUSHABILITY;
            //need to put that somewhere else frfr
            if (c.serverName.includes("Score War")) {
            if (Math.abs(this.team) == 1) {if(room.BPerk1) {this.health.set((this.settings.healthWithLevel ? 1.5 /* 1.8 */ * this.skill.level : 0) + this.HEALTH * 1.2)}} else {if(room.RPerk1 && Math.abs(this.team) == 2) {this.health.set((this.settings.healthWithLevel ? 1.5 /* 1.8 */ * this.skill.level : 0) + this.HEALTH * 1.2)}} 
            if (Math.abs(this.team) == 1) {if(room.BPerk3) {this.damage = this.DAMAGE * (this.settings.reloadToAcceleration ? this.skill.atk * 1.1 * 1.25 /*1.1*/ /*1.25*/ : this.skill.atk * 1.25)}} else {if(room.RPerk3 && Math.abs(this.team) == 2) {this.damage = this.DAMAGE * (this.settings.reloadToAcceleration ? this.skill.atk * 1.1 * 1.25 /*1.1*/ /*1.25*/ : this.skill.atk * 1.25)}}
            }
        }
        refreshFOV() {
            this.fov = 250 * this.FOV * Math.sqrt(this.size) * (1 + .003 * this.skill.level);
        }
        bindToMaster(position, bond) {
            this.bond = bond;
            this.source = bond;
            this.bond.turrets.push(this);
            this.skill = this.bond.skill;
            this.label = this.bond.label + " " + this.label;
            this.neverInGrid = this.settings.hitsOwnType !== "shield";
            //if (this.settings.hitsOwnType !== "shield") this.removeFromGrid();
            this.settings.drawShape = false;
            this.bound = {};
            this.bound.size = .05 * position[0];
            let offset = new Vector(position[1], position[2]);
            this.bound.angle = position[3] * Math.PI / 180;
            this.bound.direction = offset.direction;
            this.bound.offset = offset.length / 10;
            this.bound.arc = position[4] * Math.PI / 180;
            this.bound.layer = position[5];
            if (this.facingType === "toTarget") {
                this.facing = this.bond.facing + this.bound.angle;
                this.facingType = "bound";
            }
            this.motionType = "bound";
            this.move();
            this.isTurret = true;
        }
        get size() {
            //if (this.bond == null) return (this.coreSize || this.SIZE) * (1 + this.skill.level / 60);
            if (this.bond == null) return (this.coreSize || this.SIZE) * (1 + (this.skill.level > c.SKILL_CAP ? c.SKILL_CAP : this.skill.level) / 60);
            return this.bond.size * this.bound.size//return this.isPlayer || this.isBot ? 2*this.bond.size * this.bound.size : 0.5 * this.bond.size * this.bound.size; // le ? est de moi (mine)this.bond.size * this.bound.size
        }
        get mass() {
            return this.density * (this.size * this.size + 1);
        }
        get force() {
            return this.mass * this.acceleration;
        }
        get realSize() {
            return this.size * (Math.abs(this.shape) >= realSizes.length ? 1 : realSizes[Math.abs(this.shape)]);
        }
        get m_x() {
            return (this.velocity.x + this.accel.x) / room.speed;
        }
        get m_y() {
            return (this.velocity.y + this.accel.y) / room.speed;
        }
        get force() { // only for shields 
            return this.mass * ((this.velocity.length * .1) + .5);
                                                          // ^ for explosions
        }
        camera(tur = false) {
            let out = {
                type: tur * 0x01 + this.settings.drawHealth * 0x02 + ((this.type === "tank" || this.type === "utility") && !this.settings.noNameplate) * 0x04 + this.invuln * 0x08,
                id: this.id,
                index: this.index,
                x: this.x,
                y: this.y,
                cx: this.x,
                cy: this.y,
                messages: this.messages,
                vx: this.velocity.x,
                vy: this.velocity.y,
                size: this.size,
                rsize: this.realSize,
                status: 1,
                health: this.health.display(),
                shield: this.shield.display(),
                facing: this.facing,
                vfacing: this.vfacing,
                twiggle: !"toTarget dodgeTank dodgeBig dodgeBetter".includes(this.facingType) || (this.facingType === "lmg" && this.control.fire), //this.facingType === "looseWithMotion" || this.facingType === "smoothWithMotion" || this.facingType === "spinSlowly" || this.facingType === "spinSlowly2" || this.facingType === "spinSlowly3" || this.facingType === "spinSlowly4" || this.facingType === "altSpin" || this.facingType === "fastSpin" || this.facingType === "autospin" || this.facingType === "autospin2" || this.facingType === "reverseAutospin" || this.facingType === "bitFastSpin" || this.facingType === "hadron" || this.facingType === "locksFacing" && this.control.alt || this.facingType === "hatchet" || this.facingType === "altLocksFacing" || this.facingType === "lmg" && this.control.fire,
                layer: this.type === "mazeWall" ? 7 : this.passive && this.LAYER !== -1 ? 1 : this.LAYER === -1 ? this.bond == null ? this.type === "wall" ? 11 : this.type === ("food" || "aquaticFood") ? 10 : this.type === "tank" ? 5 : this.type === "crasher" ? 8 : 0 : this.bound.layer : this.LAYER,
                color: this.color,
                team: this.team,
                name: this.name,
                score: this.skill.score,
                sizeRatio: [this.width || 1, this.height || 1],
                guns: this.guns.map(gun => gun.lastShot),
                turrets: this.turrets.map(turret => turret.camera(true)),
                alpha: this.alpha,
                seeInvisible: this.seeInvisible,
                nameColor: this.nameColor,
                label: this.labelOverride ? this.labelOverride : 0
            };
            /*if (this.scoped) { // maybe try finishing this
                this.cx = out.cx;
                this.cy = out.cy;
                if (!this.control.alt) {
                    if (this.hasScoped) {
                      this.fov = this.currentScopedFOV / this.scopedMult
                      this.hasScoped = false
                    }
                    this.cameraShiftFacing = null;
                } else {
                    this.cameraShiftFacing = true
                    if (!this.hasScoped) {
                      this.currentScopedFOV = this.fov * this.scopedMult
                      this.fov = this.currentScopedFOV
                      this.hasScoped = true
                    }
                    out.cx += this.fov * Math.cos(this.facing) / 3;
                    out.cy += this.fov * Math.sin(this.facing) / 3;
                }
            }*/
            if (this.scoped) {
                this.cx = out.cx;
                this.cy = out.cy;
                if (!this.control.alt) {
                    this.cameraShiftFacing = null;
                } else {
                    this.cameraShiftFacing = true
                    out.cx += this.fov * Math.cos(this.facing) / 3;
                    out.cy += this.fov * Math.sin(this.facing) / 3;
                }
            }
            if (this.altCameraSource && Number(this.altCameraSource[0]) && Number(this.altCameraSource[0])) {
                out.cx = this.altCameraSource[0]
                out.cy = this.altCameraSource[1]
            }
            return out;
        }
        skillUp(stat) {
            let upgrade = this.skill.upgrade(stat);
            if (upgrade) {
                this.refreshBodyAttributes();
                for (let gun of this.guns) gun.syncChildren();
            }
            return upgrade;
        }
        upgrade(number) {
            if (c.serverName.includes("Corrupted Tanks") || this.isCorrputedTank){
                if (number == null){
                    this.define(Class[global.gamemodeCode.generateNewTank()])
                    this.skill.score = 59212
                }else{
                    this.childrenMap.forEach(c=>c.kill())
                    this.define(Class[this.upgrades[number].class])
                }
                this.upgrades = []
                for(let i = 0; i < 3; i++){
                    let newTank = Class[global.gamemodeCode.generateNewTank()]
                    this.upgrades.push({
                        class: exportNames[newTank.index],
                        level: 0,
                        index: newTank.index,
                        tier: 4
                    })
                }
                return
            }
            if (number < this.upgrades.length && this.skill.level >= this.upgrades[number].level) {
                let tank = Class[this.upgrades[number].class];
                this.upgrades = [];
                this.define(tank);
                this.tank = tank;
                if (this.switcherooID === 0 || (this.bossTierType !== -1 && this.bossTierType !== 16)) this.sendMessage("Press Q to switch tiers. There is a 1 second cooldown.");
                if (this.scoped) this.sendMessage("Right click or press shift to move the camera to your mouse.");
                if (this.facingType === "hatchet") {
                  this.sendMessage("The speed of your rotation depends on your Rotation Speed stat.");
                  this.sendMessage("Click spacebar to make the " + this.label + " rotate its facing; hold autofire to make it spin quickly.");
                }
                if (this.settings.hasAnimation === "rmb") this.sendMessage("Right click or press shift to use a special ability.");
                if (this.settings.hasAnimation === "lmb") this.sendMessage("Left click or press space to use a special ability.");
                if (this.isShip) this.sendMessage("You can safely tread over aquatic zones, but you're slower on land.");
                //if (this.usesAltFire) this.sendMessage("Right click or press shift to fire other weapons.");
                this.sendMessage("You have upgraded to " + this.label + ".");
                this.childrenMap.forEach(o => {
                    if (o.settings.clearOnMasterUpgrade && o.master.id === this.id && o.id !== this.id && o !== this) {
                        o.kill();
                    }
                });
                //for (let o of entities)
                //    if (o.settings.clearOnMasterUpgrade && o.master.id === this.id && o.id !== this.id && o !== this) o.kill();
                this.skill.update();
                this.refreshBodyAttributes();
                if (this.stealthMode) {
                    this.settings.leaderboardable = this.settings.givesKillMessage = false;
                    this.alpha = this.ALPHA = 0;
                }
                if (!this.isPlayer) return 0;
                switch (this.label) {
                    case "Smasher": return void this.rewardManager(-1, "where_did_my_cannon_go");
                    case "Mothership": return void this.rewardManager(-1, "miniship");
                    case "Twin": return void this.rewardManager(-1, "fire_power");
                    case "Sniper": return void this.rewardManager(-1, "snipin");
                    case "Machine Gun": return void this.rewardManager(-1, "eat_those_bullets");
                    case "Flank Guard": return void this.rewardManager(-1, "aint_no_one_sneaking_up_on_me");
                    case "Director":
                        this.rewardManager(-1, "mmm_drones_drones_drones");
                        this.rewardManager(10, 1);
                        break;
                    case "Pounder": return void this.rewardManager(-1, "one_shot_bby");
                    case "Single": return void this.rewardManager(-1, "better_basic");
                    case "Pelleter": return void this.rewardManager(-1, "bullet_hell");
                    case "Trapper": return void this.rewardManager(-1, "build_a_wall");
                    case "Propeller": return void this.rewardManager(-1, "zoom");
                    case "Auto-2": return void this.rewardManager(-1, "cant_bother_using_both_hands_to_play");
                    case "Minishot": return void this.rewardManager(-1, "small_barrel_big_dreams");
                    case "Lancer": return void this.rewardManager(-1, "pointy");
                    case "Auto-Basic": return void this.rewardManager(-1, "automation");
                    case "Basebrid": return void this.rewardManager(-1, "wannabe_hybrid");
                    case "Subduer": return void this.rewardManager(-1, "wannabe_hunter");
                    case "Mini Grower": return void this.rewardManager(-1, "they_get_big_i_swear");
                    case "Inceptioner": return void this.rewardManager(-1, "commencement_of_the_inception");
                    case "Hivemind": return void this.rewardManager(-1, "which_one_is_me");
                    case "Switcheroo (Ba)": return void this.rewardManager(-1, "it_wasnt_worth_it");
                }
            }
        }
        upgradeTank(tank) {
            this.upgrades = [];
            this.define(tank);
            this.tank = tank;
            if (this.switcherooID === 0 || (this.bossTierType !== -1 && this.bossTierType !== 16)) this.sendMessage("Press Q to switch tiers. There is a 1 second cooldown.");
            if (this.scoped) this.sendMessage("Right click or press shift to move the camera to your mouse.");
                if (this.facingType === "hatchet") {
                  this.sendMessage("The speed of your rotation depends on your Rotation Speed stat.");
                  this.sendMessage("Click spacebar to make the " + this.label + " rotate its facing; hold autofire to make it spin quickly.");
                }
            if (this.settings.hasAnimation === "rmb") this.sendMessage("Right click or press shift to use an animation ability.");
            if (this.settings.hasAnimation === "lmb") this.sendMessage("Left click or press space to use an animation ability.");
            //if (this.usesAltFire) this.sendMessage("Right click or press shift to fire other weapons.");
            this.sendMessage("You have changed your tank to " + this.label + ".");
            this.skill.update();
            this.refreshBodyAttributes();
            this.children.forEach(o => {
                if (o.settings.clearOnMasterUpgrade && o.id !== this.id) {
                    o.kill();
                }
            });
            if (this.stealthMode) {
                this.settings.leaderboardable = this.settings.givesKillMessage = false;
                this.alpha = this.ALPHA = 0;
            }
        }
        damageMultiplier() {
            switch (this.type) {
                case "swarm":
                    return .25 + 1.5 * util.clamp(this.range / (this.RANGE + 1), 0, 1);
                default:
                    return 1;//1
            }
        }
        move() {
            let g = this.control.goal ? {
                x: this.control.goal.x - this.x,
                y: this.control.goal.y - this.y
            } : {
                x: 0,
                y: 0
            },
                gactive = g.x !== 0 || g.y !== 0,
                engine = {
                    x: 0,
                    y: 0
                },
                a = this.acceleration / room.speed;
            switch (this.motionType) {
                case "glide":
                    this.maxSpeed = this.topSpeed;
                    this.damp = .05;
                    break;
      case "snake":
        this.maxSpeed = this.topSpeed; //copied from glide
        this.damp = 0.05;
        if (this.source.control.alt) this.winding = true; 
        if (this.winding === true) {
          this.facing += 0.3 * Math.sin(this.range / -9);
          if (Math.abs(this.velocity.x) > Math.abs(this.velocity.y))
            this.y += 6 * Math.sin(this.range / -9);
          else
            this.x += 6 * Math.sin(this.range / -9);        
        }
        break;
      case "altSnake":
        this.maxSpeed = this.topSpeed; //copied from glide
        this.damp = 0.05;
        if (this.source.control.alt) this.winding = true; 
        if (this.winding === true) {
          this.facing += 0.3 * Math.sin((-this.range / -9));
          if (Math.abs(this.velocity.x) > Math.abs(this.velocity.y))
            this.y += 6 * Math.sin((-this.range / -9));
          else
            this.x += 6 * Math.sin((-this.range / -9));        
        }
        break;
         case "jiboya":
        this.maxSpeed = this.topSpeed; //copied from glide
        this.damp = 0.05;
        if (this.source.control.alt) this.winding = true; 
        if (this.winding === true) {
          this.facing += 0.5 * Math.sin(this.range/-9);
          if (Math.abs(this.velocity.x) > Math.abs(this.velocity.y))
            this.y += 13 * Math.sin(this.range/-9);
          else
            this.x += 8 * Math.sin(this.range/-9);        
        }
        break;
                case "motor":
                    this.maxSpeed = 0;
                    if (this.topSpeed) this.damp = a / this.topSpeed;
                    if (gactive) {
                        let len = Math.sqrt(g.x * g.x + g.y * g.y);
                        engine = {
                            x: a * g.x / len,
                            y: a * g.y / len
                        };
                    }
                    break;
                case "invertedMotor":
                    this.maxSpeed = 0;
                    if (this.topSpeed) this.damp = a / this.topSpeed;
                    if (gactive) {
                        let len = Math.sqrt(g.x * g.x + g.y * g.y);
                        engine = {
                            x: a * -g.x / len,
                            y: a * -g.y / len
                        };
                    }
                    break;
      case "amble":
        this.maxSpeed = 0;
        if (this.topSpeed) {
          this.damp = 0.04;
        }
        if (gactive) {
          let len = Math.sqrt(g.x * g.x + g.y * g.y);
          engine = {
            x: ((a/2) * g.x) / len,
            y: ((a/2) * g.y) / len,
          };
        }
        break;
      case "misfit":
        this.maxSpeed = 0;
        if (this.topSpeed) {
          this.damp = 0.04;
        }
        if (gactive) {
          let len = Math.sqrt(g.x * g.x + g.y * g.y);
          engine = {
            x: ((a/2) * -g.x) / len,
            y: ((a/2) * -g.y) / len,
          };
        }
        break;
      case "amblele":
        this.maxSpeed = 0;
        if (this.topSpeed) {
          this.damp = 0.015;
        }
        if (gactive) {
          let len = Math.sqrt(g.x * g.x + g.y * g.y);
          engine = {
            x: ((a/2) * g.x) / len,
            y: ((a/2) * g.y) / len,
          };
        }
        break;
                case "swarm":
                    this.maxSpeed = this.topSpeed;
                    let l = util.getDistance({
                        x: 0,
                        y: 0
                    }, g) + 1;
                    if (gactive && l > this.size) {
                        let desiredXSpeed = this.topSpeed * g.x / l,
                            desiredYSpeed = this.topSpeed * g.y / l,
                            turning = Math.sqrt((this.topSpeed * Math.max(1, this.range) + 1) / a);
                        engine = {
                            x: (desiredXSpeed - this.velocity.x) / Math.max(5, turning),
                            y: (desiredYSpeed - this.velocity.y) / Math.max(5, turning)
                        };
                    } else {
                        if (this.velocity.length < this.topSpeed) engine = {
                            x: this.velocity.x * a / 20,
                            y: this.velocity.y * a / 20
                        };
                    }
                    break;
                case "chase":
                    if (gactive) {
                        let l = util.getDistance({
                            x: 0,
                            y: 0
                        }, g);
                        if (l > this.size * 2) {
                            this.maxSpeed = this.topSpeed;
                            let desiredxspeed = this.topSpeed * g.x / l,
                                desiredyspeed = this.topSpeed * g.y / l;
                            engine = {
                                x: (desiredxspeed - this.velocity.x) * a,
                                y: (desiredyspeed - this.velocity.y) * a
                            };
                        } else this.maxSpeed = 0;
                    } else this.maxSpeed = 0;
                    break;
                case "drift":
                    this.maxSpeed = 0;
                    engine = {
                        x: g.x * a,
                        y: g.y * a
                    };
                    break;
                case "tokyoDrift":
                    this.maxSpeed = this.topSpeed;
                    if (this.topSpeed) this.damp = a / this.topSpeed;
                    if (gactive) {
                        this.refreshBodyAttributes()
                        let len = Math.sqrt(g.x * g.x + g.y * g.y);
                        engine = {
                            x: a * g.x / len,
                            y: a * g.y / len
                        };
                    } else {
                        this.topSpeed *= 0.9
                        this.damp = 1;
                    }
                    break;
                case "bound":
                    if(!this.bond){return}
                    let bound = this.bound,
                        ref = this.bond;
                    this.x = ref.x + ref.size * bound.offset * Math.cos(bound.direction + bound.angle + ref.facing);
                    this.y = ref.y + ref.size * bound.offset * Math.sin(bound.direction + bound.angle + ref.facing);
                    this.bond.velocity.x += bound.size * this.accel.x;
                    this.bond.velocity.y += bound.size * this.accel.y;
                    this.firingArc = [ref.facing + bound.angle, bound.arc / 2];
                    this.accel.null();
                    this.blend = ref.blend;
                    break;
                case "accelerate":
                    this.maxSpeed = this.topSpeed;
                    this.damp = -.0125;
                    //this.DAMAGE += .6; // .05, 1, 2
                    break;
                case "accelerateMAX":
                    this.maxSpeed = this.topSpeed;
                    this.damp = -.125;
                    //this.DAMAGE += 2.1; // .05, 1, 2
                    break;
                case "glideBall":
                    this.maxSpeed = this.topSpeed;
                    if (this.topSpeed) this.damp = a / this.topSpeed;
                    if (gactive) {
                        let len = Math.sqrt(g.x * g.x + g.y * g.y);
                        engine = {
                            x: a * g.x / len,
                            y: a * g.y / len
                        };
                    } else this.damp = .005;
                    break;
                case "GLIDEBALL":
                    this.maxSpeed = this.topSpeed;
                    if (this.topSpeed) this.damp = a / this.topSpeed;
                    if (gactive) {
                        let len = Math.sqrt(g.x * g.x + g.y * g.y);
                        engine = {
                            x: a * g.x / len,
                            y: a * g.y / len
                        };
                    } else this.damp = .00003;
                    break;
                case "grow":
                    this.SIZE += .175;
                    break;
                case "wand":
                    if (this.thing == undefined) {this.thing = 1} else {this.thing += 0.02}//tf
                    if(this.SIZE > 11.5) {this.SIZE -= this.thing} else {this.SIZE += 0.2}
                    break;
                case "shrink"://mine
                    this.SIZE -= .4
                    break;
                case "shrinkalot"://mine
                    if(this.SIZE > 0.81) {this.SIZE -= .8}
                    break;
                case "dirt"://mine
                        if(this.SIZE > 1){this.SIZE -= this.thing} 
                    break; 
                case "flamethrower":
                    this.maxSpeed = this.topSpeed;
                    this.damp = -.02;
                    this.SIZE += .175;
                    this.DAMAGE -= 2.25;
                    break;
                case "combustFlare":
                    this.maxSpeed = this.topSpeed;
                    this.damp = -.02;
                    this.SIZE += .175;
                    let q = util.getDistance({
                        x: 0,
                        y: 0
                    }, g) + 1;
                    if (gactive && q > this.size) {
                        let desiredXSpeed = this.topSpeed * g.x / q,
                            desiredYSpeed = this.topSpeed * g.y / q,
                            turning = Math.sqrt((this.topSpeed * Math.max(1, this.range) + 1) / a);
                        engine = {
                            x: (desiredXSpeed - this.velocity.x) / Math.max(5, turning),
                            y: (desiredYSpeed - this.velocity.y) / Math.max(5, turning)
                        };
                    } else {
                        if (this.velocity.length < this.topSpeed) engine = {
                            x: this.velocity.x * a / 20,
                            y: this.velocity.y * a / 20
                        };
                    }
                    break;
                case "flare":
                    this.maxSpeed = this.topSpeed;
                    this.damp = -.025;
                    this.SIZE += .25;
                    this.DAMAGE -= .175;
                    break;
                case "explode":
                    this.SIZE += 10;
                    this.DAMAGE += 3;
                    break;
                case "flakGun":
                    this.SIZE += 5;
                    this.DAMAGE += 2.3;
                    break;
                case "revExplode":
                    this.SIZE -= 4;
                    this.DAMAGE -= 3;
                    if (this.SIZE <= 1) this.kill();
                    break;
                case "kamikaze":
                    this.SIZE += 7;
                    this.DAMAGE += 1;
                    break;
                case "suddenexplosion":
                    this.SIZE = 350;
                    this.velocity.x = 0;
                    this.velocity.y = 0;
                    break;
                case "crockett":
                    this.SIZE += 2;
                    this.DAMAGE += 2;
                    break;
                case "revCrockett":
                    this.SIZE -= 2;
                    this.DAMAGE -= 2;
                case "crockett2":
                    this.SIZE += 1.3;
                    this.DAMAGE += 1.6;
                    break;
                case "fastcrockett":
                    this.SIZE += 6;
                    this.DAMAGE += 6;
                    break;
                case "exponennuke":
                    this.SIZE *= 1.03;
                    this.DAMAGE *= 1.03;
                    break;
                case "snowball":
                    this.SIZE += .15;
                    this.DAMAGE += 2;
                    break;
                case "fatNuke":
                    this.SIZE += 7;
                    this.DAMAGE += 20;
                    break;
                case "miniGrower":
                    this.SIZE += .1; // + .02 * Math.random();
                    this.DAMAGE += .15;
                    this.penetration += .01;
                    if (this.velocity.x > 0) this.velocity.x -= .0035;
                    if (this.velocity.y > 0) this.velocity.y -= .0035;
                    break;
                case "fire":
                    //this.damp = .1;
                    this.SIZE += .16 + .02 * Math.random(this.range);
                    if (this.SIZE >= 11) this.SIZE = 11 + .02 * Math.random();
                    this.color = 204;
                    this.DAMAGE += .03;
                    break;
                case "grower":
                    this.SIZE += .14; // + .022 * Math.random();
                    this.DAMAGE += .175;
                    this.penetration += .02;
                    if (this.velocity.x > 0) this.velocity.x -= .004;
                    if (this.velocity.y > 0) this.velocity.y -= .004;
                    break;
                case "megaGrower":
                    this.SIZE += .17; // + .024 * Math.random();
                    this.DAMAGE += .2;
                    this.penetration += .03;
                    if (this.velocity.x > 0) this.velocity.x -= .0045;
                    if (this.velocity.y > 0) this.velocity.y -= .0045;
                    break;
                case "gigaGrower":
                    this.SIZE += .21; // + .026 * Math.random();
                    this.DAMAGE += .225;
                    this.penetration += .04;
                    if (this.velocity.x > 0) this.velocity.x -= .005;
                    if (this.velocity.y > 0) this.velocity.y -= .005;
                    break;
                case "overGrower":
                    this.SIZE += Math.random();
                    this.DAMAGE += .25;
                    this.penetration += .05;
                    if (this.velocity.x > 0) this.velocity.x -= .005;
                    if (this.velocity.y > 0) this.velocity.y -= .005;
                    break;
                case "thunder":
                    this.SIZE += 4.5;
                    break;
                /*case "gravity":
                    //this.a += 1; // Does nothing
                    this.velocity.y += a;
                    this.damp = -.005;
                    this.topSpeed = 90;
                    break;*/
                case "gravityA":
                    //this.a += 1;
                    this.velocity.y += a / 1.45;
                    this.damp = -.00125;
                    this.topSpeed = 70;
                    break;
                case "gravityB":
                    //this.a += 1;
                    this.velocity.y -= a / 1.45;
                    this.damp = -.00125;
                    this.topSpeed = 70;
                    break;
                case "gravityC":
                    this.velocity.y += a / 1.45;
                    this.damp = -.00125;
                    this.topSpeed = 70;
                    break;
                case "gravityD":
                    this.velocity.x -= a / 1.45 * Math.sin(2 * Math.PI / 3);
                    this.velocity.y += a / 1.45 * Math.cos(2 * Math.PI / 3);
                    this.damp = -.00125;
                    this.topSpeed = 70;
                    break;
                case "gravityE":
                    this.velocity.x -= a / 1.45 * Math.sin(4 * Math.PI / 3);
                    this.velocity.y += a / 1.45 * Math.cos(4 * Math.PI / 3);
                    this.damp = -.00125;
                    this.topSpeed = 70;
                    break;
                case "limitShrink":
                    this.SIZE -= .175;
                    if (this.SIZE < 2) this.SIZE = 2;
                    break;
                case "limitShrink2":
                    this.SIZE -= .08;
                    break;
                case "decentralize":
                    if (this.master.control.alt) this.SIZE += 1;
                    else {
                        if (this.SIZE > 25.2) this.SIZE -= 1;
                        else this.SIZE = 25.2;
                    }
                    break;
                case "plasma":
                    this.x = this.source.x;
                    this.y = this.source.y;
                    this.SIZE += 4;
                    break;
                case "colorthingy":
                    this.color = 0;
                    this.SIZE -= 1;
                    if (this.SIZE <= 1) this.kill();
                    this.maxSpeed = this.topSpeed;
                    break;
                case "colorthingy2":
                    this.color = 2;
                    this.SIZE -= 1;
                    if (this.SIZE <= 1) this.kill();
                    this.maxSpeed = this.topSpeed;
                    break;
                case "colorthingynocolor":
                    this.SIZE -= 1;
                    if (this.SIZE <= 1) this.kill();
                    this.maxSpeed = this.topSpeed;
                    break;
                case "decelfast":
                    this.maxSpeed = this.topSpeed;
                    this.damp = .2;
                    break;
                case "decel":
                    this.maxSpeed = this.topSpeed;
                    this.damp = .05;
                break;
                case "colorthingy4":
                    this.color = 23;
                    this.SIZE += 5;
                    if (this.SIZE >= 40) this.SIZE = 40;
                    this.guns.color = 4;
                    this.maxSpeed = this.topSpeed;
                    break;
                case "flashlight":
                    this.maxSpeed = this.topSpeed;
                    this.SIZE += 3;
                    if (this.SIZE >= 40) this.SIZE = 40;
                    break;
                case "blind":
                    this.maxSpeed = this.topSpeed;
                    this.SIZE += 1.2;
                    if (this.SIZE >= 70) this.SIZE = 70;
                    break;
                case "welder":
                    this.color = 276;
                    this.SIZE += 5;
                    if (this.SIZE >= 40) this.SIZE = 40;
                    this.guns.color = 4;
                    this.maxSpeed = this.topSpeed;
                    break;
                case "ebin":
                    this.color = 22;
                    this.diesAtRange = true;
                    let mod = 120 * Math.PI / 180 * Math.sin(900 * Math.random()),
                        theta = this.facing + mod;
                    if (this.range <= 40 && this.range >= 39) {
                        this.velocity.x = 10 * Math.cos(theta);
                        this.velocity.y = 10 * Math.sin(theta);
                        mod *= -1;
                    }
                    this.maxSpeed = this.topSpeed;
                    break;
                case "ebin2":
                    this.diesAtRange = true;
                    let mod2 = 160 * Math.PI / 180 * Math.sin(500 * Math.random()),
                        theta2 = this.facing + mod2;
                    if (this.range <= 15 && this.range >= 14 && !this.master.autoOverride) {
                        this.velocity.x = 11 * Math.cos(theta2);
                        this.velocity.y = 11 * Math.sin(theta2);
                        mod2 *= 1;
                    }
                    if (this.range <= 40 && this.range >= 39 && !this.master.autoOverride) {
                        this.velocity.x = 10 * Math.cos(theta2);
                        this.velocity.y = 10 * Math.sin(theta2);
                        mod2 *= -1;
                    }
                    this.maxSpeed = this.topSpeed;
                    break;
                case "ebin3":
                    this.diesAtRange = true;
                    let mod3 = 160 * Math.PI / 180 * Math.sin(500 * Math.random()),
                        theta3 = this.facing + mod3;
                    if (this.range <= 15 && this.range >= 14 && !this.master.autoOverride) {
                        this.velocity.x = 12 * Math.cos(theta3);
                        this.velocity.y = 12 * Math.sin(theta3);
                        mod3 *= 1;
                    }
                    if (this.range <= 27.5 && this.range >= 26.5 && !this.master.autoOverride) {
                        this.velocity.x = 11 * Math.cos(theta3);
                        this.velocity.y = 11 * Math.sin(theta3);
                        mod3 *= 1;
                    }
                    if (this.range <= 40 && this.range >= 39 && !this.master.autoOverride) {
                        this.velocity.x = 10 * Math.cos(theta3);
                        this.velocity.y = 10 * Math.sin(theta3);
                        mod3 *= -1;
                    }
                    this.maxSpeed = this.topSpeed;
                    break;
                case "bong":
                    this.SIZE += 4;
                    this.maxSpeed = this.topSpeed;
                    this.damp = .05;
                    break;
                case "oxy":
                    this.maxSpeed = this.topSpeed;
                    let oxy = util.getDistance({
                        x: 0,
                        y: 0
                    }, g) + 1;
                    if (gactive && oxy > this.size) {
                        let desiredXSpeed = this.topSpeed * g.x / oxy,
                            desiredYSpeed = this.topSpeed * g.y / oxy,
                            turning = Math.sqrt((this.topSpeed * Math.max(1, this.range) + 1) / a);
                        engine = {
                            x: (desiredXSpeed - this.velocity.x) / Math.max(5, turning),
                            y: (desiredYSpeed - this.velocity.y) / Math.max(5, turning)
                        };
                    } else {
                        if (this.velocity.length < this.topSpeed) engine = {
                            x: this.velocity.x * a / 20,
                            y: this.velocity.y * a / 20
                        };
                    }
                    this.color = 31;
                    break;
                    //mine
                    case "fastExplode":
                        this.MUTATION = "boom"
                        this.SIZE += 30;
                        this.DAMAGE += 10;
                        break;
            }
            this.accel.x += engine.x * this.control.power;
            this.accel.y += engine.y * this.control.power;
        }
        face() {
            let t = this.control.target,
                oldFacing = this.facing;
            switch (this.facingType) {
                case "autospin":
                    this.facing += .02 / room.speed;
                    break;
                case "autospin2":
                    this.facing += .0125 / room.speed;
                    break;
                case "spinSlowly":
                    this.facing += .0075 / room.speed;
                    break;
                case "revSlowSpin"://mine
                    this.facing -= .0075 / room.speed;
                    break;
                case "brainDamage"://mine
                    this.facing += 2* Math.random() - 1 / room.speed;
                    break;
                case "spinSlowly2":
                    this.facing += .004 / room.speed;
                    break;
                case "spinSlowly3":
                    this.facing += .0025 / room.speed;
                    break;
                case "spinSlowly4":
                    this.facing += .00125 / room.speed;
                    break;
                case "spinSlowly5":
                    this.facing += .001575 / room.speed;
                    break;
                case "bitFastSpin":
                    this.facing += .035 / room.speed;
                    break;
                case "fastSpin":
                    this.facing += .075 / room.speed;
                    break;
                case "revFastSpin":
                    this.facing -= .075 / room.speed;
                    break;
                case "revSuperFastSpin":
                    this.facing -= .1 / room.speed;
                    break;
                case "legionaryCrasherSpin":
                    this.facing -= .04 / room.speed;
                    break;
                case "altSpin":
                    this.facing += (this.master.control.alt ? -.15 : .075) / room.speed;
                    break;
                case "altSpinBunk":
                    this.facing += (this.master.control.alt ? -.025 : .025) / room.speed;
                    break;
                case "altSpinBunk2":
                    this.facing += (this.master.control.alt ? .04 : -.04) / room.speed;
                    break;
                case "revaltSpinBunk":
                    this.facing += (this.master.control.alt ? .025 : -.025) / room.speed;
                    break;
                case "revaltSpinBunk2":
                    this.facing += (this.master.control.alt ? -.04 : .04) / room.speed;
                    break;
                case "hadron":
                    this.facing += (this.master.control.alt ? -.035 : .035) / room.speed;
                    break;
                case "lmg":
                    if (this.master.control.fire) this.facing += .0375 / room.speed;
                    break;
                case "isin":
                    if (this.master.control.fire || this.master.control.alt) this.facing += .0375 / room.speed;
                    break;
                case "turnWithSpeed":
                    this.facing += this.velocity.length / 90 * Math.PI / room.speed;
                    break;
                case "turnWithMasterSpeed":
                    this.facing += this.master.velocity.length / 90 * Math.PI / room.speed;
                    break;
                case "turnWithSpeedFood":
                    if (!(this.id % 2)) this.facing -= this.velocity.length / 90 * Math.PI / room.speed
                    else this.facing += this.velocity.length / 90 * Math.PI / room.speed;
                    break;
                case "withMotion":
                    if (this.velocity.length > 0) this.facing = this.velocity.direction;
                    break;
                case "smoothTargetOrSmoothhMotion":
                  if(this.source.control.target.length === 0){// no target: smooth with motion
                      this.facing += util.loopSmooth(this.facing, this.velocity.direction, 4 / room.speed);
                  }else{ // target: smooth to target
                      this.facing += util.loopSmooth(this.facing, Math.atan2(t.y, t.x), 4 / room.speed);
                  }
                break;
                case "looseWithMotion":
                    if (!this.velocity.length) break;
                case "smoothWithMotion":
                    this.facing += util.loopSmooth(this.facing, this.velocity.direction, 4 / room.speed);
                    break;
                case "sans": //ty misfit
                    this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                    entities.forEach((instance) => {
                        if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion tank miniboss crasher food".includes(instance.type) && instance.team != this.team) { 
                        this.velocity.x += 20 * Math.sin(instance.velocity.direction + (Math.PI/2));
                        this.velocity.y += 50 * Math.cos(instance.velocity.direction + (Math.PI/2));
                        
                        this.facingType = "smoothWithMotion"; //Disables ability after dodging
                        setTimeout(() => {
                        this.facingType = "sans"; //Re-enables ability after cooldown
                        }, 1);
                        }
                    } 
                    );
                        break;
                case "dodge": //ty misfit
                    this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                    entities.forEach((instance) => {
                        if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion".includes(instance.type) && instance.team != this.team) { 
                        this.velocity.x += 50 * Math.sin(instance.velocity.direction + (Math.PI/2));
                        this.velocity.y += 50 * Math.cos(instance.velocity.direction + (Math.PI/2));
                        
                        this.facingType = "smoothWithMotion"; //Disables ability after dodging
                        setTimeout(() => {
                        this.facingType = "dodge"; //Re-enables ability after cooldown
                        }, 2500); //2.5 sec dodge cooldown
                        }
                    } 
                    );
                        break;
                case "dodgeTank": // dodge type without turning delay
                    this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                    entities.forEach((instance) => {
                        if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion crasher tank miniboss".includes(instance.type) && instance.team != this.team && !this.invuln) { 
                        this.velocity.x += 50 * Math.sin(instance.velocity.direction + (Math.PI/2));
                        this.velocity.y += 50 * Math.cos(instance.velocity.direction + (Math.PI/2));
                        
                        this.facingType = "toTarget"; //Disables ability after dodging
                        setTimeout(() => {
                        this.facingType = "dodgeTank"; //Re-enables ability after cooldown
                        }, 4500); //1.5 sec dodge cooldown
                        }
                    } 
                    );
                        break;
                case "dodgeBig": // dodge type without turning delay
                    this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                    entities.forEach((instance) => {
                        if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion crasher tank miniboss".includes(instance.type) && instance.team != this.team && !this.invuln) { 
                        this.velocity.x += 170 * Math.sin(instance.velocity.direction + (Math.PI/2));
                        this.velocity.y += 170 * Math.cos(instance.velocity.direction + (Math.PI/2));
                        
                        this.facingType = "toTarget"; //Disables ability after dodging
                        setTimeout(() => {
                        this.facingType = "dodgeBig"; //Re-enables ability after cooldown
                        }, 5000); //1.5 sec dodge cooldown
                        }
                    } 
                    );
                        break;
                case "dodgeBetter": // dodge type without turning delay
                    this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                    entities.forEach((instance) => {
                        if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion crasher tank miniboss".includes(instance.type) && instance.team != this.team && !this.invuln) { 
                        this.velocity.x += 50 * Math.sin(instance.velocity.direction + (Math.PI/2));
                        this.velocity.y += 50 * Math.cos(instance.velocity.direction + (Math.PI/2));
                        
                        this.facingType = "toTarget"; //Disables ability after dodging
                        setTimeout(() => {
                        this.facingType = "dodgeBetter"; //Re-enables ability after cooldown
                        }, 3000); //1.5 sec dodge cooldown
                        }
                    } 
                    );
                        break;
                case "bossdodge": //ty misfit
                    this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                    entities.forEach((instance) => {
                        if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion".includes(instance.type) && instance.team != this.team) { 
                        this.velocity.x += 150 * Math.sin(instance.velocity.direction + (Math.PI/2));
                        this.velocity.y += 150 * Math.cos(instance.velocity.direction + (Math.PI/2));
                        
                        this.facingType = "smoothWithMotion"; //Disables ability after dodging
                        setTimeout(() => {
                        this.facingType = "bossdodge"; //Re-enables ability after cooldown
                        }, 10000); //10 sec dodge cooldown
                        }
                    } 
                    );
                        break;
                case "dronedodge": //ty misfit
                    this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                    entities.forEach((instance) => {
                        if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion".includes(instance.type) && instance.team != this.team) { 
                        this.velocity.x += 50 * Math.sin(instance.velocity.direction + (Math.PI/2));
                        this.velocity.y += 50 * Math.cos(instance.velocity.direction + (Math.PI/2));
                        
                        this.facingType = "smoothWithMotion"; //Disables ability after dodging
                        setTimeout(() => {
                        this.facingType = "dronedodge"; //Re-enables ability after cooldown
                        }, 2500); //2.5 sec dodge cooldown
                        }
                    } 
                    );
                        break;
                    case "bossdodge2": //ty misfit
                        this.facing = Math.atan2(t.y, t.x); //Copied from toTarget
                        entities.forEach((instance) => {
                            if (Math.abs(this.x - instance.x) < 70 && Math.abs(this.y - instance.y) < 70 && "bullet trap swarm drone minion".includes(instance.type) && instance.team != this.team) { 
                            this.velocity.x += 150 * Math.sin(instance.velocity.direction + (Math.PI/2));
                            this.velocity.y += 150 * Math.cos(instance.velocity.direction + (Math.PI/2));
                            
                            this.facingType = "smoothToTarget"; //Disables ability after dodging
                            setTimeout(() => {
                            this.facingType = "bossdodge2"; //Re-enables ability after cooldown
                            }, 10000); //10 sec dodge cooldown
                            }
                        } 
                        );
                            break;
                case "toTarget":
                    this.facing = Math.atan2(t.y, t.x);
                    break;
                /*case "coper":
                    this.facing = Math.atan2(t.y, t.x);
                    if (this.control.alt) {
                       this.regen = 7;
                    } else this.regen = 0;
                    break;*/
                case 'discom':
                    this.facing = Math.atan2(t.y, t.x) + (Math.random() * 360);
                    break;
                case "locksFacing":
                    if (!this.control.alt) this.facing = Math.atan2(t.y, t.x);
                    break;
                case "altLocksFacing":
                    if (!this.control.fire) this.facing = Math.atan2(t.y, t.x);
                    break;
                case "smoothToTarget":
                    this.facing += util.loopSmooth(this.facing, Math.atan2(t.y, t.x), 4 / room.speed);
                    break;
                case "slowToTarget":
                    this.facing += util.loopSmooth(this.facing, Math.atan2(t.y, t.x), 8 / room.speed);
                break;
                case "bound":
                    let givenAngle;
                    if (this.turretRightClick ? this.control.alt : this.control.main) {
                        givenAngle = Math.atan2(t.y, t.x);
                        let diff = util.angleDifference(givenAngle, this.firingArc[0]);
                        if (Math.abs(diff) >= this.firingArc[1]) givenAngle = this.firingArc[0];
                    } else givenAngle = this.firingArc[0];
                    this.facing += util.loopSmooth(this.facing, givenAngle, (2 / room.speed) * this.turretTraverseSpeed);
                    if (this.bond.syncTurretSkills) this.skill.set(this.bond.skill.raw);
                    break;
                case "toBound":
                    this.facing = this.bound.angle + this.bond.master.facing;
                    break;
                case "hatchet":
                    if (this.control.fire) this.facing += .2 + this.skill.spd / 7;
                    break;
                case "reverseAutospin":
                    this.facing -= .02 / room.speed;
                    break;
                case "masterOnSpawn":
                    if (!this.variables.masterOnSpawnFacing) {
                        this.facing = this.master.facing
                        this.variables.masterOnSpawnFacing = 1
                    }
                    break;
                case "random":
                    this.facing += Math.random()*20;
                    break;
                case "cyclostack":
                    if (this.control.fire) {this.facing -= 0.63}
                    if (this.control.alt && !this.control.fire) {this.facing -= 0.15}
                break;
            }
            let TAU = 2 * Math.PI;
            this.facing = (this.facing % TAU + TAU) % TAU;
            this.vfacing = util.angleDifference(oldFacing, this.facing) * room.speed;
        }
        takeSelfie() {
            this.flattenedPhoto = null;
            this.photo = this.settings.drawShape ? this.camera() : undefined;
        }
        physics() {
            this.velocity.x += this.accel.x;
            this.velocity.y += this.accel.y;
            this.accel.null();
            this.stepRemaining = c.ARENA_TYPE === 1 ? 1.5 : 1;
            this.x += this.stepRemaining * this.velocity.x / room.speed;
            this.y += this.stepRemaining * this.velocity.y / room.speed;
        }
        friction() {
            let motion = this.velocity.length,
                excess = (motion - this.maxSpeed) * (c.ARENA_TYPE === 1 ? 1.05 : 1);
            if (excess > 0 && this.damp) {
                let drag = excess / (this.damp / room.speed + 1),
                    finalvelocity = this.maxSpeed + drag;
                this.velocity.x = finalvelocity * this.velocity.x / motion;
                this.velocity.y = finalvelocity * this.velocity.y / motion;
            }
        }
        location() {
            if (this.isDead()) {
                return;
            }/*
            if (isNaN(this.x) || isNaN(this.y)) {
                util.error("Detected an NaN position!");
                util.error("Label: " + this.label);
                util.error("Index: " + this.index);
                util.error(`Position: (${this.x}, ${this.y})`);
                util.error(`Velocity: (${this.velocity.x}, ${this.velocity.y})`);
                util.error(`Acceleration: (${this.accel.x}, ${this.accel.y})`);
                return this.kill();
            }*/
            let loc = {
                x: this.x,
                y: this.y
            },
                myCell = this.myCell;
            if (room.outb && room.outb.length && this.diesToTeamBase && !this.godmode && !this.passive && myCell === "outb") {
                if (this.type === "miniboss" || this.type === "crasher") {
                    let pos = room.randomType(c.serverName.includes("Boss Rush") ? "myboss" : "nest");//"boss" : "nest"
                    this.x = pos.x;
                    this.y = pos.y;
                } else if (this.type === "tank" || this.type === "food" || this.type === "aquaticFood") {
                    return this.kill();
                }
            }
            if (c.DO_BASE_DAMAGE && room.gameMode === "tdm" && this.diesToTeamBase && !this.godmode && !this.passive && !this.isTurret) {
                let bas = myCell.slice(0, -1);
                if (bas === "bas" || bas === "n_b" || bas === "bad" || bas === "por") {
                    if (bas + -this.team !== myCell) {
                        if(c.serverName.includes("Boss Rush") && this.team == -100) {

                        }else{
                        this.velocity.null();
                        this.accel.null();
                        this.kill();
                        }
                        return;
                    }
                }
                /*let isInTeamBase = false;
                for (let i = 1; i < room.teamAmount + 1; i++)
                    if (this.master.team !== -i && (room.isIn(`bas${i}`, loc) || room.isIn(`n_b${i}`, loc) || room.isIn(`bad${i}`, loc))) {
                        isInTeamBase = true;
                        break;
                    }
                if (isInTeamBase) {
                    this.velocity.null();
                    this.accel.null();
                    this.isDead = () => true;
                    return setTimeout(() => {
                        if (this.isAlive) this.kill();
                    }, 75);
                }*/
            }
            if (c.PORTALS.ENABLED) {
                if (myCell === "port" && !this.passive && !this.settings.goThruObstacle && !this.settings.goThruRock && !this.isTurret) {
                    if (this.motionType === "crockett") return this.kill();
                    /*if (this.settings.isHelicopter) {
                        if (!this.godmode && !this.invuln) this.health.amount -= 1;
                        return;
                    }*/
                    let myRoom = room.isAt(loc),
                        dx = loc.x - myRoom.x,
                        dy = loc.y - myRoom.y,
                        dist2 = dx * dx + dy * dy,
                        force = c.BORDER_FORCE;
                    if (this.type === "miniboss" || this.isMothership) {
                        this.accel.x += 1e4 * dx / dist2 * force / room.speed;
                        this.accel.y += 1e4 * dy / dist2 * force / room.speed;
                    } else if (this.type === "tank") {
                        if (dist2 <= c.PORTALS.THRESHOLD) {
                            let angle = Math.random() * Math.PI * 2,
                                ax = Math.cos(angle),
                                ay = Math.sin(angle);
                            //this.velocity.x = c.PORTALS.LAUNCH_FORCE * ax * force / room.speed;
                            //this.velocity.y = c.PORTALS.LAUNCH_FORCE * ay * force / room.speed;
                            let portTo;
                            do portTo = room["port"][Math.floor(Math.random() * room["port"].length)];
                            while (portTo.id === myRoom.id && room["port"].length > 1);
                            let rx = ax < 0 ? -room.xgridWidth / 1.8 : room.xgridWidth / 1.8,
                                ry = ay < 0 ? -room.ygridHeight / 1.8 : room.ygridHeight / 1.8;
                            this.x = portTo.x + rx;
                            this.y = portTo.y + ry;
                            if (this.isPlayer) {
                                this.invuln = true;
                                this.invulnTime = [Date.now(), 15000];
                                this.sendMessage("You will be invulnerable until you move, shoot or wait 15 seconds.");
                            }
                            //for (let o of entities)
                            entities.forEach(o => {
                                if (o.id !== this.id && o.master.id === this.id && (o.type === "drone" || o.type === "minion")) {
                                    o.x = portTo.x + 320 * ax + 30 * (Math.random() - .5);
                                    o.y = portTo.y + 320 * ay + 30 * (Math.random() - .5);
                                }
                            });
                        } else {
                            this.velocity.x -= c.PORTALS.GRAVITY * dx / dist2 * force / room.speed;
                            this.velocity.y -= c.PORTALS.GRAVITY * dy / dist2 * force / room.speed;
                        }
                    } else this.kill();
                } else if (myCell === "port" && !this.passive && this.motionType === "crockett") {
                    return this.kill();
                } else if (room[`por${-this.team}`] && myCell === `por${-this.team}` && !this.passive && !this.settings.goThruObstacle && !this.isTurret) {
                    if (this.motionType === "crockett") return this.kill();
                    /*if (this.settings.isHelicopter) {
                        if (!this.godmode && !this.invuln) this.health.amount -= 1;
                        return;
                    }*/
                    let myRoom = room.isAt(loc),
                        dx = loc.x - myRoom.x,
                        dy = loc.y - myRoom.y,
                        dist2 = dx * dx + dy * dy,
                        force = c.BORDER_FORCE;
                    if (this.type === "miniboss" || this.isMothership) {
                        this.accel.x += 1e4 * dx / dist2 * force / room.speed;
                        this.accel.y += 1e4 * dy / dist2 * force / room.speed;
                    } else if (this.type === "tank") {
                        if (dist2 <= c.PORTALS.THRESHOLD) {
                            let angle = Math.random() * Math.PI * 2,
                                ax = Math.cos(angle),
                                ay = Math.sin(angle);
                            //this.velocity.x = c.PORTALS.LAUNCH_FORCE * ax * force / room.speed;
                            //this.velocity.y = c.PORTALS.LAUNCH_FORCE * ay * force / room.speed;
                            let portTo;
                            do portTo = room[`por${-this.team}`][Math.floor(Math.random() * room[`por${-this.team}`].length)];
                            while (portTo.id === myRoom.id && room[`por${-this.team}`].length > 1);
                            let rx = ax < 0 ? -room.xgridWidth / 1.8 : room.xgridWidth / 1.8,
                                ry = ay < 0 ? -room.ygridHeight / 1.8 : room.ygridHeight / 1.8;
                            this.x = portTo.x + rx;
                            this.y = portTo.y + ry;
                            if (this.isPlayer) {
                                this.invuln = true;
                                this.invulnTime = [Date.now(), 15000];
                                this.sendMessage("You will be invulnerable until you move, shoot or wait 15 seconds.");
                            }
                            entities.forEach(o => {
                                if (o.id !== this.id && o.master.id === this.id && (o.type === "drone" || o.type === "minion")) {
                                    o.x = portTo.x + 320 * ax + 30 * (Math.random() - .5);
                                    o.y = portTo.y + 320 * ay + 30 * (Math.random() - .5);
                                }
                            });
                        } else {
                            this.velocity.x -= c.PORTALS.GRAVITY * dx / dist2 * force / room.speed;
                            this.velocity.y -= c.PORTALS.GRAVITY * dy / dist2 * force / room.speed;
                        }
                    } else this.kill();
                } else if (room[`por${-this.team}`] && myCell === `por${-this.team}` && !this.passive && this.motionType === "crockett") {
                    return this.kill();
                }
            }
            if (!this.settings.canGoOutsideRoom && !this.passive && this.motionType !== "bound") {
                /*let xx = this.x;
                let yy = this.y;
                let bounces = this.type !== "tank" && this.type !== "miniboss" && this.type !== "drone";

                this.x = Math.max(0 + this.realSize, Math.min(this.x, room.width - this.realSize));
                this.y = Math.max(0 + this.realSize, Math.min(this.y, room.height - this.realSize));

                if (this.x != xx) {
                    this.accel.x = this.x > room.width / 2 ? Math.min(this.accel.x, 0) : Math.max(this.accel.x, 0);
                    this.velocity.x = bounces ? this.velocity.x *= -0.5 : 0;
                }
                if (this.y != yy) {
                    this.accel.y = this.y > room.width / 2 ? Math.min(this.accel.x, 0) : Math.max(this.accel.x, 0);
                    this.velocity.y = bounces ? this.velocity.y *= -0.5 : 0;
                }*/
                let force = c.BORDER_FORCE;
                this.isOutsideRoom = false
                switch (c.ARENA_TYPE) {
                    case 1: // Round
                        if (this.isActive && ((this.type === "tank" && this.bound == null) || this.type === "food" || this.type ==="aquaticFood")) {
                            const dist = util.getDistance(this, {
                                x: room.width / 2,
                                y: room.height / 2
                            });
                            if (dist > room.width / 2) {
                                this.isOutsideRoom = true
                                let strength = Math.abs((dist - room.width / 2) * (force / room.speed)) / 1000;
                                this.x = util.lerp(this.x, room.width / 2, strength);
                                this.y = util.lerp(this.y, room.height / 2, strength);
                            }
                        }
                        break;
                    case 2: // Warping
                        if (this.x < 0) {
                            this.x = room.width - this.realSize;
                        }
                        if (this.x > room.width) {
                            this.x = this.realSize;
                        }
                        if (this.y < 0) {
                            this.y = room.height - this.realSize;
                        }
                        if (this.y > room.width) {
                            this.y = this.realSize;
                        }
                        break;
                    case 3: // Triangle
                        if (this.isActive && ((this.type === "tank" && this.bound == null) || this.type === "food" || this.type === "aquaticFood")) {
                            let isOutside = false;
                            for (let point of room.mapPoints) {
                                let angle = Math.atan2(this.y - point.y, this.x - point.x),
                                    diff = Math.abs(util.angleDifference(angle, point.angle));
                                if (diff < Math.PI / 2) {
                                    isOutside = true;
                                    break;
                                }
                            }
                            if (isOutside) {
                                this.isOutsideRoom = true
                                let strength = Math.abs((util.getDistance(this, {
                                    x: room.width / 2,
                                    y: room.height / 2
                                }) - room.width / 2) * (force / room.speed)) / 1000;
                                this.x = util.lerp(this.x, room.width / 2, strength);
                                this.y = util.lerp(this.y, room.height / 2, strength);
                            }
                        }
                        break;
                    default: // Default rectangular
                        if (this.x < 0) {
                            this.isOutsideRoom = true
                            this.accel.x -= Math.min(this.x - this.realSize + 50, 0) * force / room.speed;
                        }
                        if (this.x > room.width) {
                            this.isOutsideRoom = true
                            this.accel.x -= Math.max(this.x + this.realSize - room.width - 50, 0) * force / room.speed;
                        }
                        if (this.y < 0) {
                            this.isOutsideRoom = true
                            this.accel.y -= Math.min(this.y - this.realSize + 50, 0) * force / room.speed;
                        }
                        if (this.y > room.height) {
                            this.isOutsideRoom = true
                            this.accel.y -= Math.max(this.y + this.realSize - room.height - 50, 0) * force / room.speed;
                        }
                        break;
                }

                // Do outside of room damage
                function outsideRoomDamage(entity) {
                    if (entity.shield.amount > 1) {
                        entity.shield.amount = entity.shield.amount - c.OUTSIDE_ROOM_DAMAGE
                    } else {
                        entity.health.amount = entity.health.amount - c.OUTSIDE_ROOM_DAMAGE
                    }
                    if (entity.onDamaged) entity.onDamaged(entity, null, c.OUTSIDE_ROOM_DAMAGE)
                }
                if (this.OUTSIDE_ROOM_DAMAGE && this.isOutsideRoom) {
                    outsideRoomDamage(this)
                }


                if (c.PORTALS.ENABLED && !this.settings.isHelicopter) {
                    let force = c.BORDER_FORCE;
                    if (c.PORTALS.DIVIDER_1.ENABLED) {
                        let l = c.PORTALS.DIVIDER_1.LEFT,
                            r = c.PORTALS.DIVIDER_1.RIGHT,
                            m = (l + r) * .5;
                        if (this.x > m && this.x < r) this.accel.x -= Math.min(this.x - this.realSize + 50 - r, 0) * force / room.speed;
                        if (this.x > l && this.x < m) this.accel.x -= Math.max(this.x + this.realSize - 50 - l, 0) * force / room.speed;
                    }
                    if (c.PORTALS.DIVIDER_2.ENABLED) {
                        let l = c.PORTALS.DIVIDER_2.TOP,
                            r = c.PORTALS.DIVIDER_2.BOTTOM,
                            m = (l + r) * .5;
                        if (this.y > m && this.y < r) this.accel.y -= Math.min(this.y - this.realSize + 50 - r, 0) * force / room.speed;
                        if (this.y > l && this.y < m) this.accel.y -= Math.max(this.y + this.realSize - 50 - l, 0) * force / room.speed;
                    }
                }
            }
            // water cells
            //let waterCells = ["watr" && "barn"];
            if ("watr barn".includes(myCell) && !this.passive && !this.isShip && !this.isShip2 && !this.isTurret && !this.settings.goThruObstacle && !this.isAquatic && !this.invuln && !this.godmode && !this.settings.isHelicopter) {
                        this.health.amount -= 1;
                        this.killedByWater = true;
                        this.rewardManager(-1, "i_cant_swim");
                    };
           if (this.isAquatic && !"watr barn".includes(myCell)) {
               this.health.amount -= 20;
           }
           if (this.isShip && !"watr barn".includes(myCell)) {
               this.velocity.x /= 1.1;
               this.velocity.y /= 1.1;
           }
          if (this.label === 'Ship' && "watr barn".includes(myCell) && !this.sailTheSeas) {
             this.rewardManager(-1, "sail_the_seas");
             this.sailTheSeas = true;
          }
        }
        regenerate() {
            if (this.shield.max) {
                if (this.REGEN !== -1) this.shield.regenerate();
            }
            if (this.health.amount) {
                if (this.REGEN !== -1) this.health.regenerate(this.shield.max && this.shield.max === this.shield.amount);
            }
        }
        death() {
            //newLogs.death.start();
            //this.checkIfIShouldDie() && this.kill();
            // Turrets must not be calculated as a normal entity
            if (this.bond != null && this.bond.isGhost) {
                //newLogs.death.stop();
                return true;
            }
            // Invulnerable and godmode players should not take damage or be killed. (Set the godmode and invuln properties to false beforehand)
            if (this.invuln || this.godmode) {
                this.damageReceived = 0;
                this.regenerate();
                //newLogs.death.stop();
                return 0;
            }
            // If we die at range, attempt to die for some dumb reason
            if (this.settings.diesAtRange) {
                this.range -= 1 / room.speed;//1
                if (this.range <= 0) {//0
                    this.kill();
                }
            }
            // If we die at low speeds, do that because we are a failure
            if (this.settings.diesAtLowSpeed && !this.collisionArray.length && this.velocity.length < this.topSpeed / 2) {
                this.health.amount -= this.health.getDamage(1 / room.speed);
            }
            // Do damage to us
            if (this.damageReceived !== 0) {
                if (this.shield.max) {
                    let shieldDamage = this.shield.getDamage(this.damageReceived);
                    this.damageReceived -= shieldDamage;
                    this.shield.amount -= shieldDamage;
                }
                if (this.damageReceived !== 0) {
                    let healthDamage = this.health.getDamage(this.damageReceived);
                    this.blend.amount = 1;
                    this.health.amount -= healthDamage;
                }
            }
            this.regenerate();
            this.damageReceived = 0;
            if (this.isDead()) {
                // Explosions, phases and whatnot
                if (this.onDead != null && !this.hasDoneOnDead) {
                    this.hasDoneOnDead = true;
                    this.onDead();
                }
                // Second function so onDead isn't overwritten by specific gamemode features
                if (this.modeDead != null && !this.hasDoneModeDead) {
                    this.hasDoneModeDead = true;
                    this.modeDead();
                }
                // Process tag events if we should
                if (c.serverName.includes("Tag") && (this.isPlayer || this.isBot)) {
                    tagDeathEvent(this);
                }
                // Just in case one of the onDead events revives the tank from death (like dominators), don't run it
                if (this.isDead()) {
                    let killers = [],
                        killTools = [],
                        notJustFood = false,
                        name = this.master.name === "" ? this.master.type === "tank" ? "An unnamed player's " + this.label : this.master.type === "miniboss" ? "a visiting " + this.label : util.addArticle(this.label) : this.master.name + "'s " + this.label,
                        jackpot = Math.round(util.getJackpot(this.skill.score) / this.collisionArray.length);
                    // Find out who killed us, and if it was "notJustFood" or not
                    for (let i = 0, l = this.collisionArray.length; i < l; i++) {
                        let o = this.collisionArray[i];
                        if (o.type === "wall" || o.type === "mazeWall") {
                            continue;
                        }
                        if (o.master.isDominator || o.master.isArenaCloser || o.master.label === "Base Protector") {
                            if (!killers.includes(o.master)) {
                                killers.push(o.master);
                            }
                        }
                        if (o.master.settings.acceptsScore) {
                            if (o.master.type === "tank" || o.master.type === "miniboss") {
                                notJustFood = true;
                            }
                            o.master.skill.score += jackpot;
                            if (!killers.includes(o.master)) {
                                killers.push(o.master);
                            }
                        } else if (o.settings.acceptsScore) {
                            o.skill.score += jackpot;
                        }
                        killTools.push(o);
                    }
                    // Now process that information
                    let killText = notJustFood ? "" : "You have been killed by ",
                        giveKillMessage = this.settings.givesKillMessage;
                    for (let i = 0, l = killers.length; i < l; i++) {
                        let o = killers[i];
                        if (o.onKill) {
                            o.onKill(o, this);
                        }
                        this.killCount.killers.push(o.index);
                        if (this.type === "tank") {
                            if (killers.length > 1) {
                                o.killCount.assists++;
                                if (!o.teamwork) o.rewardManager(-1, "teamwork");
                            } else {
                                o.killCount.solo++;
                            }
                            o.rewardManager(0, 1);
                        } else if (this.type === "miniboss") {
                            o.killCount.bosses++;
                            o.rewardManager(2, 1);
                        } else if (this.type === "food") {
                            o.rewardManager(3, 1);
                        } else if (this.type === "crasher") {
                            o.rewardManager(8, 1);
                        }
                    }
                    // Understand who killed us, but only if it wasn't a minor NPC
                    if (notJustFood) {
                        for (let i = 0, l = killers.length; i < l; i++) {
                            let o = killers[i];
                            if (o.master.type !== "food" && o.master.type !== "crasher") {
                                killText += o.name === "" ? killText === "" ? "An unnamed player" : "An unnamed player" : o.name;
                                killText += " and ";
                            }
                            if (giveKillMessage) {
                                o.sendMessage("You" + (killers.length > 1 ? " assist " : " ") + "killed " + name + ".");
                            }
                        }
                        killText = killText.slice(0, -4);
                        killText += "killed you with ";
                    }
                    // If we generally broadcast something when we die, do so
                    if (this.settings.broadcastMessage) {
                        sockets.broadcast(this.settings.broadcastMessage);
                    }
                    let toAdd = "";
                    for (let i = 0, l = killers.length; i < l; i++) {
                        let o = killers[i];
                        if (o.label.includes("Collision")) {
                            toAdd = "a Collision and ";
                        } else {
                            toAdd += util.addArticle(o.label) + " and ";
                        }
                    }
                    killText += toAdd;
                    killText = killText.slice(0, -5);
                    if (this.killedByK) {
                        killText = "You killed yourself";
                    } else if (this.killedByWalls) {
                        killText = "You got stuck in the walls";
                    } else if (this.glassDied) {
                        killText = "You exploded too much";
                    } else if (this.killedByFire) {
                        killText = "You got burnt by a teammate's fire";
                    } else if (killText === "You have been kille") {
                        killText = "You have died a stupid death";
                    }
                    // If we're really us, just send the message
                    if (!this.underControl) {
                        this.sendMessage(killText + ".");
                    }
                    // Usurp message (Doesn't happen in ranked battle)
                    if (this.id === room.topPlayerID && !c.RANKED_BATTLE) {
                        let usurptText = this.name || "The leader";
                        if (notJustFood) {
                            usurptText += " has been usurped by";
                            for (let i = 0, l = killers.length; i < l; i++) {
                                let o = killers[i];
                                o.rewardManager(-1, "usurper");
                                if (o.type !== "food") {
                                    usurptText += " ";
                                    usurptText += o.name || "An unnamed player";
                                    usurptText += " and";
                                }
                            }
                            usurptText = usurptText.slice(0, -4);
                            usurptText += "!";
                        } else {
                            if (this.killedByWalls) {
                                usurptText += " went to the backrooms.";
                            } else if (killers[0] != null) {
                                if (killers[0].isArenaCloser) {
                                    usurptText += ` suffered by the hands of ${util.addArticle(killers[0].label)}.`;
                                } else if (killers[0].label.includes("Base Protector")) {
                                    usurptText += " strayed too close to a Base Protector.";
                                } else {
                                    usurptText += ` fought ${util.addArticle(killers[0].label)}, and the ${killers[0].label} won.`;
                                }
                            } else if (this.killedByK) {
                                usurptText += " took the easy way out.";
                            } else if (this.isBot) {
                                usurptText += " was slaughtered by server code.";
                            } else {
                                usurptText += " suffered an unknown fate.";
                            }
                        }
                        sockets.broadcast(usurptText);
                    }
                    //newLogs.death.stop();
                    return true;
                }
            }
            //newLogs.death.stop();
            return false;
        }
        protect() {
            entitiesToAvoid.push(this);
            this.isProtected = true;
        }
        sendMessage(message) { }
        rewardManager(id, amount) { }
        kill() {
            this.godmode = false;
            this.invuln = false;
            this.damageReceived = this.health.max * 2;
            this.health.amount = -1;
        }
        destroy() {
            if (this.hasDestroyed) {
                return;
            }
            this.hasDestroyed = true;
            //newLogs.destroy.start();
            // Remove us from protected entities
            if (this.isProtected) {
                //entitiesToAvoid = entitiesToAvoid.filter(child => child.id !== this.id);
                //util.remove(entitiesToAvoid, entitiesToAvoid.indexOf(this));
                util.removeID(entitiesToAvoid, this.id);
            }
            // Remove us from the view of the players
            /*for (let v of views) {
                v.remove(this);
            }*/
            // Remove us from our children
            if (this.parent != null) {
                //util.remove(this.parent.children, this.parent.children.indexOf(this));
                //this.parent.children = this.parent.children.filter(child => child.id !== this.id);
                if(this.parent.childrenMap) this.parent.childrenMap.delete(this.id)
                util.removeID(this.parent.children, this.id);
            }
            if (this.master != null) {
                if (this.master.childrenMap) this.master.childrenMap.delete(this.id)
                util.removeID(this.master.children, this.id);
            }
            // NEDS WORK: remove our children
            /*for (let i = 0, l = entities.length; i < l; i ++) {
                let instance = entities[i];
                if (instance.source.id === this.id) {
                    if (instance.settings.persistsAfterDeath) {
                        instance.source = instance;
                        if (instance.settings.persistsAfterDeath === 'always') {
                            continue;
                        }
                    } else {
                        instance.kill();
                    }
                }
                if (instance.parent && instance.parent.id === this.id) {
                    instance.parent = null;
                }
                if (instance.master.id === this.id) {
                    instance.kill();
                    instance.master = instance;
                }
            }*/
            for (let [key, child] of this.childrenMap) {
                this.childrenMap.delete(key)
                child.parent = null
                child.source = child
                if (!child.settings.persistsAfterDeath) {
                    child.destroy()
                }
            };
            /*this.childrenMap.forEach(instance => {
                if (instance.source.id === this.id) {
                    if (instance.settings.persistsAfterDeath) {
                        instance.source = instance;
                        if (instance.settings.persistsAfterDeath === 'always') {
                            return;
                        }
                        if (this.source == this) {
                            instance.kill();
                            this.childrenMap.delete(instance.id);
                        }
                    } else {
                        this.childrenMap.delete(instance.id);
                        instance.kill();
                    }
                }
                if (instance.parent && instance.parent.id === this.id) {
                    instance.parent = null;
                }
                if (instance.master.id === this.id) {
                    this.childrenMap.delete(instance.id);
                    instance.kill();
                    instance.master = instance;
                }
            });*/

            if (this.isGuided && this.master.altCameraSource) {
                this.master.altCameraSource = false
            }

            this.removeFromGrid();
            this.isGhost = true;
            //newLogs.destroy.stop();
            for (let turret of this.turrets) {
                turret.destroy();
            }
            // Evolve stuff
            if (this.evolutionTimeout) {
                clearTimeout(this.evolutionTimeout)
            }
            // Explosions, phases and whatnot
            if (this.onDead != null && !this.hasDoneOnDead) {
                this.hasDoneOnDead = true;
                this.onDead();
            }
            // Second function so onDead isn't overwritten by specific gamemode features
            if (this.modeDead != null && !this.hasDoneModeDead) {
                this.hasDoneModeDead = true;
                this.modeDead();
            }
            //entities.delete(this.id);
            this.isGhost = true;
        }
        isDead() {
            return this.health.amount <= 0 || this.isGhost;
        }
        isAlive() {
            return /*this != null && */ this.health.amount > 0 && !this.isGhost;
        }
        toggleRainbow() {
            this.rainbow = !this.rainbow;
            if (this.rainbow) this.intervalID = setInterval(this.rainbowLoop, this.rainbowSpeed);
            else clearInterval(this.intervalID);
        }
        rainbowLoop() {
            if (this.color < 100 || isNaN(this.color)) this.color = 100;
            this.color = (this.color - 100 + 1) % 86 + 100;
            if (this.multibox.enabled)
                for (let o of this.multibox.controlledTanks)
                    if (o.isAlive()) o.color = this.color;
        }
        toggleMultibox() {
            this.multibox.intervalID = setInterval(this.multiboxLoop, 500);
        }
        multiboxLoop() {
            this.settings.hitsOwnType = "never";
            for (let controlledBody of this.multibox.controlledTanks)
                if (controlledBody.isAlive()) {
                    controlledBody.autoOverride = this.autoOverride;
                    controlledBody.passive = this.passive;
                    controlledBody.godmode = this.godmode;
                    entities.forEach(o => {
                        if (o.master.id === controlledBody.id && o.id !== controlledBody.id) {
                            o.passive = controlledBody.passive;
                            o.diesToTeamBase = !controlledBody.godmode;
                        }
                    });
                    controlledBody.skill.set(this.skill.raw);
                    controlledBody.refreshBodyAttributes();
                    if (controlledBody.skill.score < 59214) {
                        controlledBody.skill.score = this.skill.score;
                        controlledBody.skill.level = this.skill.level;
                    }
                    if (controlledBody.tank !== this.tank) controlledBody.upgradeTank(this.tank);
                    controlledBody.tank = this.tank;
                    controlledBody.FOV = .1;
                    controlledBody.refreshFOV();
                    if (room.gameMode === "tdm") controlledBody.team = this.team;
                    else controlledBody.team = this.team = -9;
                    controlledBody.color = this.color;
                    controlledBody.settings.leaderboardable = false;
                    controlledBody.layer = this.layer - .5;
                    controlledBody.SIZE = this.SIZE;
                    controlledBody.nameColor = this.nameColor;
                    controlledBody.alpha = this.alpha;
                    controlledBody.ALPHA = this.ALPHA;
                }

        }
        relinquish(player) {
            if (player.body.isMothership) {
                player.body.nameColor = ["#00B0E1", "#F04F54", "#00E06C", "#BE7FF5", "#FFEB8E", "#F37C20", "#E85DDF", "#8EFFFB"][player.team - 1];
                player.body.controllers = [new ioTypes.nearestDifferentMaster(player.body), new ioTypes.mapTargetToGoal(player.body), new ioTypes.roamWhenIdle(player.body)];
                player.body.name = "Mothership";
            } else {
                player.body.controllers = [new ioTypes.nearestDifferentMaster(player.body), new ioTypes.spinWhileIdle(player.body)];
                player.body.nameColor = "#FFFFFF";
                if (player.body.label === "Trapper Dominator") {
                    player.body.addController(new ioTypes.alwaysFire(player.body));
                    player.body.facingType = "autospin";
                }
                player.body.name = "";
            }
            player.body.underControl = false;
            player.body.autoOverride = false;
            player.body.sendMessage = (content, color=0) => { this.talk("m", content, color) };
            player.body.rewardManager = (id, amount) => { };
            let fakeBody = new Entity({
                x: player.body.x,
                y: player.body.y
            });
            fakeBody.passive = true;
            fakeBody.underControl = true;
            player.body = fakeBody;
            player.body.kill();
        }
        runAnimations(gun) {
            let onShoot = gun.onShoot;
            if (gun.onShoot && gun.onShoot.animation) {
                const frames = gun.onShoot.frames;
                for (let i = 1; i <= frames; i++) setTimeout(() => {
                    if (gun.body.health.amount <= 0) {
                        return;
                    }
                    if (gun.onShoot.end && i === frames) {
                        gun.body.master.upgrades = [];
                    }
                    const id = `${gun.onShoot.transformExport}${gun.onShoot.end ? frames - i : i}`;
                    try {
                        gun.body.master.define(Class[id]);
                    } catch (e) {
                        console.log(id);
                    }
                }, 20 * i);
                return;
            }

            switch (onShoot) {
                case "log":
                    console.log("LOG");
                    break;
                case "hitScan":
                case "hitScan1":
                case "hitScan2":
                case "hitScan3": {
                    if (this.master.health.amount < 0) break;
                    let save = {
                        x: this.master.x,
                        y: this.master.y,
                        angle: this.master.facing + gun.angle
                    };
                    let s = this.size * gun.width * gun.settings2.size;
                    let target = {
                        x: save.x + this.control.target.x,
                        y: save.y + this.control.target.y
                    };
                    let amount = util.getDistance(target, save) / s | 0;
                    let explode = e => {
                        e.onDead = () => {
                            let o = new Entity(e, this);
                            o.accel.x = 3 * Math.cos(save.angle);
                            o.accel.y = 3 * Math.sin(save.angle);
                            o.color = this.master.color;
                            o.define(Class.hitScanExplosion);
                            // Pass the gun attributes
                            o.define({
                                BODY: gun.interpret(gun.settings3),
                                SKILL: gun.getSkillRaw(),
                                SIZE: (this.size * gun.width * gun.settings3.size) / 2,
                                LABEL: this.label + (gun.label ? " " + gun.label : "") + " " + o.label
                            });
                            o.refreshBodyAttributes();
                            o.life();
                            o.source = this;
                        }
                    };
                    let branchAlt = 0;
                    let branchLength = 0;
                    let branch = (e, a, b = false, g = 0, z = amount) => {
                        if (!b) branchAlt++;
                        let total = (z / 5 | 0) || 2;
                        let dir = (a ? Math.PI / 2 : -Math.PI / 2) + g;
                        for (let i = 0; i < total; i++) setTimeout(() => {
                            let ss = s * 1.5;
                            let x = e.x + (ss * Math.cos(save.angle + dir)) * i;
                            let y = e.y + (ss * Math.sin(save.angle + dir)) * i;
                            let o = new Entity({
                                x,
                                y
                            }, this);
                            o.facing = Math.atan2(target.y - y, target.x - x) + dir;
                            o.color = this.master.color;
                            o.define(Class.hitScanBullet);
                            // Pass the gun attributes
                            o.define({
                                BODY: gun.interpret(gun.settings3),
                                SKILL: gun.getSkillRaw(),
                                SIZE: (this.size * gun.width * gun.settings2.size) / 2,
                                LABEL: this.label + (gun.label ? " " + gun.label : "") + " " + o.label
                            });
                            o.refreshBodyAttributes();
                            o.life();
                            o.source = this;
                            if (i === total - 1) {
                                if (branchLength < 3) {
                                    branchLength++;
                                    branch(o, a, true, dir + g, total);
                                } else branchLength = 0;
                            }
                        }, (500 / amount) * i);
                    };
                    const hitScanLevel = +onShoot.split("hitScan").pop();
                    for (let i = 0; i < amount; i++) {
                        setTimeout(() => {
                            if (this.master.health.amount < 0) return;
                            let x = save.x + (s * Math.cos(save.angle)) * i;
                            let y = save.y + (s * Math.sin(save.angle)) * i;
                            let e = new Entity({
                                x: x,
                                y: y
                            }, this);
                            e.facing = Math.atan2(target.y - y, target.x - x);
                            e.color = this.master.color;
                            e.define(Class.hitScanBullet);
                            // Pass the gun attributes
                            e.define({
                                BODY: gun.interpret(gun.settings2),
                                SKILL: gun.getSkillRaw(),
                                SIZE: (this.size * gun.width * gun.settings2.size) / 2,
                                LABEL: this.label + (gun.label ? " " + gun.label : "") + " " + e.label
                            });
                            e.refreshBodyAttributes();
                            e.life();
                            e.source = this;
                            switch (hitScanLevel) {
                                case 1: {
                                    if (i % 5 === 0) branch(e, branchAlt % 2 === 0);
                                }
                                    break;
                                case 2: { // Superlaser
                                    if (i === amount - 1) explode(e);
                                }
                                    break;
                                case 3: { // Death Star
                                    if (i % 3 === 0) explode(e);
                                }
                                    break;
                            }
                        }, 10 * i);
                    }
                }
                    break;
                case "revo":
                    if (this.isAlive()) this.define(Class.baseThrowerFire);
                    break;
                case "harpoon":
                    if (this.isAlive()) this.define(Class.harpoonNo);
                    break;
                case "leister":
                    if (this.isAlive()) this.define(Class.leisterNo);
                    break;
                case "mei":
                    if (this.isAlive()) this.define(Class.meiFire);
                    break;
                case "hand":
                case "hand2":
                case "hand3":
                case "hand4": {
                    let increment = onShoot === "hand2" ? 20 : onShoot === "hand3" ? 40 : onShoot === "hand4" ? 60 : 0,
                        tank = this.label === "Auto-Glove" ? "autoHandBasic" : "handBasic";
                    for (let i = 1; i < 21; i++) setTimeout(() => {
                        if (this.isAlive()) this.define(Class[`${tank}${i + increment}`]);
                    }, this.skill.rld * 20 * i); // 9.5
                }
                    break;
                case "hand5":
                    this.upgrades = [];
                    if (this.isAlive()) this.define(this.label === "Auto-Glove" ? Class.autoHandBasic0 : Class.handBasic0);
                    break;
                case "oxy":
                    if (this.isAlive()) this.define(Class.greenGuardianLauncher);
                    break;
                case "oxy2":
                    if (this.isAlive()) this.define(Class.greenMiniGuardianLauncher);
                    break;
                case "hybranger":
                case "hybranger2":
                    entities.forEach(o => {
                        if (o.master.id === this.id && o.type === "drone") o.kill();
                    });
                    for (let i = 1; i < 32; i++) setTimeout(() => {
                        if (this.isAlive()) this.define(Class[`hybranger${onShoot === "hybranger" ? i : (i === 31 ? 0 : i + 31)}`]);
                    }, 14 * i);
                    break;
                case "shape":
                case "shape2":
                    entities.forEach(o => {
                        if (o.master.id === this.id && o.type === "drone") o.kill();
                    });
                    for (let i = 1; i < 32; i++) setTimeout(() => {
                        if (this.isAlive()) this.define(Class[`shapeChange${onShoot === "shape" ? i : 31 - i}`]);
                    }, 14 * i);
                    break;
                case "surge":
                case "surge2":
                    for (let i = 1; i < 21; i++) setTimeout(() => {
                        if (this.isAlive()) this.define(Class[`sniperEMP${onShoot === "surge" ? i : 20 + i}`]);
                    }, this.skill.rld * (onShoot === "surge" ? 180 : 60) * i);
                    break;
                case "surge3":
                    if (this.isAlive()) this.define(Class.sniperEMP0);
                    break;
                case "glove":
                case "glove2":
                case "glove3":
                case "glove4": {
                    let increment = onShoot === "glove2" ? 20 : onShoot === "glove3" ? 40 : onShoot === "glove4" ? 60 : 0,
                        tank = "mittens";
                    for (let i = 1; i < 21; i++) setTimeout(() => {
                        if (this.isAlive()) this.define(Class[`${tank}${i + increment}`]);
                    }, this.skill.rld * 20 * i); // 9.5
                }
                    break;
                case "glove5":
                    this.upgrades = [];
                    if (this.isAlive()) this.define(Class.mittens0);
                    break;
                default:
                    util.warn("Unknown ON_SHOOT value: " + onShoot + "!");
                    onShoot = null;
            };
        }
    }
    workerWindow.Entity = Entity

    const logs = (() => {
        const logger = (() => {
            const set = obj => {
                obj.time = util.time();
            };
            const mark = obj => {
                obj.data.push(util.time() - obj.time);
            };
            const record = obj => {
                let o = util.averageArray(obj.data);
                obj.data = [];
                return o;
            };
            const sum = obj => {
                let o = util.sumArray(obj.data);
                obj.data = [];
                return o;
            };
            const tally = obj => {
                obj.count++;
            };
            const count = obj => {
                let o = obj.count;
                obj.count = 0;
                return o;
            };
            return () => {
                let internal = {
                    data: [],
                    time: util.time(),
                    count: 0
                };
                return {
                    set: () => set(internal),
                    mark: () => mark(internal),
                    record: () => record(internal),
                    sum: () => sum(internal),
                    count: () => count(internal),
                    tally: () => tally(internal)
                };
            };
        })();
        return {
            entities: logger(),
            collide: logger(),
            network: logger(),
            minimap: logger(),
            //misc2: logger(),
            //misc3: logger(),
            physics: logger(),
            life: logger(),
            selfie: logger(),
            master: logger(),
            activation: logger(),
            loops: logger()
        };
    })();

    /*const newLogs = (function () {
        class Log {
            constructor(name) {
                this.name = name;
                this.startAt = 0;
                this.time = 0;
                this.totalTime = 0;
                this.count = 0;
            }
            start() {
                this.startAt = performance.now();
            }
            stop() {
                this.time += performance.now() - this.startAt;
                this.totalTime += this.time;
                this.tally();
            }
            get average() {
                return (this.totalTime == 0 || this.count == 0) ? 0 : this.totalTime / this.count;
            }
            tally() {
                this.count++;
                if (this.count >= 100_000) {
                    this.count = 0;
                    this.totalTime = 0;
                }
            }
            reset() {
                this.startAt = this.time = 0;
            }
        }
        const output = {
            // GAME TICK
            collision: new Log("Collision"),
            queryForCollisionPairs: new Log("QuadTree (queryForCollisionPairs)"),
            entities: new Log("Entities"),
            // Entity Functions
            location: new Log("Entity.prototype.location()"),
            death: new Log("Entity.prototype.death()"),
            life: new Log("Entity.prototype.life()"),
            destroy: new Log("Entity.prototype.destroy()"),
            activation: new Log("Activation"),
            controllers: new Log("AI and Controllers"),
            moveFace: new Log("Move and Face"),
            physics: new Log("Physics"),
            camera: new Log("Selfie snap :D"),
            buildList: new Log("BuildList"),
            targeting: new Log("Targeting"),
            aspects: new Log("Guns"),
            // Other Functions
            broadcast: new Log("Minimaps & Leaderboards"),
            network: new Log("Socket bs"),
        };
        return output;
    })();
*/
    /*const sockets = (() => {
        const protocol = require("./lib/fasttalk");
        const bans = [];
        const backlog = [];
        let lastConnection = Date.now() - 501;
        class BacklogData {
            constructor(id, ip) {
                this.id = id;
                this.ip = ip;
                backlog.push(this);
            }
        }
        let id = 0;*/
function flatten(data) {
    const output = [data.type];
    
    if (data.type & 0x01) {
        output.push(+(data.facing).toFixed(2), data.layer);
    } else {
        // Pre-calculate values that are used multiple times
        const x = (data.x + .5) | 0;
        const y = (data.y + .5) | 0;
        const size = (data.size + .5) | 0;
        const facing = +(data.facing).toFixed(2);
        
        // Create flags as a number instead of building it incrementally
        let flags = 0;
        flags |= data.twiggle ? 1 : 0;
        flags |= data.layer !== 0 ? 2 : 0;
        flags |= data.health < .975 ? 4 : 0;
        flags |= data.shield < .975 ? 8 : 0;
        flags |= data.alpha < .975 ? 16 : 0;
        flags |= data.seeInvisible ? 32 : 0;
        flags |= data.nameColor !== "#FFFFFF" ? 64 : 0;
        flags |= data.label ? 128 : 0;
        flags |= data.sizeRatio[0] !== 1 ? 256 : 0;
        flags |= data.sizeRatio[1] !== 1 ? 512 : 0;
        
        // Add common elements
        output.push(data.id, flags, data.index, x, y, size, facing);
        
        // Add conditional elements based on flags
        if (flags & 2) output.push(data.layer);
        output.push(data.color ?? 0, data.team);
        if (flags & 4) output.push(Math.ceil(255 * data.health));
        if (flags & 8) output.push(Math.ceil(255 * data.shield));
        if (flags & 16) output.push(Math.ceil(255 * data.alpha));
        if (flags & 64) output.push(data.nameColor);
        if (flags & 128) output.push(data.label);
        if (flags & 256) output.push(data.sizeRatio[0]);
        if (flags & 512) output.push(data.sizeRatio[1]);
        
        // Add type-specific elements
        if (data.type & 0x04) {
            output.push(data.name || "", data.score || 0, data.messages ? JSON.stringify(data.messages) : "[]");
        }
    }
    
    // Add gun data
    const gunCount = data.guns.length;
    output.push(gunCount);
    
    // Unroll loop for guns
    for (let i = 0; i < gunCount; i++) {
        const gun = data.guns[i];
        output.push((gun.time + .5) | 0, (gun.power + .5) | 0);
    }
    
    // Add turret data
    const turretCount = data.turrets.length;
    output.push(turretCount);
    
    // Process turrets
    for (let i = 0; i < turretCount; i++) {
        output.push.apply(output, flatten(data.turrets[i]));
    }
    
    return output;
}

        function perspective(e, player, data) {
            if (player.body != null && player.body.id === e.master.id) {
                data = data.slice();
                if (player.command.autospin) {
                    if (data[2] % 2 === 0) {
                        data[2] += 1;
                    }
                }
                if (room.gameMode === "ffa" && player.body.color === "FFA_RED") data[(data[2] & 2) ? 9 : 8] = (player.teamColor ?? 0);
            }
            return data;
        }
    const sockets = (() => {
        const protocol = require("./lib/fasttalk");
        const bans = [];
        const backlog = [];
        let lastConnection = Date.now() - 501;
        class BacklogData {
            constructor(id, ip) {
                this.id = id;
                this.ip = ip;
                backlog.push(this);
            }
        }
        let id = 0;
        const checkInView = (camera, obj) => Math.abs(obj.x - camera.x) < camera.fov * .6 + 1.5 * (obj.size * (obj.width || 1)) + 100 && Math.abs(obj.y - camera.y) < camera.fov * .6 * .5625 + 1.5 * (obj.size * (obj.height || 1)) + 100;
        /*const traffic = socket => {
            let strikes = 0;
            return () => {
                if (util.time() - socket.status.lastHeartbeat > c.maxHeartbeatInterval) {
                    socket.error("traffic evaluation", "Heartbeat lost", true);
                    return 0;
                }
                if (socket.status.requests > 50) strikes++;
                else strikes = 0;
                if (strikes > 3) {
                    socket.error("traffic evaluation", "Socket traffic volume violation", true);
                    return 0;
                }
                socket.status.requests = 0;
            };
        };*/
        function validateHeaders(request) {
            let valid = ["localhost", "woomy-site.glitch.me", "woomy-api.glitch.me", "woomy-api-dev.glitch.me", "woomy.app", ".rivet.game"];
            let has = [0, 0];
            if (request.headers.origin) {
                for (let ip of valid) {
                    if (request.headers.origin.includes(ip)) {
                        has[0]++;
                    }
                }
            }
            if (request.headers["user-agent"]) {
                for (let agent of ["Mozilla", "AppleWebKit", "Chrome", "Safari"]) {
                    if (request.headers["user-agent"].includes(agent)) {
                        has[1]++;
                    }
                }
            }
            return !(has[0] !== 1 || has[1] === 0);
        }
        const generateEvalPacket = require("./lib/generateEvalCode.js");
        api.apiEvent.on("badIp", (data) => {
            let socket = clients.find(client => client.ip === data.data.ip)

            if (socket.betaData.permissions > 1) {
                return;
            }
            
            if (!socket) {
                util.warn(`Tried to kick ${socket?.ip} for bad ip but the socket could not be found`)
                return
            }
            util.warn("Bad IP connection attempt terminated")
            socket.lastWords("P", `Your ip has been banned. Reason: "${data.data.reason}". `);
        })      
      
        class SocketUser {
            constructor(playerId) {
                util.log("New socket initiated!");
                userSockets.set(playerId, this)
                this.id = id++;
                this._socket = userSocket(playerId);
                this.sentPackets = 0
                this.receivedPackets = 0
                this.camera = {
                    x: undefined,
                    y: undefined,
                    vx: 0,
                    vy: 0,
                    lastUpdate: util.time(),
                    lastDowndate: undefined,
                    fov: 2000
                };
                this.animationsToDo = new Map();
                this.betaData = {
                    permissions: 0,
                    nameColor: "#FFFFFF",
                    discordID: -1,
                    username: "",
                    globalName: "",
                };
                this.player = {
                    camera: {},
                    id: this.id
                };
                this.status = {
                    verified: false,
                    receiving: 0,
                    deceased: true,
                    requests: 0,
                    hasSpawned: false,
                    needsFullMap: true,
                    needsFullLeaderboard: true,
                    needsNewBroadcast: true,
                    lastHeartbeat: util.time(),
                    previousScore: 0
                };
                this._socket.binaryType = "arraybuffer";
                this._socket.on("message", message => this.incoming(message));
                this._socket.on("close", () => {
                    if ("loops" in this) {
                        this.loops.terminate();
                    }
                    this.close();
                });
                this._socket.on("error", e => {
                    util.error("" + e);
                    if ("logDisconnect" in global) {
                        global.logDisconnect(e);
                    }
                    this._socket.terminate();
                    this.close();
                });
                /*if (!validateHeaders(request)) {
                    this.lastWords("P", "Connection too unstable to be verified.");
                    util.warn("User tried to connect to the game from an invalid client!");
                    return;
                }
                // Keys
                try {
                    let url = (this._request._parsedUrl?.query || this._request.url.split("/?")[1]);
                    this.IDKeys = Object.fromEntries(url.split("&").map(entry => (entry = entry.split("="), [entry[0], Number(entry[1])])));
                    if (JSON.stringify(Object.keys(this.IDKeys)) !== '["a","b","c","d","e"]') {
                        this.lastWords("P", "Invalid Identification set!");
                        util.warn("Invalid identification set! (Keys)");
                        return;
                    }
                    if (Object.values(this.IDKeys).some(value => value !== Math.round(Math.min(Math.max(value, 1000000), 10000000)))) {
                        this.lastWords("P", "Invalid Identification set!");
                        util.warn("Invalid identification set! (Values) " + Object.values(this.IDKeys));
                        return;
                    }
                    if (clients.find(client => JSON.stringify(client.IDKeys) === JSON.stringify(this.IDKeys))) {
                        this.lastWords("P", "Invalid Identification set!");
                        util.warn("Invalid identification set! (Duplicates)");
                        return;
                    }
                } catch (error) {
                    util.warn(error.stack);
                    socket.terminate();
                    return;
                }*/
                this.ip = "127.0.0.1"
                /*try {
                    this.ip = request.headers["x-forwarded-for"] || request.connection.remoteAddress;
                    if (!this.ip) throw new Error("No IP address found!");
                    if (this.ip.startsWith("::ffff:")) this.ip = this.ip.slice(7);
                } catch (e) {
                    this.lastWords("P", "Invalid IP, connection terminated.");
                    util.warn("Invalid IP, connection terminated.\n" + e);
                    return;
                }*/

                /*if (Date.now() - lastConnection < 500) {
                    this.talk("P", "Connection rate limit reached, please try again.");
                    util.warn("Rate limit triggered!");
                    socket.terminate();
                    return;
                }*/
                lastConnection = Date.now();/*
                try {
                    fetch("http://isproxy.glitch.me/lookup?ping=yes&ip=" + this.ip).then(response => response.json()).then(json => {
                        if (json.isBanned) {
                            this.talk("P", "VPN/Proxy detected, please disable it and try rejoining.");
                            console.log("User disconnected due to VPN/Proxy!");
                            socket.terminate();
                        }
                    });
                } catch(error) {
                    util.warn("Unable to fetch from proxyDB!");
                }*/
                api.apiConnection.talk({
                    type: "checkIp",
                    data: {
                        ip: this.ip
                    }
                })

                /*let ban = bans.find(instance => instance.ip === this.ip);
                if (ban) {
                    this.lastWords("P", "You have been banned from the server. Reason: " + ban.reason);
                    util.warn("A socket was terminated before verification due to being banned!");
                    return;
                }
                const sameIP = clients.filter(client => client.ip === this.ip).length;
                if (sameIP >= c.tabLimit) {
                    this.lastWords("P", "Too many connections from this IP have been detected. Please close some tabs and try again.");
                    util.warn("A socket was terminated before verification due to having too many connections with the same IP open!");
                    return;
                }*/
                this.nextAllowedRespawnData = 0;
                /*this.loops = (() => {
                    let nextUpdateCall = null,
                        trafficMonitoring = setInterval(() => traffic(this), 1500);
                    return {
                        setUpdate: timeout => {
                            nextUpdateCall = timeout;
                        },
                        cancelUpdate: () => {
                            clearTimeout(nextUpdateCall);
                        },
                        terminate: () => {
                            clearTimeout(nextUpdateCall);
                            clearTimeout(trafficMonitoring);
                        }
                    };
                })();*/
                this.makeView();
                this.spawnCount = 0;
                this.name = undefined;
                /*this.update = time => {
                    this.loops.cancelUpdate();
                    this.loops.setUpdate(setTimeout(() => {
                        this.view.gazeUpon();
                    }, time));
                };*/
                this.inactivityTimeout = null;
                this.beginTimeout = () => {
                    this.inactivityTimeout = setTimeout(() => {
                        /*this.talk("P", "You were disconnected for inactivity.");
                        this.kick("Kicked for inactivity!");*/
                    }, (c.INACTIVITY_TIMEOUT || 360) * 1000);
                };
                this.endTimeout = () => clearTimeout(this.inactivityTimeout);
                this.backlogData = new BacklogData(this.id, this.ip);
                //this.runEvalPacket();
                this.animationsInterval = setInterval(this.animationsUpdate.bind(this), 1000 / 5);// 5 fps animations
                /*this.activityTimeout = setInterval(()=>{
                    //this.talk("level")
                },6000);*/
                clients.push(this);
            }
            animationsUpdate() {
                if (this.animationsToDo.size === 0) {
                    return;
                }
                let packet = ["am", this.animationsToDo.size];
                this.animationsToDo.forEach((value, key) => {
                    packet.push(key, value.length, ...value);
                });
                this.animationsToDo.clear();
                this.talk(...packet);
            }
            runEvalPacket() {
                /*this.sendEvalPacket().then(isGood => {
                    if (!isGood) {
                        this.lastEvalPacketEnded = Date.now();
                        //this.kick("You failed the vibe check");
                    } else {
                        this.lastEvalPacketEnded = Date.now();
                    }
                });*/
            }
            sendEvalPacket() {
                return new Promise((resolve, reject) => {
                    const challenge = generateEvalPacket(this.IDKeys);
                    this.talk("I_solemnly_swear_I_wont_exploit", LZString.compressToEncodedURIComponent(challenge.code));
                    let t = 7, i = setInterval(() => {
                        if (util.time() - this.status.lastHeartbeat < 6000) { // Don't count tabbed out
                            if (t-- <= 0) {
                                clearInterval(t);
                                resolve(false);
                            }
                        }
                    }, 1000);
                    this.clearEvalInterval = (response) => {
                        let checksPassed = 0
                        let requiredChecks = 2
                        /*
                            0 = eval
                            1 = _sent (receive for server)
                            2 = _receive (sent for server)
                        */

                        // Beat eval
                        if (response[0] === challenge.result) {
                            checksPassed++
                        }

                        //console.log(response[2], ((_random() * 10000) | 0))
                        //console.log(response[2] - ((_random() * 10000) | 0))

                        // Beat sent/receive
                        let buffer = 50
                        response[2] -= 80085
                        response[1] -= 80085
                        if (
                            response[2] > this.sentPackets - buffer && response[2] < this.sentPackets + buffer &&
                            response[1] > this.receivedPackets - buffer && response[1] < this.receivedPackets + buffer
                        ) {
                            //console.log("did packets")
                            checksPassed++
                        }
                        //console.log(response[4], this.sentPackets)
                        //console.log(response[3], this.receivedPackets)


                        // Did they pass the vibe check?
                        if (checksPassed < requiredChecks) {
                            resolve(false);
                            console.log(this.ip, `failed the eval packet (${checksPassed}/${requiredChecks})`)
                        } else {
                            clearInterval(i);
                            resolve(true);
                        }
                        delete this.clearEvalInterval;
                    }
                });
            }
            get readableID() {
                return `Socket (${this.id}) [${this.name || "Unnamed Player"}]: `;
            }
            get open() {
                return this._socket.readyState === this._socket.OPEN;
            }
            talk(...message) {
                /*if (this.open) {
                    (true) ? this._socket.send(WASMModule.shuffle(protocol.encode(message)), {
                        binary: true
                    }) : postToWorker(message, uint8 => {
                        this._socket.send(uint8, {
                            binary: true
                        });
                    }, this.id);
                }*/
                this.sentPackets++
                if (this.open) {
                        this._socket.send((message), {
                            binary: true
                        });
                }
            }
            lastWords(...message) {
                if (this.open) {
                    this._socket.send((message), {
                        binary: true
                    }, () => {
                        setTimeout(() => {
                            this._socket.terminate();
                        }, 1000);
                    });
                }/*
                if (this.open) {
                    this._socket.send(WASMModule.shuffle(protocol.encode(message)), {
                        binary: true
                    }, () => {
                        setTimeout(() => {
                            this._socket.terminate();
                        }, 1000);
                    });
                }*/
            }
            error(type = "unknown", reason = "unspecified", report = false) {
                this.talk("P", `Something went wrong during the ${type} process: ${reason}. ${report ? "Please report this bug if it continues to occur." : ""}`);
                this.kick(reason + "!");
            }
            kick(reason = "Unspecified.") {
                util.warn(this.readableID + "has been kicked. Reason: " + reason);
                this.talk("P", "You have been kicked: " + reason)
                this.lastWords("K");
                this.talk("closeSocket")
            }
            ban(reason) {
                if (this.isBanned) {
                    return;
                }
                this.isBanned = true;
                util.warn(this.readableID + "has been banned. Reason: " + reason);
                bans.push({
                    ip: this.ip,
                    reason: reason
                });
                this.talk("P", "You have been banned: " + reason)
                this.lastWords("K");
                this.talk("closeSocket")
            }
            close(isBanned) {
                this.talk("closeSocket")
                if (this.isClosed) {
                    return;
                }

                this.isClosed = true;

                let player = this.player || {},
                    index = players.indexOf(player),
                    body = player.body;
                if (index !== -1) {
                    let below5000 = false;
                    if (body != null && body.skill.score < 5000) {
                        below5000 = true;
                    }
                    setTimeout(() => {
                        if (body != null) {
                            if (body.underControl) {
                                body.relinquish(player);
                            } else {
                                body.kill();
                            }
                        }
                    }, below5000 ? 1 : c.disconnectDeathTimeout);
                    if (this.inactivityTimeout != null) this.endTimeout();
                }
                if (global.isVPS && typeof this.rivetPlayerToken === "string") rivet.matchmaker.players.disconnected({ playerToken: this.rivetPlayerToken });
                util.info(this.readableID + "has disconnected! Players: " + (clients.length - 1).toString());
                if(isBanned !== true) sockets.broadcast(trimName(this.name)+" has left the server! ("+(players.length-1) +" players)","red")
                api.apiConnection.talk({
                    type: "updatePlayerCount",
                    data: {
                        count: clients.length - 1
                    }
                })
                players = players.filter(player => player.id !== this.id);
                clients = clients.filter(client => client.id !== this.id);
                views = views.filter(view => view.id !== this.id);
                clearInterval(this.animationsInterval);
                worker.postMessage({type:"updatePlayers", data:players.length})
            }
            closeWithReason(reason) {
                this.talk("P", reason);
                this.kick(reason);
            }
            makeGUI() {
                const skilNames = ["atk", "hlt", "spd", "str", "pen", "dam", "rld", "mob", "rgn", "shi"];
                const cache = {
                    _: {},
                    get: key => {
                        if (cache._[key] == null) {
                            return null;
                        }
                        const output = cache._[key] != null && cache._[key].update && cache._[key].value;
                        cache._[key].update = false;
                        return output;
                    },
                    set: (key, value) => {
                        if (cache._[key]) {
                            let updated = false;
                            if (value instanceof Array) {
                                updated = value.length !== cache._[key].value.length || value.some((element, index) => cache._[key].value[index] !== element);
                            } else if (value !== cache._[key].value) {
                                updated = true;
                            }
                            if (!updated) {
                                return;
                            }
                        }
                        cache._[key] = {
                            update: true,
                            value: value
                        };
                    }
                };
                function getSkills(body) {
                    let val = 0;
                    val += 0x1 * body.skill.amount("atk");
                    val += 0x10 * body.skill.amount("hlt");
                    val += 0x100 * body.skill.amount("spd");
                    val += 0x1000 * body.skill.amount("str");
                    val += 0x10000 * body.skill.amount("pen");
                    val += 0x100000 * body.skill.amount("dam");
                    val += 0x1000000 * body.skill.amount("rld");
                    val += 0x10000000 * body.skill.amount("mob");
                    val += 0x100000000 * body.skill.amount("rgn");
                    val += 0x1000000000 * body.skill.amount("shi");
                    return val.toString(36);
                } 
                cache.set("time", performance.now());
                return () => {
                    let current = cache.get("time"),
                        output = [0],
                        body = this?.player?.body;
                    if (performance.now() - current > 1000) {
                        cache._ = {};
                        cache.set("time", performance.now());
                    }
                    cache.set("mspt", room.mspt);
                    if (body) {
                        cache.set("label", [body.index, this.player.teamColor != null ? this.player.teamColor : body.color, body.id]);
                        cache.set("score", body.skill.score + .5 | 0);
                        if (!body.lvlCheated && body.skill.score > 59212) body.rewardManager(-1, "wait_its_all_sandbox");
                        cache.set("points", body.skill.points);
                        cache.set("upgrades", body.upgrades.filter(up => up.level <= body.skill.level).map(up => up.index));
                        cache.set("skillNames", skilNames.map(name => [body.skill.title(name), body.skill.cap(name), body.skill.cap(name, true)]).flat());
                        cache.set("skills", getSkills(body));
                    }
                    if (current = cache.get("mspt"), current != null && current !== false) {
                        output[0] += 0x0001;
                        output.push(current);
                    }
                    if (current = cache.get("label"), current != null && current !== false) {
                        output[0] += 0x0002;
                        output.push(...current);
                    }
                    if (current = cache.get("score"), current != null && current !== false) {
                        output[0] += 0x0004;
                        output.push(current);
                    }
                    if (current = cache.get("points"), current != null && current !== false) {
                        output[0] += 0x0008;
                        output.push(current);
                    }
                    if (current = cache.get("upgrades"), current != null && current !== false) {
                        output[0] += 0x0010;
                        output.push(current.length, ...current);
                    }
                    if (current = cache.get("skillNames"), current != null && current !== false) {
                        output[0] += 0x0020;
                        output.push(...current);
                    }
                    if (current = cache.get("skills"), current != null && current !== false) {
                        output[0] += 0x0040;
                        output.push(current);
                    }
                    return output;
                }
            }
            makeView() {
                this.view = {
                    id: this.id,
                    check: object => checkInView(this.camera, object),
                };
                views.push(this.view);
            }
            async incoming(message) {
                this.receivedPackets++
                /*if (!(message instanceof ArrayBuffer)) {
                    this.error("initialization", "Non-binary packet", true);
                    return 1;
                }
                if (!message.byteLength || message.byteLength > 512) {
                    this.error("dumbass", "Malformed packet", true);
                    return 1;
                }*/
                //message = WASMModule.shuffle(Array.from(new Uint8Array(message)));
                let m = (message);
                if (m == null || m === -1) {
                    this.error("initialization", "Malformed packet", true);
                    return 1;
                }
                let player = this.player,
                    body = player != null ? player.body : null,
                    isAlive = body != null && body.health.amount > 0 && !body.isGhost,
                    index = m.shift();
                switch (index) {
                    case "k": { // Verify Key
                        if (room.arenaClosed) return;
                        if (m.length !== 4) {
                            this.error("token verification", "Ill-sized token request", true);
                            return 1;
                        }
                        if (typeof m[1] !== "string") {
                            this.error("token verification", "Non-string socket id was offered: " + typeof m[2])
                        }
                        if (typeof m[2] !== "string") {
                            this.error("token verification", "Non-string rivet player id was offered: " + typeof m[2])
                        }
                        let key = m[0];
                        if (key.length > 124) {
                            this.error("token verification", "Overly-long token offered");
                            return 1;
                        }
                        if (this.status.verified) {
                            this.error("spawn", "Duplicate spawn attempt", true);
                            return 1;
                        }

                        /*if(m[0]){
                            await fetch("https://discord.com/api/v10/users/@me", {
                                headers: {
                                    Authorization: "Bearer " + m[0],
                                },
                            }).then((res) => res.json()).then((userData) => {
                                if (userData.code != undefined) {
                                    return
                                };
                            }).catch((err)=>{});
                        }*/
                        if(players.length === 0){
                          this.betaData = {
                            permissions: 4,
                            nameColor: "#ffa600",
                            username: "Not An Actual Token (lmao) - Musicalement",
                            globalName: "Room Host",
                            discordID: "1",
                            //canPromoteToLvl4: true
                          }
                        }

                        if (room.testingMode) {
                            if (this.betaData?.permissions !== 5) {
                                this.closeWithReason("The Room Host Enabled Test Mode: no players may join.");
                                return 1;
                            }
                        }


                        /*if (multitabIDs.indexOf(m[1]) !== -1 && this.betaData.permissions < 1) {
                            this.closeWithReason("Please only use one tab at once!");
                            return 1;
                        }*/
                        if(global.isVPS) rivet.matchmaker.players.connected({ playerToken: m[2] }).catch(err => this.closeWithReason("Rivet player verification failed"));
                        this.rivetPlayerToken = m[2]
                        this.identification = m[1];
                        this.verified = true;
                        this.usingAdBlocker = m[3]
                        this.talk("w", c.RANKED_BATTLE ? "queue" : true);
                        //                      if (c.serverName.includes("Sandbox") && this.betaData.permissions === 0) this.betaData.permissions = 1; 
                        if (key) {
                            util.info("A socket was verified with the token: " + this.betaData.username || "Unknown Token" + ".");
                        }
                    } break;
                    case "j": { // Rejoin queue
                        if (this.roomId === "ready") {
                            this.roomId = null;
                        }
                    } break;
                    case "s": {// Spawn request
                        if (!this.status.deceased) {
                            this.error("spawn", "Trying to spawn while already alive", true);
                            return 1;
                        }
                        if (Date.now() < this.nextAllowedRespawnData) {
                            this.error("spawn", "Trying to respawn too early", true);
                            return 1;
                        }
                        if (m.length !== 4) {
                            this.error("spawn", "Ill-sized spawn request", true);
                            return 1;
                        }
                        this.party = +m[0];
                        if (c.SANDBOX) {
                            const room = global.sandboxRooms.find(entry => entry.id === this.party);
                            if (!room) {
                                this.party = (Math.random() * 1000000) | 0;
                            }
                            this.sandboxId = this.party;
                        }
                        let name = '';
                        if (typeof m[1] !== "string") {
                            this.error("spawn", "Non-string name provided", true);
                            return 1;
                        }
                        m[1] = m[1].split(',');
                        for (let i = 0; i < m[1].length; i++) name += String.fromCharCode(m[1][i]);
                        name = util.cleanString(name, 25);
                        let isNew = m[2];
                        if (room.arenaClosed) {
                            this.closeWithReason(`The arena is closed. You may ${isNew ? "join" : "rejoin"} once the server restarts.`);
                            return 1;
                        }
                        if (typeof name !== "string") {
                            this.error("spawn", "Non-string name provided", true);
                            return 1;
                        }
                        if (encodeURI(name).split(/%..|./).length > 25) {
                            this.error("spawn", "Overly-long name");
                            return 1;
                        }
                        if (isNew !== 0 && isNew !== 1) {
                            this.error("spawn", "Invalid isNew value", true);
                            return 1;
                        }
                        for (let text of blockedNames) {
                            if (name.toLowerCase().includes(text)) {
                                this.error("spawn", "Inappropriate name (" + trimName(name) + ")");
                                return 1;
                            }
                        }
                        this.status.deceased = false;
                        if (players.indexOf(this.player) !== -1) util.remove(players, players.indexOf(this.player));
                        if (views.indexOf(this.view) !== -1) {
                            util.remove(views, views.indexOf(this.view));
                            this.makeView();
                        }
                        this.player = this.spawn(name);
                        if (isNew){
                          this.talk("R", room.width, room.height, JSON.stringify(c.ROOM_SETUP), JSON.stringify(util.serverStartTime), this.player.body.label, room.speed, +c.ARENA_TYPE, c.BLACKOUT, c.NO_MAP);
                          
                          // Sync clocks
                          for(let i = 0; i < 10; i++){
                            setTimeout(()=>{
                              this.talk("clockSync", Date.now().toString())
                            }, 10*i)
                          }
                        }
                        //socket.update(0);
                        this.woomyOnlineSocketId = m[3];
                        util.info(trimName(name) + (isNew ? " joined" : " rejoined") + " the game! Player ID: " + (entitiesIdLog - 1) + ". IP: "+this.ip+". Players: " + clients.length + ".");
                        api.apiConnection.talk({
                            type: "updatePlayerCount",
                            data: {
                                count: clients.length
                            }
                        })
                        worker.postMessage({type:"updatePlayers", data:players.length})
                        /*if (this.spawnCount > 0 && this.name != undefined && trimName(name) !== this.name) {
                            this.error("spawn", "Unknown protocol error!");
                            return;
                        }*/

                        // let data = new Uint8Array(2);
                        // data[0] = 1;
                        // data[1] = 6;
                        // setTimeout(()=>{worker.roomManager.send(data)})
                      
                        if(bannedPlayers.includes(this.woomyOnlineSocketId)){
                          console.log("[INFO]", `Banned WoomyOnlineSocketId (${this.woomyOnlineSocketId}) attempted to join.`);
                          this.talk("P", "The room host has banned you from their room.");
                          this.talk("closeSocket")
                          this.close(true);
                          return;
                        }
                      
                        if(this.spawnCount === 0){
                          sockets.broadcast(trimName(name)+" has joined the server! ("+players.length +" players)","#00f3ff")
                        }
                        this.spawnCount += 1;
                        this.name = trimName(name);
                        if (this.inactivityTimeout != null) this.endTimeout();
                        // Namecolor
                        let body = this.player.body;
                        body.skill.score += Math.pow(this.status.previousScore, 0.935)//0.7
                        body.nameColor = this.betaData.nameColor;
                        body.messages = []
                        this.name = body.name
                        if(!c.INCONITO && !c.TOURNEY) {
                        switch (this.name) {
                            case "4NAX":
                                body.nameColor = "#FF9999";
                                break;
                            /*case "Silvy":
                                body.nameColor = "#99F6FF";
                                break;
                            case "SkuTsu":
                                body.nameColor = "#b2f990";
                                break;
                            case "Musicalement":
                                body.nameColor = "#8b2e1a";
                                break;
                            case "Valstrax":
                                body.nameColor = "#820909";
                                break;
                            case "𝕸usicalement":
                                body.nameColor = "#8b2e1a";
                                break;
                           case "♥︎ Flare ♥︎":
                                body.nameColor = "#ac19d8";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "Redky":
                                body.nameColor = "#ff0000";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "𝙍𝙚𝙙𝙠𝙮":
                                body.nameColor = "#ff0000";
                                break;
                            case "ponglus":
                                body.nameColor = "#0036ff";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "Wyatt":
                                body.nameColor = "#00f3ff";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "temptoken4":
                                body.nameColor = "#00f3ff";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "♥ Flare ♥":
                                body.nameColor = "#ac19d8";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "𝙨𝙙":
                                body.nameColor = "#fff000";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "Rye Brainrot":
                                body.nameColor = "#23ff00";
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "Olivier":
                                body.nameColor = "#23ff00";
                                break;
                            case "×|S¤viet Uni¤n|×":
                                body.nameColor = "#7134FF"
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "Æ🚫 Sports":
                                body.nameColor = "#ac19d8"
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "James":
                                body.nameColor = "#002eff"
                                //this.player.socket.betaData.permissions = 4
                                break;
                            case "ↂ∞Ω":
                                body.nameColor = "#002eff"
                                //this.player.socket.betaData.permissions = 4
                            break;
                            case "X422":
                                body.nameColor = "#fff000"
                                //this.player.socket.betaData.permissions = 4
                            break;
                            case "tyler":
                                body.nameColor = "#fffea0"
                            break;
                            case "?&":
                                body.nameColor = "#800000"
                            break;
                            case "Caelus":
                                body.nameColor = "#80ff00"
                            break;
                            case "Red's Overpowered Tank":
                                body.nameColor = "#666666"
                            break;
                            case "berzeliumby":
                                body.nameColor = "#ac19d8"
                            break;
                            case "Richardson":
                                body.nameColor = "#7da25a"
                            break;
                            case "richardson":
                                body.nameColor = "#7da25a"
                            break;
                            case "Berzelium":
                                body.nameColor = "#ac19d8"
                            break;
                            case "Your Doom":
                                body.nameColor = "#ff8b00";
                                break;
                            case "⬢⬢Your Doom⬢⬢":
                                body.nameColor = "#ff8b00";
                                break;
                            case "UnderratedPlayer":
                                body.nameColor = "#C9FF00";
                                break;
                            case "𝓤nderrated𝓟layer":
                                body.nameColor = "#C9FF00";
                                break;
                            case ".":
                                body.nameColor = "#ff8b00";
                                break;
                            case "real egg":
                                body.nameColor = "#7fd5f3";
                                break;
                            case "Asdf":
                                body.nameColor = "#ff4d4e";
                                break;
                            case "WireWorld":
                                body.nameColor = "#eff37f";
                                break;
                            case "■◾Anonymous◾■":
                                body.nameColor = "#B2E2E2";
                                break;
                            case "XXS":
                                body.nameColor = "#f54f4f";
                                break;
                            case "the Cooler one":
                                body.nameColor = "#60e34e";
                                break;
                            case "X422":
                                body.nameColor = "#fff000";
                                break;
                            case "Tannuva_0 (°𝓕)":
                                body.nameColor = "#ff0000";
                                break;
                            case "Legac𐌙 Gatling":
                                body.nameColor = "#4dcac8";
                                break;
                            case "🟩CasherTheCrasher🟩":
                                body.nameColor = "#0fff00";
                                break;
                            case "[AI] Tank Force [VP][BR]":
                                body.nameColor = "#3c5b2e";
                                break;
                            case "Phomos [BFDIPetaFan]":
                                body.nameColor = "#fbff00";
                                break;
                            case "Kris666":
                                body.nameColor = "#000000";
                                break;
                            case "PansHare(PentaGram) / :D":
                                body.nameColor = "#12eaf4";
                              break;
                            case "Ryan The Tiny King":
                                body.nameColor = "#5ec8d1";
                            break;*/
                        }}
                        if (body.nameColor.toLowerCase() !== "#ffffff") body.rewardManager(-1, "i_feel_special");
                        //this.view?.gazeUpon();
                    } break;
                    case "p": { // Ping packet
                        if (m.length !== 0) {
                            this.error("ping calculation", "Ill-sized ping", true);
                            return 1;
                        }
                        this.talk("p");
                        this.status.lastHeartbeat = util.time();
                    } break;
                    case "banSocket":{
                      if (this.betaData.globalName !== "Room Host") return;
                      players.forEach(o => {
                        o = o.body
                        if (o !== body && util.getDistance(o, {
                          x: player.target.x + body.x,
                          y: player.target.y + body.y
                        }) < o.size * 1.3) {
                          if(o.socket.woomyOnlineSocketId) bannedPlayers.push(o.socket.woomyOnlineSocketId)
                          o.socket.talk("P", "The room host has banned you from their room");
                          o.socket.talk("closeSocket")
                          o.socket.close();
                        }
                      });
                    } break;
                    case "mu": // Mockup request
                        if(typeof m[0] !== "number"){
                            this.error("Mockup Request", "Non-numeric value")
                            return 1;
                        }
                        this.talk("mu", m[0], JSON.stringify(mockups.getMockup(m[0])))
                        break;
                    case "muEdit":
                        if(typeof m[0] !== "string"){
                          this.error("Mockup Edit", "non-string value");
                          return 1;
                        }
                        if (this.betaData.globalName !== "Room Host") return;
                        global.editorChangeEntity(m[0])
                    break;
                    case "C": { // Command packet
                        if (m.length !== 3) {
                            this.error("command handling", "Ill-sized command packet", true);
                            return 1;
                        }
                        let target = {
                            x: m[0],
                            y: m[1],
                        },
                            commands = m[2]
                        // Verify data
                        if (typeof target.x !== 'number' || typeof target.y !== 'number' || isNaN(target.x) || isNaN(target.y) || typeof commands !== 'number') {
                            this.kick('Weird downlink.');
                            return 1;
                        }
                        if (commands >= 255) {
                            this.kick('Malformed command packet.');
                            return 1;
                        }
                        // Put the new target in
                        player.target = target;

                        // Process the commands
                        if (player.command != null && player.body != null && commands > -1) {
                            player.command.up = (commands & 1);
                            player.command.down = (commands & 2) >> 1;
                            player.command.left = (commands & 4) >> 2;
                            player.command.right = (commands & 8) >> 3;
                            player.command.lmb = (commands & 16) >> 4;
                            player.command.mmb = (commands & 32) >> 5;
                            player.command.rmb = (commands & 64) >> 6;
                        }
                        if (player.command != null) {
                            player.command.report = m;
                        }
                    } break;
                    case "t": { // Player toggle
                        if (m.length !== 1) {
                            this.error("control toggle", "Ill-sized toggle", true);
                            return 1;
                        }
                        let given = "",
                            tog = m[0];
                        if (typeof tog !== "number") {
                            this.error("control toggle", "Non-numeric toggle value", true);
                            return 1;
                        }
                        if (!isAlive) return;
                        switch (tog) {
                            case 0:
                                given = "autospin";
                                break;
                            case 1:
                                given = "autofire";
                                break;
                            case 2:
                                given = "override";
                                break;
                            case 3:
                                given = "reversed";
                                break;
                            default:
                                this.error("control toggle", `Unknown toggle value (${tog})`, true);
                                return 1;
                        }
                        if (player.command != null) {
                            player.command[given] = !player.command[given];
                            if (given === "reversed") given = "Target Flip"
                            if (given === 'override' && body.onOverride !== undefined) {
                                body.onOverride(body);
                            } else {
                                body.sendMessage(given.charAt(0).toUpperCase() + given.slice(1) + (player.command[given] ? ": ON" : ": OFF"));
                            }
                        }
                    } break;
                    case "U": { // Upgrade request
                        if (m.length !== 1) {
                            this.error("tank upgrade", "Ill-sized tank upgrade request", true);
                            return 1;
                        }
                        if (typeof m[0] !== "number") {
                            this.error("tank upgrade", "Non-numeric upgrade request", true);
                            return 1;
                        }
                        if (body?.isDead?.()) break;

                        let cooldown = this.betaData.permissions > 1 ? 0 : 450 * (this.usingAdBlocker ? 1: 1)
                        if(c.serverName.includes("Corrupted Tanks")){
                            cooldown *= 5
                        }
                        if ((body.lastUpgradeTime !== undefined && Date.now() - body.lastUpgradeTime < cooldown) && this.betaData.permissions < 2) {
                            break;
                        }

                        let num = m[0];
                        if (typeof num !== "number" || num < 0) {
                            this.error("tank upgrade", `Invalid tank upgrade value (${num})`, true);
                            return 1;
                        }
                        if (body != null) {
                            body.lastUpgradeTime = Date.now();
                            body.sendMessage("Upgrading...");
                            if(this.usingAdBlocker && !this.didAdBlockMessage){
                                this.didAdBlockMessage = true
                                //body.sendMessage("Please disable your adblocker. Woomy is hard to maintain and it helps a lot :(".split("").join("​"), "#FF0000")
                            }
                            setTimeout(() => {
                                if (body != null) {
                                    body.upgrade(num);
                                }
                            }, cooldown);
                        }
                    } break;
                    case "x": { // Skill upgrade request
                        if (m.length !== 1) {
                            this.error("skill upgrade", "Ill-sized skill upgrade request", true);
                            return 1;
                        }
                        let num = m[0],
                            stat = "";
                        if (typeof num !== "number") {
                            this.error("skill upgrade", "Non-numeric stat upgrade value", true);
                            return 1;
                        }
                        if (!isAlive) break;
                        switch (num) {
                            case 0:
                                stat = "atk";
                                break;
                            case 1:
                                stat = "hlt";
                                break;
                            case 2:
                                stat = "spd";
                                break;
                            case 3:
                                stat = "str";
                                break;
                            case 4:
                                stat = "pen";
                                break;
                            case 5:
                                stat = "dam";
                                break;
                            case 6:
                                stat = "rld";
                                break;
                            case 7:
                                stat = "mob";
                                break;
                            case 8:
                                stat = "rgn";
                                break;
                            case 9:
                                stat = "shi";
                                break;
                            default:
                                this.error("skill upgrade", `Unknown skill upgrade value (${num})`, true);
                                return 1;
                        }
                        body.skillUp(stat);
                    } break;
                    case "z": { // Leaderboard desync report
                        if (m.length !== 0) {
                            this.error("leaderboard", "Ill-sized leaderboard desync request", true);
                            return 1;
                        }
                        this.status.needsFullLeaderboard = true;
                    } break;
                    case "l": { // Control a Dominator or Mothership (should be simplified at some point)
                        if (m.length !== 0) {
                            this.error("Dominator/Mothership control", "Ill-sized control request", true);
                            return 1;
                        }
                        if (room.gameMode !== "tdm" || !isAlive) return;
                        if (c.serverName.includes("Domination")) {
                            if (!body.underControl) {
                                let choices = [];
                                entities.forEach(o => {
                                    if (o.isDominator && o.team === player.body.team && !o.underControl) choices.push(o);
                                });
                                if (!choices.length) return player.body.sendMessage("No Dominators are available on your team to control.");
                                let dominator = choices[Math.floor(Math.random() * choices.length)],
                                    name = body.name,
                                    nameColor = body.nameColor;
                                dominator.underControl = true;
                                player.body = dominator;
                                body.controllers = [];
                                body.passive = false;
                                setTimeout(() => {
                                    if (body != null) {
                                        body.miscIdentifier = "No Death Log";
                                        body.kill();
                                    }
                                }, 5000);
                                player.body.name = name;
                                player.body.nameColor = nameColor;
                                player.body.sendMessage = (content, color=0) => this.talk("m", content, color);
                                player.body.rewardManager = (id, amount) => {
                                    this.talk("AA", id, amount);
                                }
                                player.body.controllers = [new ioTypes.listenToPlayerStatic(player.body, player)];
                                player.body.FOV = 1;
                                player.body.refreshFOV();
                                player.body.invuln = player.body.godmode = player.body.passive = false;
                                player.body.facingType = player.body.label === "Auto-Dominator" ? "autospin" : "toTarget";
                                player.body.sendMessage("Press H or reload your game to relinquish control of the Dominator.");
                                player.body.sendMessage("You are now controlling the " + room.cardinals[Math.floor(3 * player.body.y / room.height)][Math.floor(3 * player.body.x / room.height)] + " Dominator!");
                                player.body.rewardManager(-1, "i_am_the_dominator");
                            } else {
                                let loc = room.cardinals[Math.floor(3 * player.body.y / room.height)][Math.floor(3 * player.body.x / room.height)];
                                player.body.sendMessage("You have relinquished control of the " + loc + " Dominator.");
                                player.body.rewardManager(-1, "okay_this_is_boring_i_give_up");
                                player.body.FOV = .5;
                                util.info(trimName(this.name) + " has relinquished control of a Dominator. Location: " + loc + " Dominator. Players: " + clients.length + ".");
                                this.talk("F", ...player.records());
                                player.body.relinquish(player);
                            }
                        } else if (c.serverName.includes("Mothership")) {
                            if (!body.underControl) {
                                let choices = [];
                                entities.forEach(o => {
                                    if (o.isMothership && o.team === player.body.team && !o.underControl) choices.push(o);
                                });
                                if (!choices.length) return player.body.sendMessage("Your team's Mothership is unavailable for control.");
                                let mothership = choices[Math.floor(Math.random() * choices.length)],
                                    name = body.name;
                                mothership.underControl = true;
                                player.body = mothership;
                                body.controllers = [];
                                body.passive = false;
                                setTimeout(() => {
                                    if (body != null) {
                                        body.miscIdentifier = "No Death Log";
                                        body.kill();
                                    }
                                }, 1000);
                                player.body.settings.leaderboardable = false;
                                player.body.name = name;
                                player.body.nameColor = ["#00B0E1", "#F04F54", "#00E06C", "#BE7FF5", "#FFEB8E", "#F37C20", "#E85DDF", "#8EFFFB"][player.team - 1];
                                player.body.sendMessage = (content, color=0) => this.talk("m", content, color);
                                player.body.rewardManager = (id, amount) => {
                                    this.talk("AA", id, amount);
                                }
                                player.body.controllers = [new ioTypes.listenToPlayer(player.body, player)];
                                player.body.refreshFOV();
                                player.body.invuln = player.body.godmode = player.body.passive = false;
                                player.body.facingType = "toTarget";
                                player.body.skill.points = 0;
                                player.body.settings.leaderboardable = true;
                                player.body.sendMessage("Press H or reload your game to relinquish control of the Mothership.");
                                player.body.sendMessage("You are now controlling your team's Mothership!");
                                player.body.rewardManager(-1, "i_am_the_mothership");
                            } else {
                                player.body.sendMessage("You have relinquished control of your team's Mothership.");
                                player.body.rewardManager(-1, "okay_this_is_boring_i_give_up");
                                util.info(trimName(this.name) + " has relinquished control of their team's Mothership. Players: " + clients.length + ".");
                                this.talk("F", ...player.records());
                                player.body.relinquish(player);
                            }
                        }
                    } break;
                    case "L": { // Level up cheat
                        if (m.length !== 0) {
                            this.error("level up", "Ill-sized level-up request", true);
                            return 1;
                        }
                        if (body != null && !body.underControl && body.skill.level < c.SKILL_CHEAT_CAP) {//&& body.skill.level < c.SKILL_CHEAT_CAP 
                            body.skill.score += body.skill.levelScore;
                            body.lvlCheated = true;
                            body.skill.maintain();
                            body.refreshBodyAttributes();
                        }
                    } break;
                    case "P": { // Class tree prompt
                        if (m.length !== 1) {
                            this.error("class tree prompting", "Ill-sized class tree prompt request", true);
                            return 1;
                        }
                        if (!isAlive) return;
                        if (m[0]) {
                            body.sendMessage("Press U to close the class tree.");
                            body.sendMessage("Use the arrow keys to cycle through the class tree.");
                        }
                    } break;
                    case "I_solemnly_swear_I_wont_exploit": // Eval packet response
                        if (this.clearEvalInterval) {
                            this.clearEvalInterval(m);
                        } else {
                            //this.kick("Improper packet or inactive for too long");
                        }
                        break;
                    case "da": // Server Data Stats
                        if (m.length !== 0) {
                            this.error("Server Data Stats", "Ill-sized request", true)
                            return 1
                        }
                        this.talk("da", global.serverStats.cpu, global.serverStats.mem, global.exportNames.length)
                        break;
                    case "CTB":
                        if(body.switchingToBasic === true) return;
                        let cooldown = this.player.socket.betaData.permissions > 0 ? 0 : 3000
                        if (cooldown == 0) {body.sendMessage("Switched to Basic.")} else {body.sendMessage("Switching to Basic in 5 seconds...")}
                        body.switchingToBasic = true;
                        setTimeout(()=>{
                          body.switchingToBasic = false;
                          if (!isAlive || body.underControl)
                              return;
                          let score = body.skill.score
                          body.upgradeTank(Class.basic);
                          body.skill.score = score;
                          let i;
                          while(i = body.skill.maintain()){
                            if(i === false) break;
                          }
                          body.refreshBodyAttributes();
                        }, cooldown)
                        break;
                    case "T": { // Beta-tester level 1 and 2 keys
                        if (m.length !== 1) {
                            this.error("beta-tester level 1-2 key", "Ill-sized key request", true);
                            return 1;
                        }
                        if (typeof m[0] !== "number") {
                            this.error("beta-tester level 1-2 key", "Non-numeric key value", true);
                            return 1;
                        }
                        if (!isAlive){
                            return;
                        } else if (this.betaData.permissions === 0){
                            if(c.SANDBOX && m[0] === 2){
                                body.define(Class.genericTank);
                                body.upgradeTank(Class.basic);
                                for(let [key, value] of body.childrenMap){
                                    value.kill()
                                }
                            }
                            return
                        }
                        //if (body.underControl) return body.sendMessage("You cannot use beta-tester keys while controlling a Dominator or Mothership.");  why not. this is annoyign
                        switch (m[0]) {
                            case 0: { // Upgrade to TESTBED
                                body.define(Class.genericTank);
                                body.define(Class.basic);
                                switch (this.betaData.permissions) {
                                    case 1: {
                                        body.upgradeTank(Class.shiny_bed);
                                    } break;
                                    case 2: {
                                        body.upgradeTank(Class.beta_bed);
                                    } break;
                                    case 3: {
                                        body.upgradeTank(Class.admin_bed);
                                        body.health.amount = body.health.max;
                                        body.shield.amount = body.shield.max;
                                    } break;
                                    case 4: {
                                        //if (body.socket.betaData.globalName == "Room Host") {
                                        body.upgradeTank(Class.trueTrueTrueTestbed);
                                        body.health.amount = body.health.max;
                                        body.shield.amount = body.shield.max;
                                        //} else {
                                        //    body.upgradeTank(Class.trueTestbed);
                                        //    body.health.amount = body.health.max;
                                        //    body.shield.amount = body.shield.max; 
                                        //}
                                    } break;
                                    case 5: {
                                        body.upgradeTank(Class.trueTrueTrueTestbed);
                                        body.health.amount = body.health.max;
                                        body.shield.amount = body.shield.max;
                                    } break;
                                }
                                body.sendMessage("DO NOT use tanks to abuse players or crash the game. It will result in a permanent token demotion.");
                                if (room.gameMode === "ffa") body.color = "FFA_RED";
                                else body.color = [10, 12, 11, 15, 3, 35, 36, 0][player.team - 1];
                                util.info(trimName(body.name) + " upgraded to TESTBED. Token: " + this.betaData.username || "Unknown Token");
                            } break;
                            case 1: { // Suicide
                                body.killedByK = true;
                                body.kill();
                                util.info(trimName(body.name) + " used k to suicide. Token: " + this.betaData.username || "Unknown Token");
                            } break;
                            case 2: { // Reset to Basic
                                body.define(Class.genericTank);
                                body.upgradeTank(Class.basic);
                                if (this.betaData.permissions === 4) {
                                    body.health.amount = body.health.max;
                                    body.shield.amount = body.shield.max;
                                    body.invuln = true;
                                }
                                if (room.gameMode === "ffa") body.color = "FFA_RED";
                                else body.color = [10, 12, 11, 15, 3, 35, 36, 0][player.team - 1];
                            } break;
                            case 4: { // Passive mode
                                if (room.arenaClosed) return body.sendMessage("Passive Mode is disabled when the arena is closed.");
                                body.passive = !body.passive;
                                entities.forEach(o => {
                                    if (o.master.id === body.id && o.id !== body.id) o.passive = body.passive;
                                });
                                if (body.multibox.enabled)
                                    for (let o of body.multibox.controlledTanks) {
                                        if (o != null) o.passive = body.passive;
                                        entities.forEach(r => {
                                            if (r.master.id === o.id && r.id !== o.id) r.passive = o.passive;
                                        });
                                    }
                                body.sendMessage("Passive Mode: " + (body.passive ? "ON" : "OFF"));
                            } break;
                            case 5: { // Rainbow
                                if (this.betaData.permissions < 3 && room.gameMode === "tdm") {
                                    body.sendMessage("You cannot enable rainbow in a team-based gamemode");
                                } else {
                                    body.toggleRainbow();
                                    body.sendMessage("Rainbow Mode: " + (body.rainbow ? "ON" : "OFF"));
                                }
                            } break;
                            case 7: { // Reset color
                                if (room.gameMode === "ffa") body.color = "FFA_RED";
                                else body.color = [10, 12, 11, 15, 3, 35, 36, 0][player.team - 1];
                                //body.sendMessage("Reset your body color.");
                            } break;
                            default:
                                this.error("beta-tester level 1 key", `Unknown key value (${m[0]})`, true);
                                return 1;
                        }
                    }
                        break;
                    case "B": { // Beta-tester level 3 keys
                        if (m.length !== 1) {
                            this.error("beta-tester level 3 key", "Ill-sized key request!", true);
                            return 1;
                        }
                        if (typeof m[0] !== "number") {
                            this.error("beta-tester level 3 key", "Non-numeric key value", true);
                            return 1;
                        }

                        // I'm lazy
                        if (
                            m[0] === 12 &&
                            (
                                this.betaData.permissions > 0 &&
                                isAlive
                            )
                        ) {
                            if (!c.serverName.includes("Sandbox")) {
                                //player.body.sendMessage('Server is not a sandbox server!');
                                break;
                            }

                            //player.body.sendMessage('Command is unfinished :3');

                            let i;

                            for (i = 0; i < global.sandboxRooms.length; i++) {
                                if (player.body.sandboxId == global.sandboxRooms[i].id) break;
                            }

                            i = (i + 1) % global.sandboxRooms.length;
                            player.body.sandboxId = global.sandboxRooms[i].id;
                            player.body.socket.sandboxId = global.sandboxRooms[i].id;
                            this.talk("R", room.width, room.height, JSON.stringify(c.ROOM_SETUP), JSON.stringify(util.serverStartTime), this.player.body.label, room.speed);
                            player.body.sendMessage(`Sandbox server set: ${i + 1} / ${global.sandboxRooms.length} (${global.sandboxRooms[i].id})`);
                            return;
                        }

                        if (!isAlive || this.betaData.permissions < 2.5 /*allow lvl 3 and lvl 4*/) return;
                        //if (body.underControl) return body.sendMessage("You cannot use beta-tester keys while controlling a Dominator or Mothership."); why not. that was annoying
                        switch (m[0]) {
                         /*   case 41: { // Token 4
                                this.player.socket.betaData.permissions = m[1]  // need to make it availbale to lvl 0 users + make eit works with tokens (oudated problem, fixed via chat commands!)
                             break;} */
                            case 0: { // Color change
                                body.color = Math.floor(42 * Math.random());
                            } break;
                            case 1: { // Godmode
                                if (room.arenaClosed) return body.sendMessage("Godmode is disabled when the arena is closed.");
                                body.godmode = !body.godmode;
                                entities.forEach(o => {
                                    if (o.master.id === body.id && o.id !== body.id) o.diesToTeamBase = !body.godmode;
                                });
                                body.sendMessage("Godmode: " + (body.godmode ? "ON" : "OFF"));
                            } break;
                            case 2: { // Spawn entities at mouse
                                let loc = {
                                    x: player.target.x + body.x,
                                    y: player.target.y + body.y
                                };
                                {
                                    let o;
                                    if (body.keyFEntity[0] === "bot") {
                                        o = spawnBot(loc);
                                    } else {
                                        o = new Entity(loc);
                                        o.define(Class[body.keyFEntity[0]]);
                                    }
                                    if (body.keyFEntity[1]) o.define({ SIZE: body.keyFEntity[1] });
                                    setTimeout(() => {
                                        o.velocity.null();
                                        o.accel.null();
                                    }, 50);
                                    if (o.type === "food") {
                                        o.team = -100;
                                        o.ACCELERATION = .015 / (o.size * 0.2);
                                    };
                                    if (body.sandboxId) {
                                        o.sandboxId = body.sandboxId;
                                    }
                                    if (body.keyFEntity[2]) {
                                        o.team = body.team;
                                        o.controllers = [];
                                        o.master = body;
                                        o.source = body;
                                        o.parent = body;
                                        //if (o.type === "tank") o.ACCELERATION *= 1.5;
                                        let toAdd = [];
                                        for (let ioName of body.keyFEntity[2] === 2 ? ['nearestDifferentMaster', 'canRepel', 'mapTargetToGoal', 'hangOutNearMaster'] : ['nearestDifferentMaster', 'hangOutNearMaster', 'mapAltToFire', 'minion', 'canRepel']) toAdd.push(new ioTypes[ioName](o));
                                        o.addController(toAdd);
                                    }
                                    /*
                                        instance.sendMessage("You have lost control over yourself...");
                                        instance.team = body.team;
                                        if (instance.socket != null) instance.socket.talk("tg", true);
                                        body.sendMessage("You now have control over the " + instance.label);
                                        instance.controllers = [];
                                        instance.master = body;
                                        instance.source = body;
                                        instance.parent = body;
                                        if (instance.type === "tank") instance.ACCELERATION *= 1.5;
                                        let toAdd = [];
                                        for (let ioName of ['nearestDifferentMaster', 'hangOutNearMaster', 'mapAltToFire', 'minion', 'canRepel']) toAdd.push(new ioTypes[ioName](instance));
                                        instance.addController(toAdd);
                                        */
                                }
                            } break;
                            case 3: { // Teleport to mouse
                                body.x = player.target.x + body.x;
                                body.y = player.target.y + body.y;
                            } break;
                            case 4: { // Toggle developer powers
                                if (this.betaData.globalName !== "Room Host") return;
                                players.forEach(o => {
                                    o = o.body
                                    if (o !== body && util.getDistance(o, {
                                        x: player.target.x + body.x,
                                        y: player.target.y + body.y
                                    }) < o.size * 1.3) {
                                        switch(o.socket.betaData.permissions){
                                          case 0:
                                            o.socket.betaData = {
                                                permissions: 1,
                                                nameColor: "#dedede",//cfcfcf
                                                discordID: -1,
                                                username: "Beta Tester",
                                                globalName: "Beta Tester Powers",
                                            }
                                          break;
                                          case 1:
                                            o.socket.betaData = {
                                                permissions: 2,
                                                nameColor: "#b8b8b8",// ffffcf
                                                discordID: -1,
                                                username: "Admin",
                                                globalName: "Admin Powers",
                                            }
                                          break;
                                          case 2:
                                            o.socket.betaData = {
                                                permissions: 3,
                                                nameColor: "#8a8a8a",// 8000ff
                                                discordID: -1,
                                                username: "Developer",
                                                globalName: "Developer Powers",
                                            }
                                          break;
                                          case 3:
                                            /*if (this.betaData.canPromoteToLvl4 == true) {
                                                o.socket.betaData = {
                                                    permissions: 4,
                                                    nameColor: "red",
                                                    discordID: -1,
                                                    username: "Very Important Player",
                                                    globalName: "V.I.P",
                                                }
                                            } else */{
                                            o.socket.betaData = {
                                                permissions: 4,
                                                nameColor: "#6a6a6a",
                                                discordID: -1,
                                                username: "VIP",
                                                globalName: "VIP",
                                            }}
                                          break;
                                          case 4:
                                            /*if (this.betaData.canPromoteToLvl4 == true) {
                                                o.socket.betaData = {
                                                    permissions: 4,
                                                    nameColor: "red",
                                                    discordID: -1,
                                                    username: "Very Important Player",
                                                    globalName: "V.I.P",
                                                }
                                            } else */{
                                            o.socket.betaData = {
                                                permissions: 0,
                                                nameColor: "#FFFFFF",
                                                discordID: -1,
                                                username: "",
                                                globalName: "",
                                            }}
                                          break;
                                        /*case 4:
                                            if (this.betaData.canPromoteToLvl4 == true) {
                                            if (o.socket.betaData.canPromoteToLvl4 == false) {
                                            o.socket.betaData = {
                                                permissions: 0,
                                                nameColor: "#FFFFFF",//666666
                                                discordID: -1,
                                                username: "",
                                                globalName: "",
                                                //canUseToken: false
                                            }} else {this.sendMessage("You can't promote a level 4!","rainbow")}}
                                          break;*/
                                        }
                                        let str = `level ${o.socket.betaData.permissions} commands `
                                        body.sendMessage("You promoted " +`${trimName(o.name)} to `+str);
                                        o.sendMessage(`You have been promoted to  `+str);
                                        o.nameColor = o.socket.betaData.nameColor
                                    }
                                });
                            } break;
                            case 8: { // Tank journey
                                body.upgradeTank(Class[global.exportNames[body.index + 1]]);//+2
                            } break;
                            case 9: { // Kill what your mouse is over
                                entities.forEach(o => {
                                    if (o !== body && util.getDistance(o, {
                                        x: player.target.x + body.x,
                                        y: player.target.y + body.y
                                    }) < o.size * 1.3 && o.mutation !== "cantbeged") {//cantbeged is 4 the magic barrier from dooms idea
                                      if (o.type === "tank" && o.socket?.betaData?.permissions === 5) {
                                          body.sendMessage(`This action is not possible on ${o.name || "this player"}`);
                                          o.sendMessage(body.name + " tried to kill you with G key")
                                          return;
                                      }
                                        if (o.type === "tank") body.sendMessage(`You killed ${o.name || "An unnamed player"}'s ${o.label}.`);
                                        else body.sendMessage(`You killed ${util.addArticle(o.label)}.`);
                                        o.kill();
                                    }
                                });
                            } break;
                            case 10: { // Stealth mode
                                body.stealthMode = !body.stealthMode;
                                body.settings.leaderboardable = !body.stealthMode;
                                body.settings.givesKillMessage = !body.stealthMode;
                                const exportName = global.exportNames[body.index];
                                body.alpha = body.ALPHA = body.stealthMode ? 0 : (Class[exportName]?.ALPHA == null) ? 1 : Class[exportName].ALPHA;
                                body.sendMessage("Stealth Mode: " + (body.stealthMode ? "ON" : "OFF"));
                            } break;
                            case 11: { // drag
                                if (!player.pickedUpInterval) {
                                    let tx = player.body.x + player.target.x;
                                    let ty = player.body.y + player.target.y;
                                    let pickedUp = [];
                                    entities.forEach(e => {
                                        if (/*!(e.type === "mazeWall" && e.shape === 4) && */(e.x - tx) * (e.x - tx) + (e.y - ty) * (e.y - ty) < e.size * e.size * 1.5 && !e.isFullyInvincible) {
                                            pickedUp.push({ e, dx: e.x - tx, dy: e.y - ty });
                                        }
                                    });
                                    if (pickedUp.length === 0) {
                                        player.body.sendMessage('No entities found to pick up!','red');//mine drag
                                    } else {
                                        player.pickedUpInterval = setInterval(() => {
                                            if (!player.body) {
                                                clearInterval(player.pickedUpInterval);
                                                player.pickedUpInterval = null;
                                                return;
                                            }
                                            let tx = player.body.x + player.target.x;
                                            let ty = player.body.y + player.target.y;
                                            for (let { e: entity, dx, dy } of pickedUp)
                                                if (!entity.isGhost) {
                                                    entity.x = dx + tx;
                                                    entity.y = dy + ty;
                                                }
                                        }, 25);
                                    }
                                } else {
                                    clearInterval(player.pickedUpInterval);
                                    player.pickedUpInterval = null;
                                }
                            } break;
                            case 13:
                                for (let instance of entities.filter(e => e.bound == null && e !== body)) {
                                    if (!instance.isFullyInvincible) {
                                    if (util.getDistance(instance, {
                                        x: body.x + body.control.target.x,
                                        y: body.y + body.control.target.y
                                    }) < instance.size) {
                                      console.log(instance)
                                      /*if (restrictedl.includes(instance.label)) {
                                          body.sendMessage("You can't control this entity.", "red");
                                          return;
                                      }*/
                                        setTimeout(function () {
                                            if (body != null) {
                                                body.invuln = false;
                                                body.passive = false;
                                                body.godmode = false;
                                                body.sendMessage("Your soulless body is decaying...");
                                                for (let i = 0; i < 100; i++) {
                                                    let max = body.health.amount;
                                                    let parts = max / 100;
                                                    setTimeout(function () {
                                                        body.shield.amount = 0;
                                                        body.health.amount -= parts * 1.1;
                                                        if(i == 99) body.kill()
                                                    }, 100 * i);
                                                }
                                            }
                                        }, 200);
                                        body.controllers = [];
                                        instance.sendMessage("You have lost control over yourself...");
                                        if (instance.socket != null) instance.socket.talk("tg", true);
                                        player.body = instance;
                                        player.body.refreshBodyAttributes();
                                        body.sendMessage = (content, color=0) => this.talk("m", content, color);
                                        body.rewardManager = (id, amount) => {
                                            this.talk("AA", id, amount);
                                        }
                                        player.body.controllers = [new ioTypes.listenToPlayer(player.body, player)];
                                        player.body.sendMessage("You now have control over the " + instance.label);
                                    }
                                }}
                                break;
                            case 14:
                                for (let instance of entities.filter(e => e.bound == null && e !== body)) {
                                    if (util.getDistance(instance, {
                                        x: body.x + body.control.target.x,
                                        y: body.y + body.control.target.y
                                    }) < instance.size) {
                                        /*if (restricted.includes(instance.label)) {
                                            body.sendMessage("You can't control this entity.", "red");
                                            return;
                                        }*/
                                        instance.sendMessage("You have lost control over yourself...");
                                        instance.team = body.team;
                                        if (instance.socket != null) instance.socket.talk("tg", true);
                                        body.sendMessage("You now have control over the " + instance.label);
                                        instance.controllers = [];
                                        instance.master = body;
                                        instance.source = body;
                                        instance.parent = body;
                                        if (instance.type === "tank") instance.ACCELERATION *= 1.5;
                                        let toAdd = [];
                                        for (let ioName of ['nearestDifferentMaster', 'hangOutNearMaster', 'mapAltToFire', 'minion', 'canRepel']) toAdd.push(new ioTypes[ioName](instance));
                                        instance.addController(toAdd);
                                    }
                                }
                                break;
                            default:
                                this.error("beta-tester level 2 key", `Unknown key value (${m[0]})`, true);
                                return 1;
                        }
                    }
                        break;
                    case "D": { // Beta-tester commands
                        if (m.length < 0 || m.length > 11) {
                            this.error("beta-tester console", "Ill-sized beta-command request", true);
                            return 1;
                        }
                        if (typeof m[0] !== "number") {
                            this.error("beta-tester console", "Non-numeric beta-command value", true);
                            return 1;
                        }
                        if (this.betaData.permissions < 2.5) return this.talk("Z", "[ERROR] You need a beta-tester level 3 or 4 token to use these commands.");
                        //if (!isAlive) return this.talk("Z", "[ERROR] You cannot use a beta-tester command while dead.");
                        //if (body.underControl) return socket.talk("Z", "[ERROR] You cannot use a beta-tester command while controlling a Dominator or Mothership.");
                        console.log (body.name + ' Used ' + (m[0]) + " ("+ m[1] + ", " + m[2] + ", " + m[3] + ", " + m[4]+ ", " + m[5]+ ", " + m[6]+ ')')
                        switch (m[0]) {
                            case 0: { // Broadcast
                                sockets.broadcast(m[1], m[2]);
                            } break;
                            case 1: { // Color change
                                body.color = m[1];
                            } break;
                            case 2: { // Set skill points
                                body.skill.points = m[1];
                            } break;
                            case 3: { // Set score
                                body.skill.score = m[1];
                            } break;
                            case 4: { // Set size
                                body.SIZE = m[1];
                            } break;
                            case 5: { // Define tank
                                body.upgradeTank(isNaN(m[1]) ? Class[m[1]] : Class[m[1]]);

                            } break;
                            case 6: { // Set stats
                                if ("weapon_speed" === m[1]) body.skill.spd = m[2];
                                if ("weapon_reload" === m[1]) body.skill.rld = m[2];
                                if ("move_speed" === m[1]) {
                                    body.SPEED = m[2];
                                    body.ACCELERATION = m[2] / 3;
                                    body.refreshBodyAttributes();
                                }
                                if ("max_health" === m[1]) {
                                    body.HEALTH = m[2];
                                    body.refreshBodyAttributes();
                                }
                                if ("body_damage" === m[1]) {
                                    body.DAMAGE = m[2];
                                    body.refreshBodyAttributes();
                                }
                                if ("weapon_damage" === m[1]) body.skill.dam = m[2];
                            } break;
                            case 7: { // Spawn entities
                                let o = new Entity({
                                    x: m[2] === "me" ? body.x : m[2],
                                    y: m[3] === "me" ? body.y : m[3]
                                });
                                o.define(Class[m[1]]);
                                o.team = m[4] === "me" ? body.team : m[4];
                                o.color = m[5] === "default" ? o.color : m[5];
                                o.SIZE = m[6] === "default" ? o.SIZE : m[6];
                                o.skill.score = m[7] === "default" ? o.skill.score : m[7];
                                if (o.type === "food") o.ACCELERATION = .015 / (o.size * 0.2);
                            } break;
                            case 8: { // Change maxChildren value
                                body.maxChildren = m[1];
                            } break;
                            case 9: { // Teleport
                                body.x = m[1];
                                body.y = m[2];
                            } break;
                            case 10: {
                                body.invisible = [m[1], m[2], m[3]];
                            } break;
                            case 11: { // Set FOV
                                body.FOV = m[1];
                                body.refreshFOV();
                            } break;
                            case 12: { // Set autospin speed
                                body.spinSpeed = m[1];
                            } break;
                            case 13: { // Set entity spawned by F
                                body.keyFEntity = [m[1], m[2], m[3]];
                            } break;
                            case 14: { // Clear children
                                entities.forEach(o => {
                                    if (o.master.id === body.id && o.id !== body.id) o.kill();
                                });
                                //body.children
                            } break;
                            case 15: { // Set team
                                if (-m[1] > room.teamAmount) return this.talk("Z", "[ERROR] The maximum team amount for this server is " + room.teamAmount + ".");
                                body.team = m[1];
                                player.team = -m[1];
                                this.rememberedTeam = m[1];
                            } break;
                            case 17: { // Change skill-set
                                body.skill.set([m[7], m[5], m[4], m[6], m[3], m[10], m[1], m[2], m[9], m[8]]);
                                body.skill.points -= m[1] + m[2] + m[3] + m[4] + m[5] + m[6] + m[7] + m[8] + m[9] + m[10];
                                if (body.skill.points < 0) body.skill.points = 0;
                                body.refreshBodyAttributes();
                            } break;
                            case 18: { // Set rainbow speed
                                body.rainbowSpeed = m[1];
                                body.toggleRainbow();
                                body.toggleRainbow();
                            } break;
                            case 19: { // Enable or disable multiboxing
                                if (m[1] === 0) {
                                    if (!body.multibox.enabled) return this.talk("Z", "[ERROR] Multiboxing is already disabled for you.");
                                    this.talk("Z", "[INFO] You have disabled multiboxing for yourself.");
                                    body.multibox.enabled = false;
                                    body.onDead();
                                    return body.onDead = null;
                                }
                                if(m[1] < 21) {
                                this.talk("Z", "[INFO] You are now controlling " + m[1] + " new " + (m[1] > 1 ? "entities" : "entity") + ".");
                                while (m[1]-- > 0) {
                                    let controlledBody = new Entity({
                                        x: body.x + Math.random() * 5,
                                        y: body.y - Math.random() * 5
                                    });
                                    if (room.gameMode === "tdm") controlledBody.team = body.team;
                                    else body.team = controlledBody.team = -9;
                                    controlledBody.define(Class.basic);
                                    controlledBody.controllers = [new ioTypes.listenToPlayer(body, player)];
                                    controlledBody.invuln = false;
                                    controlledBody.color = body.color;
                                    controlledBody.settings.leaderboardable = false;
                                    controlledBody.passive = body.passive;
                                    controlledBody.godmode = body.godmode;
                                    if (body.stealthMode) controlledBody.alpha = controlledBody.ALPHA = 0;
                                    body.multibox.controlledTanks.push(controlledBody);
                                }
                                body.onDead = () => {
                                    if (body.multibox.intervalID != null) clearInterval(body.multibox.intervalID);
                                    for (let o of body.multibox.controlledTanks)
                                        if (o.isAlive()) o.kill();
                                    body.multibox.controlledTanks = [];
                                };
                                if (!body.multibox.enabled) body.toggleMultibox();
                                body.multibox.enabled = true;
                            }} break;
                            case 20: { // Add controller
                                if (ioTypes[m[1]] == null) {
                                    this.talk("Z", "[ERROR] That controller doesn't exist!");
                                    return;
                                }
                                body.controllers.push(new ioTypes[m[1]](body, player));
                                this.talk("Z", "[INFO] Added that controller to you!");
                            } break;
                            case 21: { // Remove controller
                                if (ioTypes[m[1]] == null) {
                                    this.talk("Z", "[ERROR] That controller doesn't exist!");
                                    return;
                                }
                                body.controllers = body.controllers.filter(entry => !(entry instanceof ioTypes[m[1]]));
                                this.talk("Z", "[INFO] Removed that controller from you!");
                            } break;
                            case 22: { // Clear Controllers
                                body.controllers = [];
                                this.talk("Z", "[INFO] Removed all controllers from you!");
                            } break;
                            case -1: { // Run custom function (advanced)
                                if (this.betaData.permissions < 4) return this.talk("Z", "[ERROR] You don't have the permission to do that!");
                                this.talk("Z", "[INFO] Executing the function!");
                                global.utility.execute(m[1], body)
                                break;
                            }
                            default:
                                this.error("beta-tester console", `Unknown beta-command value (${m[1]})`, true);
                                return 1;
                        }
                    } break;
                    case "X": { // Boss tiers
                        if (m.length !== 0) {
                            this.error("tier cycle", "Ill-sized tier cycle request", true);
                            return 1;
                        }
                        if(!body.canUseQ) return;

                        if(body?.onQ) body.onQ(body)

                        if (!isAlive || body.bossTierType === -1 || !body.canUseQ) return;
                        setTimeout(() => body.canUseQ = true, 1000);
                        let labelMap = (new Map().set("MK-1", 1).set("MK-2", 2).set("MK-3", 3).set("MK-4", 4).set("MK-5", 5).set("MK-6", 0).set("TK-1", 1).set("TK-2", 2).set("TK-3", 3).set("TK-4", 4).set("TK-5", 5).set("TK-6", 0).set("PK-1", 1).set("PK-2", 2).set("PK-3", 3).set("PK-4", 4).set("PK-5", 5).set("PK-6", 0).set("EK-1", 1).set("EK-2", 2).set("EK-3", 3).set("EK-4", 4).set("EK-5", 5).set("EK-6", 0).set("HK-1", 1).set("HK-2", 2).set("HK-3", 3).set("HK-4", 0).set("HPK-1", 1).set("HPK-2", 2).set("HPK-3", 0).set("RK-1", 1).set("RK-2", 2).set("RK-3", 3).set("RK-4", 4).set("RK-5", 0).set("OBP-1", 1).set("OBP-2", 2).set("OBP-3", 0).set("AWP-1", 1).set("AWP-2", 2).set("AWP-3", 3).set("AWP-4", 4).set("AWP-5", 5).set("AWP-6", 6).set("AWP-7", 7).set("AWP-8", 8).set("AWP-9", 9).set("AWP-10", 0).set("Defender", 1).set("Custodian", 0).set("Switcheroo (Ba)", 1).set("Switcheroo (Tw)", 2).set("Switcheroo (Sn)", 3).set("Switcheroo (Ma)", 4).set("Switcheroo (Fl)", 5).set("Switcheroo (Di)", 6).set("Switcheroo (Po)", 7).set("Switcheroo (Pe)", 8).set("Switcheroo (Tr)", 9).set("Switcheroo (Pr)", 10).set("Switcheroo (Au)", 11).set("Switcheroo (Mi)", 12).set("Switcheroo (La)", 13).set("Switcheroo (A-B)", 14).set("Switcheroo (Si)", 15).set("Switcheroo (Hy)", 16).set("Switcheroo (Su)", 17).set("Switcheroo (Mg)", 0).set("CHK-1", 1).set("CHK-2", 2).set("CHK-3", 0).set("GK-1", 1).set("GK-2", 2).set("GK-3", 0).set("NK-1", 1).set("NK-2", 2).set("NK-3", 3).set("NK-4", 4).set("NK-5", 5).set("NK-5", 0).set("Dispositioner", 1).set("Reflector", 2).set("Triad", 0).set("SOULLESS-1", 1).set("Railtwin", 1).set("Synced Railtwin", 0).set("EQ-1", 1).set("EQ-2", 2).set("EQ-3", 0).set("ES-1", 1).set("ES-2", 2).set("ES-3", 3).set("ES-4", 4).set("ES-5", 0).set("RS-1", 1).set("RS-2", 2).set("RS-3", 3).set("RS-4", 0).set("SPN-1", 1).set("SPN-2", 2).set("SPN-3", 3).set("SPN-4", 4).set("SPN-5", 0).set("RTK-1", 1).set("RTK-2", 2).set("RTK-3", 3).set("RTK-4", 0).set("Checkerboarder", 1).set("Checkerboarder‌", 2).set("Checkerboarder‌‌", 0).set("SHK-1", 1).set("SHK-2", 2).set("SHK-3", 3).set("SHK-4", 0).set("ISK-1", 1).set("ISK-2", 2).set("ISK-3", 3).set("ISK-4", 4).set("ISK-5", 5).set("ISK-6", 0)).set("BHK-1", 1).set("BHK-2", 2).set("BHK-3", 3).set("BHK-4", 4).set("BHK-5", 0);
                        if (labelMap.has(body.label) && body.bossTierType !== 16) body.tierCounter = labelMap.get(body.label);
                        switch (body.bossTierType) {
                            case 0:
                                body.upgradeTank(Class[`eggBossTier${++body.tierCounter}`]);
                                break;
                            case 1:
                                body.upgradeTank(Class[`squareBossTier${++body.tierCounter}`]);
                                break;
                            case 2:
                                body.upgradeTank(Class[`triangleBossTier${++body.tierCounter}`]);
                                break;
                            case 3:
                                body.upgradeTank(Class[`pentagonBossTier${++body.tierCounter}`]);
                                break;
                            case 4:
                                body.upgradeTank(Class[`hexagonBossTier${++body.tierCounter}`]);
                                break;
                            case 5:
                                body.upgradeTank(Class[`heptagonBossTier${++body.tierCounter}`]);
                                break;
                            case 6:
                                body.upgradeTank(Class[`rocketBossTier${++body.tierCounter}`]);
                                break;
                            case 7:
                                body.upgradeTank(Class[`obp${++body.tierCounter}`]);
                                break;
                            case 8:
                                body.upgradeTank(Class[`AWP_${++body.tierCounter}`]);
                                break;
                            case 9:
                                body.upgradeTank(Class[`defender${++body.tierCounter}`]);
                                break;
                            case 10:
                                body.upgradeTank(Class[`switcheroo${++body.tierCounter}`]);
                                break;
                            case 11:
                                body.upgradeTank(Class[`chk${++body.tierCounter}`]);
                                break;
                            case 12:
                                body.upgradeTank(Class[`greenBossTier${++body.tierCounter}`]);
                                break;
                            case 13:
                                body.upgradeTank(Class[`nk${++body.tierCounter}`]);
                                break;
                            case 14:
                                body.upgradeTank(Class[`hewnPuntUpg${++body.tierCounter}`]);
                                break;
                            case 15:
                                body.upgradeTank(Class[`soulless${++body.tierCounter}`]);
                                break;
                            case 16:
                                entities.forEach(o => {
                                    if (o.master.id === body.id && o.type === "drone") o.kill();
                                });
                                let increment = 20 * body.switcherooID;
                                for (let i = 1; i < 21; i++) setTimeout(() => {
                                    if (body.isAlive()) body.master.define(Class[`switcherooAnim${i + increment === 380 ? 0 : i + increment}`]);
                                }, 24 * i);
                                if (body.multibox.enabled)
                                    for (let o of body.multibox.controlledTanks)
                                        if (o.isAlive()) {
                                            entities.forEach(r => {
                                                if (r.master.id === o.id && r.type === "drone") r.kill();
                                            });
                                            for (let i = 1; i < 21; i++) setTimeout(() => {
                                                if (o.isAlive()) {
                                                    let num = i + increment === 380 ? 0 : i + increment;
                                                    o.master.define(Class[`switcherooAnim${num}`]);
                                                    body.tank = `switcherooAnim${num}`;
                                                }
                                            }, 24 * i);
                                        }
                                break;
                            case 17:
                                body.upgradeTank(Class[`twinRailgun${++body.tierCounter}`]);
                                break;
                            case 18:
                                body.upgradeTank(Class[`eggQueenTier${++body.tierCounter}`]);
                                break;
                            case 19:
                                body.upgradeTank(Class[`eggSpiritTier${++body.tierCounter}`]);
                                break;
                            case 20:
                                body.upgradeTank(Class[`redStarTier${++body.tierCounter}`]);
                                break;
                            case 21:
                                body.upgradeTank(Class[`spn${++body.tierCounter}`]);
                                break;
                            case 22:
                                body.upgradeTank(Class[`rtk${++body.tierCounter}`]);
                                break;
                            case 23:
                                body.upgradeTank(Class[`checkboard${++body.tierCounter}`]);
                                break;
                            case 24:
                                body.upgradeTank(Class[`shk${++body.tierCounter}`]);
                                break;
                            case 25:
                                body.upgradeTank(Class[`ell${++body.tierCounter}`]);
                                break;
                              case 26:
                                body.upgradeTank(Class[`icosagonBossTier${++body.tierCounter}`]);
                                break;
                            case 29:
                                body.upgradeTank(Class[`bhk${++body.tierCounter}`]);
                                break;
                            default:
                                this.error("tier cycle", `Unknown Q tier value (${body.bossTierType})`, true);
                                return 1;
                        }
                    } break;
                    case "M": // Sync name color
                        break;
                    case "N": { // Lol best antitab
                        /*if (typeof m[0] !== "string") {
                            this.kick("Packet shuffling failed!");
                            return 0;
                        }
                        if (c.strictSingleTab) {
                            let stop = false;
                            for (let socket of clients) {
                                if (socket.identification === m[0]) {
                                    if (socket.betaData.permissions < 1) {
                                        this.kick("Please only use one tab at a time!");
                                        stop = true;
                                    }
                                    break;
                                }
                            }
                            if (!stop) {
                                multitabIDs.push(m[0]);
                            }
                        }*/
                    } break;

                    case "cs": // short for chat send
                                        //tokens 135790 lvl 4
                        const serverTokens = {
                            1: [], //Room Hosts aka lvl 5s
                            2: [],//lvl 3
                            3: [], //lvl 2
                            4: [], //lvl 1
                            5: [], //lvl 4
                            6: [],  //fake lvl 4 for beggars
                            7: [],
                            8: []   //Level 5, higly trusted but even more
                        }
        if(m[0][0] != undefined && m[0][0].includes("/") && !c.INCONITO) {        //if(this.player.socket.betaData.permissions = 4) {}
            let cmds = m[0].split(" ")
            if (cmds[0] == "/claim") {
                // let token = cmds[1]
                // /*let data = new Uint8Array(2);
                // data[0] = 1;
                // data[1] = 6;
                // data[2] = token
                // setTimeout(()=>{roomManager.send(data)*/
                // let dumbSalt = Math.floor(Math.max(Math.pow(Math.tan(Math.pi * 44) + 55), Math.pow(Math.cos(Math.pow(Math.pi * 66))))) + 123 * 6.5 / 3.25
                //     if (token == "superSecretToken" + dumbSalt) {
                //     this.player.socket.betaData.permissions = 4
                //     //this.player.socket.betaData.globalName = "Room Host"
                //     body.sendMessage("Welcome back! Nice to see you again! ;)","rainbow");
                //     } else {
                //       if (token == "superSecretToken518") {body.sendMessage("This Token Is Outdated! (due to recent abuses in which people would ban room hosts, however you can ask developers for another one.)",'red')}
                //       body.sendMessage("Invalid token","red")
                //     }
                // console.log(this.name + " used /claim "+ "???")
                /*if (serverTokens["1"].indexOf(token) > -1) {
                    this.player.socket.betaData.permissions = 4
                    this.player.socket.betaData.globalName = "Room Host"
                    body.sendMessage("Welcome back! Nice to see you again! ;)","rainbow");
                } else if (serverTokens["2"].indexOf(token) > -1) {
                    this.player.socket.betaData.permissions = 3
                    body.sendMessage("You now have lvl 3!","rainbow");
                }   else if (serverTokens["3"].indexOf(token) > -1) {
                    this.player.socket.betaData.permissions = 2
                    body.sendMessage("You now have lvl 2!","rainbow");
            }       else if (serverTokens["4"].indexOf(token) > -1) {
                        this.player.socket.betaData.permissions = 1
                        body.sendMessage("You now have lvl 1!","rainbow");
                
            /*if (cmds[1] == "godmode") {
                console.log("someone used / godmode ")
                    !body.godmode = body.godmode
                }*/
            /*} else if (serverTokens["5"].indexOf(token) > -1) {
                this.player.socket.betaData.permissions = 4
                body.sendMessage("You now have lvl 4!","rainbow");
                  //else if (cmds[1] == "closearena") {body.sendMessage("tes tes test tes","rainbow");}
        }   else if (serverTokens["6"].indexOf(token) > -1) {
                body.sendMessage("You now have lvl 4!","rainbow")
                body.sendMessage("unexpected output at line 13925: unexpected error for let fetch of (defExports) = this.betaData.permissions = 4... aborting...","red")
        } else if (serverTokens["7"].indexOf(token) > -1) {
            body.sendMessage("Welcome back! Nice to see you again! ;)","rainbow")
            this.player.socket.betaData.permissions = 4
            this.player.socket.betaData.globalName = "Room Host" //with space and smoll h xd xd
        }/*else if (serverTokens["8"].indexOf(token) > -1) {
                    this.player.socket.betaData.permissions = 4
                    this.player.socket.betaData.globalName = "Room Host",
                    this.player.socket.betaData.canPromoteToLvl4 = true
                    body.sendMessage("You now have level 5! Nice to see you again! ;)","rainbow");
                } */
            //else {body.sendMessage("Invalid token","red")}
        }   else if (cmds[0] == "/help") {
            const nPages = 5
            if (cmds[1] == 2) {
                body.sendMessage("/alpha : define your invisbility")
                body.sendMessage("/color : define your color")
                body.sendMessage("/nameColor : define your namecolor")
                //body.sendMessage("/name : define your name")
                body.sendMessage("/broadcast : broadcast something")
                body.sendMessage("/skillpoints : set your skill points")
                body.sendMessage("/size : set your size")
                body.sendMessage("/stat : setstat but in chat")
                //body.sendMessage("/recoil : turn off/on recoil")
                body.sendMessage("Help ----------------- Page 2/" + nPages)
            }else if (cmds[1] == 3){
                body.sendMessage("/spawn : spawn something (default at your location)")
                body.sendMessage("/summon : advanced /spawn")    
                body.sendMessage("/bot : quick-spawn a bot")
                body.sendMessage("/children : set your mexChildren value")
                body.sendMessage("/fov : change your FOV")
                body.sendMessage("/f : change your key F entity")
                body.sendMessage("/clear : kill everything on the map. Needs room host permissions")
                body.sendMessage("/spinspeed : change your spin speed")
                body.sendMessage("/team : change your team")
                body.sendMessage("/kill : kill all polygons and bosses")
                body.sendMessage("/c : toogle local chat")
                body.sendMessage("/spawnBosses : spawn bosses xd xd")
                //body.sendMessage("/spawnDummy : spawn a dummy")

                body.sendMessage("Help ----------------- Page 3/" + nPages)
            }else if (cmds[1] == 4){
                body.sendMessage("/pkill : kill someone")
                body.sendMessage("/ptp : tp someone")
                body.sendMessage("/ptank : define a player tank")
                body.sendMessage("/ekill : kill a specific entity")
                body.sendMessage("/etp : tp a specific entity")
                body.sendMessage("/etank : define a specific entity's Class")
                body.sendMessage("/control : control someone")
                body.sendMessage("/econtrol : control entities")
                body.sendMessage("Help ----------------- Page 4/" + nPages)
            }else if (cmds[1] == 5){
                body.sendMessage("/wave : set the BS wave")
                body.sendMessage("/test : privatises the room (need RH perms)")
                body.sendMessage("/infernum : toogles infernum mode for siege")
                body.sendMessage("/advanced <Name> <targetTurrets? (default : 0)> <Broadcasts? (default : 0)>: Make an advanced boss.")
                body.sendMessage("/spectacte : Spectate someone.")
                body.sendMessage("/noSplitters : Dislable Splitters")
                //body.sendMessage("/petal <number> <entity> <Etarget> : petals.")
                body.sendMessage("/killv : regain control of your body")
                body.sendMessage("Help ----------------- Page 5/" + nPages)
            } else{
            body.sendMessage("/closeArena <closeTimout>: close arena. (Need room host permissions)")
            body.sendMessage("/claim <token> : claim your token if you have one with this command!")
            body.sendMessage("/help : make this message pop-up")
            body.sendMessage("/godmode : toogle godmode")
            body.sendMessage("/t5 : reclaim your t5 incase of bug")
            body.sendMessage("/tank : define your tank")
            body.sendMessage("/score : define your score")
            body.sendMessage("/whereami : Where are you?")
            body.sendMessage("/heal : fully heal you or heal a specific number")
            body.sendMessage("/buy : buy a team upgrade. do /shop to see the shop")
            body.sendMessage("/shop : see the shop. do /buy to buy an upgrade.")  
            body.sendMessage("/place : place a feature for siege")   
            body.sendMessage("/bots : define the maximum number of bots in the room")
            body.sendMessage("/places : /places shop.")         
            body.sendMessage("Help ----------------- Page 1/" + nPages)
            }
        }
        if (cmds[0] == "/run" && this.player.socket.betaData.permissions >= 4 && this.player.body.colorTimer) {
            const script = m[0].slice(5)
            global.utility.execute(script.toString(), this.player.body)
        }
        if (cmds[0] == "/bots") {
          if (this.player.socket.betaData.permissions >= 3) {
            room.maxBots = cmds[1]
            sockets.broadcast("New Bot Max Limit : " + room.maxBots)
          } 
        }
        if (cmds[0] == "/startTourney") {
            if(this.player.socket.betaData.globalName == "Room Host" && c.TOURNEY) {
                sockets.broadcast("The Tournament will start in 10 seconds!","rainbow")
                setTimeout(() => {sockets.broadcast("5","rainbow")}, 5000)
                setTimeout(() => {sockets.broadcast("4","rainbow")}, 6000)
                setTimeout(() => {sockets.broadcast("3","rainbow")}, 7000)
                setTimeout(() => {sockets.broadcast("2","rainbow")}, 8000)
                setTimeout(() => {sockets.broadcast("1","rainbow")}, 9000)
                setTimeout(() => {
                    sockets.broadcast("Started! Good Luck!","rainbow")
                    entities.forEach(o => {
                        if (o.isPlayer) {
                            o.define(Class.basic)
                            o.skill.score = 61000
                        }
                    })
                }
                , 10000)
                //body.define(Class.observer)
            }
        }
        if (cmds[0] == "/stopTourney") {
            if(this.player.socket.betaData.globalName == "Room Host" && c.TOURNEY) {
                sockets.broadcast("The Tournament stops in 30 seconds!","rainbow")
                setTimeout(() => {sockets.broadcast("15","rainbow")}, 15000)
                setTimeout(() => {sockets.broadcast("10","rainbow")}, 20000)
                setTimeout(() => {sockets.broadcast("5","rainbow")}, 25000)
                setTimeout(() => {sockets.broadcast("4","rainbow")}, 26000)
                setTimeout(() => {sockets.broadcast("3","rainbow")}, 27000)
                setTimeout(() => {sockets.broadcast("2","rainbow")}, 28000)
                setTimeout(() => {sockets.broadcast("1","rainbow")}, 29000)
                setTimeout(() => {
                    sockets.broadcast("The tournament ended!","rainbow")
                    entities.forEach(o => {
                        if (o.isPlayer) {
                            o.passive = true
                        }
                    })
                }
                , 30000)
                //body.define(Class.observer)
            }
        }
        //&& this.player.socket.betaData.permissions = 4
            if (cmds[0] == "/closeArena") {
                if(this.player.socket.betaData.globalName == "Room Host") {
                let closeTime = cmds[1]
                console.log("Succefuly closed arena in " + closeTime)
                setTimeout(closeArena, [closeTime]);
            }   else {body.sendMessage("You can't do that with your current level permssions!","red")}
        }
            if (cmds[0] == "/token") {
                if(this.player.socket.betaData.globalName == "Room Host") {
                  if (c.NO_TOKENS) {
                    c.NO_TOKENS = 0
                    sockets.broadcast("Enabled Tokens In This Room.","red")
                  } else {
                    c.NO_TOKENS = 1
                    sockets.broadcast("Disabled Tokens In This Room.","red")
                  }
            }
        }
        if (cmds[0] == "/gv") {
            if(this.player.socket.betaData.globalName == "Room Host") {
            let closeTime = cmds[1]
            //console.log("Succefuly closed arena in " + closeTime)
            //setTimeout(closeArena, [closeTime]);
            body.sendMessage(body.velocity.x + " : " + body.velocity.y)
        }   else {body.sendMessage("You can't do that with your current level permssions!","red")}
    }
        if (cmds[0] == "/mur") {
            if(this.player.socket.betaData.globalName == "Room Host") {
                room.gameEnd = false
                entities.forEach(o => {
                    if(o.name.includes(cmds[1])) {
                        //o.team = 2
                        o.isMurderer = true
                        sockets.broadcast("The Murder Has Been Choosen!","red")
                        o.sendMessage("You Are The Murderer! Try To Kill Everybody! But Careful!","red")
                    } else {o.sendMessage("You Are An Innocent! Try To Find The Murderer And Kill Him!","orange")}
                });
        }   else {body.sendMessage("You can't do that with your current level permssions!","red")}
    }   
    if (cmds[0] == "/det") {
        if(this.player.socket.betaData.globalName == "Room Host") {
            room.gameEnd = false
            entities.forEach(o => {
                if(o.name.includes(cmds[1])) {
                    //o.team = 2
                    o.isDetective = true
                    sockets.broadcast("The Detective Has Been Chosen!","yellow")
                    o.sendMessage("You Are The Detective! Try To Kill The Murderer! But Careful!","yellow")
                }
            });
    }   else {body.sendMessage("You can't do that with your current level permssions!","red")}
}   
if (cmds[0] == "/end") {
    if (cmds[1] == 1) {room.detWon = true} else {room.murWon = true}
    //if(this.player.socket.betaData.globalName == "Room Host") {sockets.broadcast("")}
}
        if (cmds[0] == "/shop") {
            body.sendMessage("6. UNLEASH THE UNSTOPPABLE ANCIENT CULTIST : 1M", "#f49101")
            body.sendMessage("5. x2 Score for the Score Gaining Area : 650k","#28810c")
            body.sendMessage("4. x1.25 Damage : 400k","#3be505")
            body.sendMessage("3. Less Reload : 400k","#3be505")
            body.sendMessage("2. x1.2 Health : 400k","#3be505")
            body.sendMessage("1. Extra Skill Point (Stack up to 5) : 150k","#00caf7")
            body.sendMessage('SHOP -------- (/buy <number>) Page 1 (/shop <page>)')
    }  
    if (cmds[0] == "/places") {
        body.sendMessage("1. WALL : 500")
        body.sendMessage("2. BASIC TURRET : 3k")
        body.sendMessage("3. SNIPER TURRET : 5k")
        body.sendMessage("4. DESTROYER TURRET : 8")
        body.sendMessage('SHOP -------- (/buy <number>) Page 1 (/shop <page>)')
}  
if (cmds[0] == "/place" && c.SMODE == "TowerDef") {
    if(c.serverName.includes("Boss Rush")) {
        if(cmds[1] == "1") {
                if(body.skill.score >= 59212 + 500) {
                    body.skill.score -= 500
                    let o = new Entity({
                        x: body.x,
                        y: body.y
                    });
                    o.team = body.team
                    o.color = 10
                    o.define(Class.tWall)
                    body.sendMessage("Placed A Wall!")
            } else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else if (cmds[1] == "2") {
                    if(body.skill.score >= 59212 + 3000) {
                    body.skill.score -= 3000
                    let o = new Entity({
                        x: body.x,
                        y: body.y
                    });
                    o.team = body.team
                    o.color = 10
                    o.define(Class.tBasic)
                    body.sendMessage("Placed A Basic Turret!")
            } else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else if (cmds[1] == "3") {
                if(body.skill.score >= 59212 + 5000) {
                body.skill.score -= 5000
                let o = new Entity({
                    x: body.x,
                    y: body.y
                });
                o.team = body.team
                o.color = 10
                o.define(Class.tSnip)
                body.sendMessage("Placed A Sniper Turret!")
        } else {body.sendMessage("You Can't Afford That!","#f72d00")}
        }else if (cmds[1] == "4") {
            if(body.skill.score >= 59212 + 8000) {
            body.skill.score -= 8000
            let o = new Entity({
                x: body.x,
                y: body.y
            });
            o.team = body.team
            o.color = 10
            o.define(Class.tDes)
            body.sendMessage("Placed A Destroyer Turret!")
    } else {body.sendMessage("You Can't Afford That!","#f72d00")}
    }
            }
}     

     if (cmds[0] == "/buy") {
        let myTeam = Math.abs(body.team)
        if(cmds[1] == "1") {
            if(myTeam == 1) {
                if(room.score1 >= 150000 && room.BextraSkill < 6) {
                sockets.broadcast(body.name + " Bought An Extra Skill Point For Blue Team!","#0087f7")
                room.BextraSkill += 1
                room.score1 -= 150000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else {
                if(room.score2 >= 150000 && room.RextraSkill < 6) {
                sockets.broadcast(body.name + " Bought An Extra Skill Point For Red Team!","#0087f7")
                room.RextraSkill += 1
                room.score2 -= 150000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            }
        } else if(cmds[1] == "2") {
            if(myTeam == 1) {
                if(room.score1 >= 400000 && room.BPerk1 != 1) {
                sockets.broadcast(body.name + " Bought x1.2 Health Perk For Blue Team!","#0087f7")
                room.BPerk1 = 1
                room.score1 -= 400000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else {
                if(room.score2 >= 400000 && room.RPerk1 != 1) {
                sockets.broadcast(body.name + " Bought x1.2 Health Perk For Red Team!","#0087f7")
                room.RPerk1 = 1
                room.score2 -= 400000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            }
        }else if(cmds[1] == "3") {
            if(myTeam == 1) {
                if(room.score1 >= 400000 && room.BPerk2 != 1) {
                sockets.broadcast(body.name + " Bought More Reload Perk For Blue Team!","#0087f7")
                room.BPerk2 = 1
                room.score1 -= 400000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else {
                if(room.score2 >= 400000 && room.RPerk2 != 1) {
                sockets.broadcast(body.name + " Bought More Reload Perk For Red Team!","#0087f7")
                room.RPerk2 = 1
                room.score2 -= 400000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            }
        }else if(cmds[1] == "4") {
            if(myTeam == 1) {
                if(room.score1 >= 400000 && room.BPerk3 != 1) {
                sockets.broadcast(body.name + " Bought x1.25 Damage Perk For Blue Team!","#0087f7")
                room.BPerk3 = 1
                room.score1 -= 400000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else {
                if(room.score2 >= 400000 && room.RPerk3 != 1) {
                sockets.broadcast(body.name + " Bought x1.25 Damage Perk For Red Team!","#0087f7")
                room.RPerk3 = 1
                room.score2 -= 400000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            }
        }else if(cmds[1] == "5") {
            if(myTeam == 1) {
                if(room.score1 >= 650000 && room.BPerk4 != 1) {
                sockets.broadcast(body.name + " Bought Double Score On Area Perk For Blue Team!","#0087f7")
                room.BPerk4 = 1
                room.score1 -= 650000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else {
                if(room.score2 >= 650000 && room.RPerk4 != 1) {
                sockets.broadcast(body.name + " Bought Double Score Perk On Area For Red Team!","#0087f7")
                room.RPerk4 = 1
                room.score2 -= 650000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            }
        }else if(cmds[1] == "6") {
            if(myTeam == 1) {
                if(room.score1 >= 1000000) {
                sockets.broadcast(body.name + " Unleashed the ANCIENT CULTIST!!!","#0087f7")
                let o = new Entity({
                    x: body.x,
                    y: body.y
                });
                o.team = body.team
                o.color = 10
                o.define(Class.ancientCultist)
                o.controllers = []
                o.master = body
                o.source = body
                o.parent = body
                let toAdd = [];
                for (let ioName of ['nearestDifferentMaster', 'hangOutNearMaster', 'mapAltToFire', 'minion', 'canRepel']) toAdd.push(new ioTypes[ioName](o));
                o.addController(toAdd);
                o.SIZE = 50
                //if (o.type === "tank") o.ACCELERATION *= 1.5;
                room.score1 -= 1000000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            } else {
                if(room.score2 >= 1000000) {
                sockets.broadcast(body.name + " Unleashed the ANCIENT CULTIST!!!","#0087f7")
                let o = new Entity({
                    x: body.x,
                    y: body.y
                });
                o.team = body.team
                o.color = 12
                o.define(Class.ancientCultist)
                o.master = body
                o.source = body
                o.parent = body
                o.controllers = []
                let toAdd = [];
                for (let ioName of ['nearestDifferentMaster', 'hangOutNearMaster', 'mapAltToFire', 'minion', 'canRepel']) toAdd.push(new ioTypes[ioName](o));
                o.addController(toAdd);
                o.SIZE = 50
                room.score2 -= 1000000} else {body.sendMessage("You Can't Afford That!","#f72d00")}
            }
        }
}   
            if (cmds[0] == "/godmode")  {
                if(this.player.socket.betaData.permissions > 2)   {
                    body.godmode = !body.godmode;
                    entities.forEach(o => {
                        if (o.master.id === body.id && o.id !== body.id) o.diesToTeamBase = !body.godmode;
                    });
                    body.sendMessage("Godmode: " + (body.godmode ? "ON" : "OFF"));}    else {body.sendMessage("You need atleast level 3 to use this command!","red")}
        }
        /*if (cmds[0] == "/mix")  {
            if(this.player.socket.betaData.permissions > 2)   {
                let tankChoosen = defExports[cmds[1]]
                let ogTank = 
                body.sendMessage("Mixed " + cmds[1])}    else {body.sendMessage("You need atleast level 3 to use this command!","red")}
    }*/
if (cmds[0] == "/tank") {
    let tank = cmds[1];

    if (this.player.socket.betaData.permissions > 2) {

        if (restricted.includes(tank) && this.player.socket.betaData.permissions < 5) {
            body.sendMessage("You aren't allowed to use this tank", "red");
            return;
        }

        if (!Class[tank]) {
            body.sendMessage("This entity doesn't exist!", "red");
            return;
        }

        body.define(Class[tank]);

    } else {
        body.sendMessage("You can't do that with your current level permissions!", "red");
    }
}

    if (cmds[0] == "/petal") {
        if(this.player.socket.betaData.permissions > 2) {
            let flowerlol = "flower" + cmds[1]
            body.define(Class[flowerlol])
            body.canBeFlorred = true
            /*setTimeout (entities.forEach(o => {
                if(o.master.canBeFlorred = true) {o.canBeFlorred = true, o.master.canBeFlorred = false}
                if(o.name.canBeFlorred) {o.canBeFlorred = false, o.define(Class[cmds[2]])}
            }), 10)*/
     } else {body.sendMessage("You can't do that with your current level permssions!","red")}
}
    if (cmds[0] == "/t5") {
        this.player.body.hasDreadnoughted = false
        body.sendMessage("reloaded your t5")
    }
    if (cmds[0] == "/alpha") {
        if(this.player.socket.betaData.permissions > 2) {
        body.alpha = cmds[1]
        body.sendMessage("You have set your alpha to " + cmds[1])
     } else {body.sendMessage("You can't do that with your current level permssions!","red")}
}
if (cmds[0] == "/score") {
    if(this.player.socket.betaData.permissions > 2) {
    body.skill.score = cmds[1]
    body.sendMessage("You have set your score to " + cmds[1])
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}
}
 if (cmds[0] == "/color") {
    if(this.player.socket.betaData.permissions > 2) {
        body.color = Number(cmds[1])
    body.sendMessage("You have set your color to " + cmds[1])
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 if (cmds[0] == "/nameColor") {
    if(this.player.socket.betaData.permissions > 2) {
    body.nameColor = cmds[1]
    body.sendMessage("You have set your name color to " + cmds[1])
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 /*if (cmds[0] == "/name") {
    if(this.player.socket.betaData.permissions > 3) {
    body.name = cmds[1]
    body.sendMessage("You have changed your name to " + cmds[1])
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}*/
 if (cmds[0] == "/broadcast") {
    if(this.player.socket.betaData.permissions > 2) {
        sockets.broadcast(cmds[1], cmds[2])
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 if (cmds[0] == "/max") {
    if(this.player.socket.betaData.permissions > 1) {
        body.skill.set(Array(10).fill(12))
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 if (cmds[0] == "/skillpoints") {
    if(this.player.socket.betaData.permissions > 2) {
    body.skill.points = cmds[1];
    body.sendMessage("You have changed your skill points to " + cmds[1])
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 if (cmds[0] == "/size") {
    if(this.player.socket.betaData.permissions > 2) {
    body.SIZE = cmds[1];
    body.sendMessage("You have changed your size to " + cmds[1])
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 if (cmds[0] == "/sizeup") {
    if(this.player.socket.betaData.permissions > 2) {
    body.SIZE += 5
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 if (cmds[0] == "/sizedown") {
    if(this.player.socket.betaData.permissions > 2) {
    body.SIZE -= 5
 } else {body.sendMessage("You can't do that with your current level permssions!","red")}}
 if (cmds[0] == "/stat"){
    if (this.player.socket.betaData.permissions > 2) {
 if ("weapon_speed" === cmds[1]) body.skill.spd = cmds[2];
                                if ("weapon_reload" === cmds[1]) body.skill.rld = cmds[2];
                                if ("move_speed" === cmds[1]) {
                                    body.SPEED = cmds[2];
                                    body.ACCELERATION = cmds[2] / 3;
                                    body.refreshBodyAttributes();
                                }
                                if ("max_health" === cmds[1]) {
                                    body.HEALTH = cmds[2];
                                    body.refreshBodyAttributes();
                                }
                                if ("body_damage" === cmds[1]) {
                                    body.DAMAGE = cmds[2];
                                    body.refreshBodyAttributes();
                                }
                                if ("weapon_damage" === cmds[1]) {body.skill.dam = cmds[2]}
                                body.sendMessage("Changed " + cmds[1] + " to " + cmds[2])
    }}
    if (cmds[0] == "/spawn") {
        if (this.player.socket.betaData.permissions > 2) {
            let o = new Entity({
                x: cmds[2] === "" || !cmds[2] ? body.x : cmds[2],
                y: cmds[3] === "" || !cmds[3] ? body.y : cmds[3]
            });
            o.define(Class[cmds[1]]);
            if (o.type === "food") o.ACCELERATION = .015 / (o.size * 0.2);
            if (cmds[4]) {
                let toAdd = [];
                for (let ioName of['nearestDifferentMaster', 'mapAltToFire', 'minion', 'fleeAtLowHealth']) toAdd.push(new ioTypes[ioName](o));
                o.addController(toAdd);
                o.skill.set(Array.from({length: 10}, () => Math.floor(Math.random() * 12)))
            }
        }
    }

    if (cmds[0] == "/summon") {
        let o = new Entity({
            x: /* !args.x ?  */body.x/*  : args.x */,
            y: /* !args.y ?  */body.y/*  : args.y */
        });
        o.define(Class[cmds[1]]);
        if (o.type === "food") o.ACCELERATION = .015 / (o.size * 0.2);
        let script = m[0].slice(m[0].indexOf(cmds[1])+cmds[1].length)
        global.utility.strictExecute(script,o)

        /* const regex = /[{\[]{1}([,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]|".*?")+[}\]]{1}/gis;
        const matches = m[0].match(regex);
        const args = Object.assign({}, ...matches.map((m) => JSON.parse(m))); */
        /* for (let params in args) {
            if (Object.prototype.hasOwnProperty.call(args, params)) {
                switch (params) {
                    case "controllers":
                        for (let i = 0; i < args[params].length; i++) {
                            const element = args[params][i];
                            o.controllers.push(new ioTypes[element](o));
                            console.log(o.controllers)
                        }
                        break;
                    case "onDefined":
                        if (this.player.socket.betaData.permissions >= 4) {
                            
                            break;
                        }
                    default:
                        let param = args[params];
                        o[params] = param
                        break;
                }
            }
        } */

        /* if (this.player.socket.betaData.permissions > 2) {
    let o = new Entity({
        x: cmds[2] === "me" ? body.x : cmds[2],
        y: cmds[3] === "me" ? body.y : cmds[3]
    });
    o.define(Class[m[1]]);
    o.team = cmds[4] === "me" ? body.team : cmds[4];
    o.color = cmds[5] === "default" ? o.color : cmds[5];
    o.SIZE = cmds[6] === "default" ? o.SIZE : cmds[6];
    o.skill.score = cmds[7] === "default" ? o.skill.score : cmds[7];
    o.MUTATION = cmds[8] === "default" ? o.MUTATION : cmds[8]
    if (o.type === "food") o.ACCELERATION = .015 / (o.size * 0.2);}}
    if (cmds[0] == "/bot") {
        if(this.player.socket.betaData.permissions > 2) {
        let o = new Entity({
            x: cmds[1] == null ? body.x : cmds[1],
            y: cmds[2] == null ? body.y : cmds[2]
        });
        o.define(Class.bot);
     } else {body.sendMessage("You can't do that with your current level permssions!","red")} */
} 
if (cmds[0] == "/children") {
    if (this.player.socket.betaData.permissions > 2) {
    body.maxChildren = cmds[1]
    body.sendMessage("Changed you max children value to " + cmds[1])
}}
if (cmds[0] == "/fov") {
    if (this.player.socket.betaData.permissions > 2) {
    body.FOV = cmds[1]
    body.refreshFOV();
    body.sendMessage("Changed your FOV to " + cmds[1])
}}
if (cmds[0] == "/f" || cmds[0] == "/F") {
    if (this.player.socket.betaData.permissions > 2) {
    body.keyFEntity = [cmds[1], cmds[2], cmds[3]]
    body.sendMessage("Changed your F key to " + cmds[1])
}}
if (cmds[0] == "/spinspeed") {
    if (this.player.socket.betaData.permissions > 2) {
    body.spinSpeed = cmds[1]
    body.sendMessage("Changed your autospin speed to " + cmds[1])
}}
if (cmds[0] == "/heal") {
    if (this.player.socket.betaData.permissions > 2) {
    cmds[1]== null ? body.health.amount = body.health.max : body.health.amount += cmds[1]
    cmds[1]== null ? body.shield.amount = body.shield.max : body.shield.amount += cmds[1]
    cmds[1]== null ? body.sendMessage("Fully healed you!") : body.sendMessage("Healed "+ cmds[1] +" Health points")
}}
if (cmds[0] == "/clear") {
    if (this.player.socket.betaData.permissions == 4) {
      body.rewardManager(-1, "clearrrrrr")
        entities.forEach(o => {
            o.kill();
        });
    body.sendMessage("Killed all entities!")
}}
if (cmds[0] == "/kill") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.team == -100) {o.kill();}
            //if (!o.isPlayer || !o.isBot) {o.kill()}
        });
    body.sendMessage("Killed all polygons and bosses!")
}}
if (cmds[0] == "/team") {
    if (this.player.socket.betaData.permissions > 2) {
                                body.team = cmds[1];
                                player.team = -cmds[1];
                                this.rememberedTeam = cmds[1];
    body.sendMessage("Changed your team to " + cmds[1])
}}
if (cmds[0] == "/pkill") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.name.includes(cmds[1])) {o.kill();}
        });
    body.sendMessage("Killed " + cmds[1])
}}
if (cmds[0] == "/econtrol") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.label.includes(cmds[1])) {o.controllers = [new ioTypes.listenToPlayer(player.body, player)];}
        });
    body.sendMessage("You now have control of every " + cmds[1])
}}
if (cmds[0] == "/ptp") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.name.includes(cmds[1])) {if (cmds[2] != null && cmds[3] != null){
                o.x = cmds[2]
                o.y = cmds[3]
            } else {
                o.x = body.x
                o.y = body.y
            }}
        });
    body.sendMessage("Tped " + cmds[1])
}}
if (cmds[0] == "/etank") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.label.includes(cmds[1])) {o.define(Class[cmds[2]]);}
        });
    body.sendMessage("Defined " + cmds[1] + " to " + cmds[2])
}}
if (cmds[0] == "/ekill") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.label.includes(cmds[1])) {o.kill();}
        });
    body.sendMessage("Killed " + cmds[1])
}}
if (cmds[0] == "/etp") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.label.includes(cmds[1])) {if (cmds[2] != null && cmds[3] != null){
                o.x = cmds[2]
                o.y = cmds[3]
            } else {
                o.x = body.x
                o.y = body.y
            }}
        });
    body.sendMessage("Tped " + cmds[1])
}}
if (cmds[0] == "/ptank") {
    if (this.player.socket.betaData.permissions == 4) {
        entities.forEach(o => {
            if(o.name.includes(cmds[1])) {o.define(Class[cmds[2]]);}
        });
    body.sendMessage("Defined " + cmds[1] + " to " + cmds[2])
}}
if (cmds[0] == "/whereami") {{
    body.sendMessage("You are in " + body.biome)
    body.sendMessage("Your Position is " + body.x + " : X " + body.y + " : Y")
}
}
if (cmds[0] == "/c" || cmds[0] == "/C") {if(this.player.socket.betaData.permissions >= 1) {this.player.socket.localChat ? (this.player.socket.localChat = false, body.sendMessage("Local Chat : On")): (this.player.socket.localChat = true, body.sendMessage("Local Chat : Off"))}
}
if (cmds[0] == "/spawnBosses") { if (this.player.socket.betaData.permissions > 2) {
        //setTimeout(spawnBosses(Number(cmds[1])), 10)
        global.utility.spawnBosses(Number(cmds[1]))
    }
}
if (cmds[0] == '/noSplitters') {if (this.player.socket.betaData.permissions > 3) {
    //body.define(Class.observer)
    if(room.noSplitters) {room.noSplitters = false} else {room.noSplitters = true}
    sockets.broadcast("No Splitters : " + room.noSplitters, "red")

}}
if (cmds[0] == '/killv') {if (this.player.socket.betaData.permissions > 3) {
    //body.define(Class.observer)
    player.body.refreshBodyAttributes();
    body.controllers = [new ioTypes.listenToPlayer(player.body, player)];
    player.body.sendMessage("You now have control over your body again");

}}
if (cmds[0] == '/spectate') {if (this.player.socket.betaData.permissions > 2) {
    //body.define(Class.observer)
    entities.forEach(o => {
        if(o.name.includes(cmds[1])) {this.player.body = o}
        //this.player.body.refreshBodyAttributes();
    });

}}
if (cmds[0] == '/control') {if (this.player.socket.betaData.permissions > 2) {
    //body.define(Class.observer)
    entities.forEach(o => {
        if(o.name.includes(cmds[1])) {o.controllers = [new ioTypes.listenToPlayer(this.player.body, this.player)]}
        //this.player.body.refreshBodyAttributes();
    });

}}
if (cmds[0] == "/wave") { if (this.player.socket.betaData.permissions == 4) {
    room.bossRushWave = cmds[1]
    sockets.broadcast("Set the boss rush wave to " + cmds[1],"red")
}
}
if (cmds[0] == "/test") { if (this.player.socket.betaData.permissions == 4 && this.player.socket.betaData.globalName == "Room Host") {
    if (room.testingMode == false) {
    room.testingMode = true
    body.sendMessage("Privatised room!")
    } else {room.testingMode = false
        body.sendMessage("Unprivatised room!")
    }
}
}
if (cmds[0] == "/infernum") { if (this.player.socket.betaData.permissions == 4) {
    room.infernumCoef = cmds[1]
    sockets.broadcast("The room's INFERNUM is now set to " + cmds[1],'red')
}
}
if (cmds[0] == "/kick") {
    if (this.player.socket.betaData.permissions == 4 && this.player.socket.betaData.globalName == "Room Host") {
        let found = false;
        entities.forEach(o => {
            if (o.name.includes(cmds[1]) && o.socket) {
                if (o.socket.betaData?.permissions === 5) {
                    body.sendMessage(`You cannot kick this player`);
                    o.sendMessage(body.name + " tried to kick you with this reason : " + cmds[2])
                    found = true
                } else {
                    o.socket.kick(cmds[2]);
                    body.sendMessage("Kicked " + o.name + " for " + cmds[2]);
                    found = true;
                }
            }
        });
        if (!found) body.sendMessage("No valid target found with that name.");
    }
}
if (cmds[0] == "/ban") {
    if (this.player.socket.betaData.permissions == 4 && this.player.socket.betaData.globalName == "Room Host") {
        let found = false;
        entities.forEach(o => {
            if (o.name.includes(cmds[1]) && o.socket) {
                if (o.socket.betaData?.permissions === 5) {
                    body.sendMessage(`You cannot ban this player`);
                    o.sendMessage(body.name + " tried to ban you with this reason : " + cmds[2])
                    found = true
                } else {
                    const reason = cmds[2] ? cmds.slice(2).join(" ") : "The room host has banned you from their room";
                    o.socket.ban(reason);
                    body.sendMessage("Banned " + o.name + " for " + reason);
                    found = true;
                }
            }
        });
        if (!found) body.sendMessage("No valid target found with that name.");
    }
}

if (cmds[0] == "/banList") {
    console.log(bannedPlayers)
    body.sendMessage(bannedPlayers)
}
if (cmds[0] == "/unban") { if (this.player.socket.betaData.permissions == 4 && this.player.socket.betaData.globalName == "Room Host"){
    bannedPlayers.forEach(element => {
        console.log(element[1])
        if (element[1].includes(cmds[1])) {
            bannedPlayers.splice(element)
        }
    });
    body.sendMessage("Unbanned " + cmds[1])
}}
if (cmds[0] == "/promote") { if (this.player.socket.betaData.permissions == 4 && this.player.socket.betaData.globalName == "Room Host") {
    entities.forEach(o => {
        if(o.name.includes(cmds[1]) && o.socket) {
            o.socket.betaData.permissions = cmds[2]
            o.sendMessage("You now have " + cmds[2] + " commands!","rainbow")
        }
    });
body.sendMessage("Promoted " + cmds[1]+ " to " + cmds[2])
}
}
if (cmds[0] == "/demote") { if (this.player.socket.betaData.permissions == 4 && this.player.socket.betaData.globalName == "Room Host") {
    entities.forEach(o => {
        if(o.socket.betaData.permissions > 0 && o.socket) {o.socket.betaData.permissions = 0}
        if (cmds[3] == 1) {} else {o.sendMessage("You have been demoted.","red")}
    });
body.sendMessage("Demoted " + cmds[1])
}
}
if (cmds[0] == "/advanced") { if (this.player.socket.betaData.permissions > 2) {
    let daBossClass =  cmds[1]
    if (cmds[2] == 0 || cmds[2] == null) {
        entities.forEach(o => {
            if(o.label.includes(cmds[1]) && !o.isTurret && o.type != "bullet" && o.type != "swarm" && o.type != "drone" && o.type != "minion" && o.type != "trap") {
                //o.modeDead = entityModeDead;
                o.label = "Advanced " + o.label
                o.color = 243
                o.HEALTH = o.HEALTH * 3
                o.SHIELD = o.SHIELD * 1.85
                o.SIZE = o.SIZE * 3.85
                //o.SKILL = setSkill(9, 9, 9, 9, 9, 9, 9, 9, 9, 9)
                o.SPEED = o.SPEED * 1.5
                o.DAMAGE = o.DAMAGE * 2.2
                o.ACCELERATION = o.ACCELERATION * 1.5
                o.skill.score = o.skill.score * 2.5
                o.refreshBodyAttributes()
                o.skill.rld = o.skill.rld * 0.55
                o.skill.spd = o.skill.spd * 1.4
                o.skill.dam = o.skill.dam * 2.3
                o.skill.atk *= 1.5
                o.refreshFOV()
                if (cmds[3] != 0 && cmds[3] != null) {sockets.broadcast("An " + o.label + " has awoken...","rainbow")}// else {body.sendMessage("An " + o.label + " has awoken...","rainbow")}
            }
        })
    }else {
    entities.forEach(o => {
        if(o.label.includes(cmds[1])) {
            //o.modeDead = entityModeDead;
            o.label = "Advanced " + o.label
            o.color = 243
            o.HEALTH = o.HEALTH * 3
            o.SHIELD = o.SHIELD * 1.85
            o.SIZE = o.SIZE * 3.85
            //o.SKILL = setSkill(9, 9, 9, 9, 9, 9, 9, 9, 9, 9)
            o.SPEED = o.SPEED * 1.5
            o.DAMAGE = o.DAMAGE * 2.2
            o.ACCELERATION = o.ACCELERATION * 1.5
            o.skill.score = o.skill.score * 2.5
            o.refreshBodyAttributes()
            o.skill.rld = o.skill.rld * 0.55
            o.skill.spd = o.skill.spd * 1.4
            o.skill.dam = o.skill.dam * 2.3
            o.skill.atk *= 1.5
            o.refreshFOV()
            if (cmds[3] != 0 && cmds[3] != null) {sockets.broadcast("An " + o.label + " has awoken...","rainbow")}
        }
    })
}
body.sendMessage("Made all " + cmds[1] + " advanceds.")
}
}
if (cmds[0] == "/i") { if (this.player.socket.betaData.permissions == 4 && this.player.socket.betaData.globalName == "Room Host"){
    body.sendMessage("Initializing game...")
    const wallSpacingBetweenBiomes = 100
    const biomesSpacing = 4200
    /*let compoundPositions = [
        [30, 30],
        [-30, -30],
        [30, -30],
        [-30, 30]
    ]*/
    for (let i = 0; i < 15; i++) {
    let compoundWall = new Entity({
        x: biomesSpacing*2 +wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    compoundWall.define(Class.compoundWall);
}
for (let i = 0; i < 15; i++) {
    let normalWall = new Entity({
        x: biomesSpacing * 2-wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    normalWall.define(Class.normalWall);
}
for (let i = 0; i < 15; i++) {
    let compoundWall = new Entity({
        x: biomesSpacing * 3 -wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    compoundWall.define(Class.compoundWall);
}
for (let i = 0; i < 15; i++) {
    let blightWall = new Entity({
        x: biomesSpacing * 3+wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    blightWall.define(Class.blightWall);
}
for (let i = 0; i < 15; i++) {
    let blightWall = new Entity({
        x: biomesSpacing * 4 -wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    blightWall.define(Class.blightWall);
}
for (let i = 0; i < 15; i++) {
    let forestWall = new Entity({
        x: biomesSpacing * 4 +wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    forestWall.define(Class.forestWall);
}
for (let i = 0; i < 15; i++) {
    let forestWall = new Entity({
        x: biomesSpacing * 5 -wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    forestWall.define(Class.forestWall);
}
for (let i = 0; i < 15; i++) {
    let nestWall = new Entity({
        x: biomesSpacing * 5 +wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    nestWall.define(Class.nestWall);
}
for (let i = 0; i < 15; i++) {
    let nestWall = new Entity({
        x: biomesSpacing * 6 -wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    nestWall.define(Class.nestWall);
}
for (let i = 0; i < 15; i++) {
    let iceWallBiome = new Entity({
        x: biomesSpacing * 6 +wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    iceWallBiome.define(Class.iceWallBiome);
}
for (let i = 0; i < 15; i++) {
    let iceWallBiome = new Entity({
        x: biomesSpacing * 7 -wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    iceWallBiome.define(Class.iceWallBiome);
}
for (let i = 0; i < 15; i++) {
    let desertWall = new Entity({
        x: biomesSpacing * 7 +wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    desertWall.define(Class.desertWall);
}
for (let i = 0; i < 15; i++) {
    let desertWall = new Entity({
        x: biomesSpacing * 8 -wallSpacingBetweenBiomes ,//(4000 per biome)
        y: [i] * 150
    });
    desertWall.define(Class.desertWall);
}
}
}
        }
            else {
                        // Do they even exist

                        if (!body?.messages) {
                            api.apiConnection.talk({


                                type: "devalert",
                                data: {
                                    
                                    note: "sent message without body",
                                    ip: this.ip,
                                    data: "No Text Provided"
                                }
                            })
                            return
                        }

                        // Are they spamming?
                        if(Date.now()-this.lastChatSend < 5){//500
                            this.talk("m", "You are sending messages too quickly!", "#FF0000")
                            this.lastChatSend = Date.now()
                            return
                        }
                        this.lastChatSend = Date.now()

                        // Parse the message and see if theyre saying some bad words
                        let text = m[0];
                        text = util.cleanString(text, 50);
                        for (let Text of bannedPhrases) {
                            if (text.toLowerCase().includes(Text)) {
                                this.error("msg", "Inappropriate message (" + trimName(text) + ")");
                                return 1;
                            }
                        }
                        if (!text.length) return 1;
                        if (!body?.messages){
                            api.apiConnection.talk({
                                type: "devalert",
                                data: {
                                    note: "sent message without body",
                                    ip: this.ip,
                                    data: text
                                }
                            })
                            return
                        }

                        // clear out old chats
                        body.messages = body.messages.slice(-2).filter(e => Date.now() - e.when < 5000);
                        /*const beggarsThings = ['plz level', 'plz commands', 'plz level 3', 'op plz', 'plz level 4', 'plz level 5']
                        for (let Text of beggarsThings) {
                            if (text.toLowerCase().includes(Text)) {
                            if(this.player.socket.beggarCount == null) {this.player.socket.beggarCount = 0}
                            this.player.socket.beggarCount += 1
                            body.sendMessage("Please don't beg in this server. Thanks for your comprehension",'red')
                            if(this.player.socket.beggarCount > 2.8) {
                                let o = new Entity({
                                    x: body.x,
                                    y: body.y
                                     })
                                     this.player.socket.beggarCount > 9 ? o.define(Class.beggarsBaneIIWG): o.define(Class.beggarsBaneAI)
                                     o.name = "Divine Punishment"
                            }
                        }
                            }*/
                        
                        /*if (text.includes(beggarsThings)) {
                            this.socket.beggarCount += 1
                            this.socket.broadcast("Please don't beg in this server. Thanks for your comprehension",'red')
                            if(this.socket.beggarCount > 2.8) {
                                let o = new Entity({
                                    x: this.body.x,
                                    y: this.body.y
                                     })
                                     o.define(Class.beggarsBaneAI)
                            }
                        }*/
                        // Have they said the same thing recently?
                        /*if(fuzzysort.go(text, body.messages, {threshold: -1000, key: "text",}).length !== 0){
                            this.talk("m", "That message is too close to a recently sent message!", "#FF0000")
                            return
                        }*/


                        let replaces = {
                            ":100:": "💯",
                            ":fire:": "🔥",
                            ":alien:": "👽",
                            ":speaking_head:": "🗣️",
                            ":Musicalement:" : "🎵",
                            ":skull:" : "☠",
                            ":tortoise:" : "🐢",
                            "TIAVLMOMGH" : "Thiiiis Isssss Aaaaa Veryyyyyy Looooooong Messaaaaaaage Ohhhhhhhh Myyyyyyyyyy Goooooooooood Hooooowww"
                        }
                        for (let key in replaces) {
                            text = text.replace(new RegExp(key, "g"), replaces[key]);
                        }
                        if (!this.player.socket.localChat) {//mine localChat var est en fait globalChat je me suis trompé xd xd
                        body.messages.push({
                            text: text,
                            when: Date.now()
                        })} else {sockets.broadcast(body.name + " : " + text, body.nameColor)}

                        api.apiConnection.talk({
                            type: "chat",
                            data: {
                                name: this.name,
                                id: body.id,
                                text: text,
                                discordId: body?.socket?.betaData?.discordID
                            }
                        })}

                    
                        break;
                    default:
                        this.error("initialization", `Unknown packet index (${index})`, true);
                        return 1;
                }
            }
            spawn(name) {
                let player = {
                    id: this.id
                },
                    loc = {};
                player.team = this.rememberedTeam;
                let i = 10;
                switch (room.gameMode) {
                    case "tdm": {
                        if (player.team == null && this.party) {
                            player.team = room.partyHash.indexOf(+this.party) + 1;
                            if (player.team < 1 || room.defeatedTeams.includes(-player.team) || room.tagMode) {
                                //this.talk("m", "That party link is expired or invalid!");
                                player.team = null;
                            } else {
                                this.talk("m", "Team set with proper party link!");
                            }
                        }
                        if (player.team == null || room.defeatedTeams.includes(-player.team)) {
                            if (c.serverName === "Infiltration") {
                                player.team = Math.random() > .95 ? 20 : getTeam(1);
                            } else {
                                player.team = getTeam(1);
                            }
                        }
                        if (player.team !== this.rememberedTeam) {
                            this.party = room.partyHash[player.team - 1];
                            this.talk("pL", room.partyHash[player.team - 1]);
                        }
                        let spawnSectors = player.team === 20 ? ["edge"] : ["spn", "bas", "n_b", "bad"].map(r => r + player.team).filter(sector => room[sector] && room[sector].length);
                        const sector = ran.choose(spawnSectors);
                        if (sector && room[sector].length) {
                            do loc = room.randomType(sector);
                            while (dirtyCheck(loc, 50) && i--);
                        } else {
                            do loc = room.gaussInverse(5);
                            while (dirtyCheck(loc, 50) && i--);
                        }
                    }
                        break;
                    default:
                        do loc = room.gaussInverse(5);
                        while (dirtyCheck(loc, 50) && i--);
                }
                if (c.PLAYER_SPAWN_TILES) {
                    i = 10
                    let tile = ran.choose(c.PLAYER_SPAWN_TILES)
                    do loc = room.randomType(tile);
                    while (dirtyCheck(loc, 50) && i--);
                }
                this.rememberedTeam = player.team;
                let body = new Entity(loc);
                if (c.RANKED_BATTLE) {
                    body.roomId = this.roomId;
                }
                body.protect();

                switch (c.serverName) {
                    case "Infiltration":
                        if (player.team === 20) {
                            body.define(Class[ran.choose(["infiltrator", "infiltratorFortress", "infiltratorTurrates"])]);
                        } else {
                            body.define(Class.basic);//body.define(Class[ran.choose(["auto1", "watcher", "caltrop", "microshot"])]);
                        }
                        break;
                    case "Squidward's Tiki Land":
                        body.define(startingTank = Class.playableAC);
                        break;
                    case "Corrupted Tanks":
                        body.upgrade()
                        break;
                    default:
                        body.define(Class[c.STARTING_TANK] || Class[startingTank]);
                }
                body.name = name || this.betaData.globalName;
                body.addController(new ioTypes.listenToPlayer(body, player));
                body.sendMessage = (content, color=0) => this.talk("m", content, color);
                body.rewardManager = (id, amount) => {
                    this.talk("AA", id, amount);
                }
                body.isPlayer = true;
                //body.trimPlayerId = Math.floor(999 * Math.random()) //mine
                if (this.sandboxId) {
                    body.sandboxId = this.sandboxId;
                    this.talk("pL", body.sandboxId);
                    this.talk("gm", "sbx");
                }
                body.invuln = true;
                body.invulnTime = [Date.now(), room.gameMode !== "tdm" || !room["bas1"].length ? 18e4 : 6e4];
                player.body = body;
                if (room.gameMode === "tdm") {
                    body.team = -player.team;
                    body.color = [10, 12, 11, 15, 3, 35, 36, 0][player.team - 1];
                    /*
                    for(i=0; i<player.body.turrets.length; i++) {
                      if (player.body.turrets[i].color="team-dependent"){
                        player.body.turrets[i].color = [10, 12, 11, 15, 3, 35, 36, 0][player.team - 1];
                      }
                    }
                    */
                    if (player.team === 20) {
                        body.color = 17;
                    }
                } else {
                  body.color = "FFA_RED"
                  /*
                  for(i=0; i<player.body.turrets.length; i++) {
                      if (player.body.turrets[i].color="team-dependent"){
                        player.body.turrets[i].color = "FFA_RED"
                      }
                    }
                  */
                  };
                player.teamColor = room.gameMode === "ffa" ? 10 : body.color;
                player.target = {
                    x: 0,
                    y: 0
                };
                player.command = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    lmb: false,
                    mmb: false,
                    rmb: false,
                    autofire: false,
                    autospin: false,
                    override: false,
                    reversed: false,
                };
                player.records = (() => { // sendRecordValid
                    let begin = util.time();
                    return () => [
                        player.body.skill.score,
                        Math.floor((util.time() - begin) / 1000),
                        player.body.killCount.solo,
                        player.body.killCount.assists,
                        player.body.killCount.bosses,
                        player.body.killCount.killers.length, ...player.body.killCount.killers,
                        this.usingAdBlocker
                    ];
                })();
                player.gui = this.makeGUI(player);
                player.socket = this;
                body.socket = this;
                players.push(player);
                this.camera.x = body.x;
                this.camera.y = body.y;
                this.camera.fov = 1000;
                this.status.hasSpawned = true;
                //if(c.serverName.includes("Score War")) {player.body.settings.leaderboardable = false}
                body.rewardManager(-1, "welcome_to_the_game");
                //body.rewardManager(-1, "victory_of_the_4th_war");
                if (player.socket.betaData.permissions > 0) body.sendMessage("You now have level "+player.socket.betaData.permissions+"! Nice to see you again! ;)","rainbow")
                if (c.SANDBOX) {
                    [
                        "Press \"p\" to change to basic again",
                        "To get people to join your room, send them your party link!",
                        "Welcome to sandbox! Hold N to level up."
                    ].forEach(body.sendMessage);
                }else{
                    body.sendMessage(`Current Mode : ` + c.serverName);
                    if (c.serverName.includes("Boss Rush")) {body.sendMessage("Current Wave: " + room.bossRushWave + " INFERNUM: " + room.infernumCoef + " MODE: " + c.SMODE)}
                    if(!c.INCONITO) {
                        if (!c.TOURNEY) {//tourney
                        body.sendMessage("You have spawned! Welcome to Eternia!","rainbow")
                        body.sendMessage("Type \"/help\" to get a list of commands")
                        } else {
                            body.sendMessage("You have spawned! Welcome to the tournament!",'rainbow')
                        }
                    } else {body.sendMessage("A World Of Magic Is Always A World Of Mysteries...")}
                    /*body.sendMessage("Testing mode : everyone have lvl 4!","rainbow"); //testing mode here 123456789 rapelle-toi de commentary les 2 lignes ici
                    this.betaData.permissions = 4*/
                    if(c.FreeLevel) {body.sendMessage("In This Server, You Have A Free Level " + c.FreeLevel + "!" , "rainbow") , this.betaData.permissions = c.FreeLevel}
                    if (c.serverName.includes("Score War")) {body.sendMessage("Welcome To Agglomeration! Return To Your Base To Store Score! Have Fun!",'rainbow')
                    body.sendMessage("You Can See The Shop Via /shop & Buy Team Upgrades With /buy!","rainbow")
                    if (c.SMODE == "TowerDef") {body.sendMessage("Input /place in chat to buy turrets!")}
                }
                }
                this.talk("c", this.camera.x, this.camera.y, this.camera.fov);
                //views.forEach(view => view.add(body));
                let myTeam = Math.abs(body.team)
                if(myTeam == 1) {body.skill.points += room.BextraSkill} else {body.skill.points += room.RextraSkill}
                return player;
            }
        }

        const broadcast = (() => {
            let getBarColor = entry => {
                switch (entry.team) {
                    case -100:
                        return entry.color;
                    case -1:
                        return 10
                    case -2:
                        return 12
                    case -3:
                        return 11
                    case -4:
                        return 15
                    case -5:
                        return 3
                    case -6:
                        return 35;
                    case -20: // Rogue
                        return 17;
                    default:
                        if (room.gameMode[0] === '1' || room.gameMode[0] === '2' || room.gameMode[0] === '3' || room.gameMode[0] === '4') return entry.color;
                        return 11;
                }
            }
            global.newBroadcasting = function () {
                const counters = {
                    minimapAll: 0,
                    minimapTeams: {},
                    minimapSandboxes: {}
                };
                const output = {
                    minimapAll: [],
                    minimapTeams: {},
                    minimapSandboxes: {},
                    leaderboard: []
                };
                for (let i = 0; i < c.TEAM_AMOUNT; i++) {
                    output.minimapTeams[i + 1] = [];
                    counters.minimapTeams[i + 1] = 0;
                }
                for (let player of players) {
                    if (player.socket && player.socket.rememberedTeam) {
                        output.minimapTeams[-player.socket.rememberedTeam] = [];
                        counters.minimapTeams[-player.socket.rememberedTeam] = 0;
                    }
                }
                for (let room of global.sandboxRooms) {
                    output.minimapSandboxes[room.id] = [];
                    counters.minimapSandboxes[room.id] = 0;
                }

                if (c.serverName.includes("Tag") || c.SOCCER) {
                    for (let i = 0; i < c.TEAM_AMOUNT; i++) {
                        output.leaderboard.push({
                            id: i,
                            skill: {
                                score: c.SOCCER ? soccer.scoreboard[i] : 0,
                            },
                            index: c.SOCCER ? Class.soccerMode.index : Class.tagMode.index,
                            name: ["BLUE", "RED", "GREEN", "PURPLE"][i],
                            color: [10, 12, 11, 15][i] ?? 0,
                            nameColor: "#FFFFFF",
                            team: -i - 1,
                            label: 0
                        });
                    }
                }
                entities.forEach(my => {
                    if (my.type === "bullet" || my.type === "swarm" || my.type === "drone" || my.type === "minion" || my.type === "trap") {
                        return;
                    }
                    if (!my.isOutsideRoom && (((my.type === 'wall' || my.type === "mazeWall") && my.alpha > 0.2) || my.showsOnMap || my.type === 'miniboss' || (my.type === 'tank' && my.lifetime) || my.isMothership || my.miscIdentifier === "appearOnMinimap")) {
                        if (output.minimapSandboxes[my.sandboxId] != null) {
                            output.minimapSandboxes[my.sandboxId].push(
                                my.id,
                                (my.type === 'wall' || my.type === 'mazeWall') ? my.shape === 4 ? 2 : 1 : 0,
                                util.clamp(Math.floor(256 * my.x / room.width), 0, 255),
                                util.clamp(Math.floor(256 * my.y / room.height), 0, 255),
                                my.color ?? 0,
                                Math.round(my.SIZE),
                                my.width || 1,
                                my.height || 1
                            );
                            counters.minimapSandboxes[my.sandboxId]++;
                        } else {
                            output.minimapAll.push(
                                my.id,
                                (my.type === 'wall' || my.type === 'mazeWall') ? my.shape === 4 ? 2 : 1 : 0,
                                util.clamp(Math.floor(256 * my.x / room.width), 0, 255),
                                util.clamp(Math.floor(256 * my.y / room.height), 0, 255),
                                my.color ?? 0,
                                Math.round(my.SIZE),
                                my.width || 1,
                                my.height || 1
                            ); counters.minimapAll++;
                        }
                    }
                    if (my.type === 'tank' && my.master === my && !my.lifetime) {
                        if (output.minimapTeams[my.team] != null) {
                            output.minimapTeams[my.team].push(
                                my.id,
                                util.clamp(Math.floor(256 * my.x / room.width), 0, 255),
                                util.clamp(Math.floor(256 * my.y / room.height), 0, 255),
                                my.color ?? 0
                            );
                            counters.minimapTeams[my.team]++;
                        }
                    }
                    if (!c.SOCCER) {
                        if (c.serverName.includes("Mothership")) {
                            if (my.isMothership) {
                                output.leaderboard.push(my);
                            }
                        } else if (c.serverName.includes("Tag")) {
                            if (my.isPlayer || my.isBot) {
                                let entry = output.leaderboard.find(r => r.team === my.team);
                                if (entry) entry.skill.score++;
                            }
                        } else if (!c.DISABLE_LEADERBOARD && my.settings != null && my.settings.leaderboardable && my.settings.drawShape && (my.type === 'tank' || my.killCount.solo || my.killCount.assists)) {
                            output.leaderboard.push(my);
                        }
                    }
                });
                let topTen = [];
                for (let i = 0; i < 10 && output.leaderboard.length; i++) {
                    let top, is = 0
                    for (let j = 0; j < output.leaderboard.length; j++) {
                        let val = output.leaderboard[j].skill.score
                        if (val > is) {
                            is = val
                            top = j
                        }
                    }
                    if (is === 0) break
                    let entry = output.leaderboard[top];
                    topTen.push({
                        id: entry.id,
                        data: c.SANDBOX ? [
                            Math.round(c.serverName.includes("Mothership") ? entry.health.amount : entry.skill.score),
                            entry.index,
                            entry.name,
                            entry.color ?? 0,
                            getBarColor(entry) ?? 0,
                            entry.nameColor,
                            entry.labelOverride || 0,
                            entry.sandboxId || -1
                        ] : [
                            Math.round(c.serverName.includes("Mothership") ? entry.health.amount : entry.skill.score),
                            entry.index,
                            entry.name,
                            entry.color ?? 0,
                            getBarColor(entry) ?? 0,
                            entry.nameColor,
                            entry.labelOverride || 0
                        ]
                    });
                    output.leaderboard.splice(top, 1);
                }
                room.topPlayerID = topTen.length ? topTen[0].id : -1
                output.leaderboard = topTen.sort((a, b) => a.id - b.id);
                output.minimapAll = [counters.minimapAll, ...output.minimapAll];
                for (let team in output.minimapTeams) {
                    output.minimapTeams[team] = [counters.minimapTeams[team], ...output.minimapTeams[team]];
                }
                for (let team in output.minimapSandboxes) {
                    output.minimapSandboxes[team] = [counters.minimapSandboxes[team], ...output.minimapSandboxes[team]];
                }
                output.leaderboard = [output.leaderboard.length, ...output.leaderboard.map(entry => {
                    return [entry.id, ...entry.data];
                }).flat()];
                return output;
            }
            const slowLoop = () => {
                let time = util.time();
                for (let socket of clients)
                    if (time - socket.statuslastHeartbeat > c.maxHeartbeatInterval) socket.kick("Lost heartbeat!");
            };
            setInterval(slowLoop, 8000);

            function fastLoop() {
                //newLogs.broadcast.reset();
                //newLogs.broadcast.start();
                const data = global.newBroadcasting();
                for (const socket of clients) {
                    if (socket.status.hasSpawned) {
                        if (socket.battleRoom instanceof RankedRoom) {
                            socket.talk("b", ...socket.battleRoom.minimap, 0, ...socket.battleRoom.leaderboard);
                        } else if (c.SANDBOX && data.minimapSandboxes[socket.sandboxId] != null) {
                            socket.talk("b", ...data.minimapSandboxes[socket.sandboxId], 0, ...data.leaderboard);
                        } else {
                            let myTeam = data.minimapTeams[-socket.player.team];
                            socket.talk("b", ...data.minimapAll, ...(myTeam ? myTeam : [0]), ...data.leaderboard);
                        }
                    }
                }
                //newLogs.broadcast.stop();
            }
            setInterval(fastLoop, 1000);
        })();
        return {
            talkToAll: function(){
                for(let socket of clients){
                    socket.talk(...arguments)
                }
            },
            broadcast: (message, color = "") => {
                for (let socket of clients) socket.talk("m", message, color);
            },
            broadcastRoom: () => {
                for (let socket of clients) socket.talk("r", room.width, room.height, JSON.stringify(c.ROOM_SETUP));
            },
            connect: async (playerId) => new SocketUser(playerId),
            ban: (id, reason, setMessage = "") => {
                let client;
                if (client = clients.find(r => r.id === id), client instanceof SocketUser) {
                    if (setMessage.length) {
                        client.talk("P", setMessage);
                    }
                    client.ban(reason);
                    return true;
                }
                if (client = backlog.find(r => r.id === id), client instanceof BacklogData) {
                    bans.push({
                        ip: client.ip,
                        reason: reason
                    });
                    return true;
                }
                return false;
            },
            unban: id => {
                let client = backlog.find(r => r.id === id);
                if (client instanceof BacklogData) {
                    let index = bans.findIndex(ban => ban.ip === client.ip);
                    if (index > -1) {
                        bans.splice(index, 1);
                        return true;
                    }
                }
                return false;
            }
        }
    })();
    workerWindow.sockets = sockets

    function blendColors(colorA, colorB, amount) {
        const [rA, gA, bA] = colorA.match(/\w\w/g).map((c) => parseInt(c, 16));
        const [rB, gB, bB] = colorB.match(/\w\w/g).map((c) => parseInt(c, 16));
        const r = Math.round(rA + (rB - rA) * amount).toString(16).padStart(2, '0');
        const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');
        const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');
        return '#' + r + g + b;
      }
      function numberLocation(x, range) {
            const [min, max] = range;
            
            if (min === max) return 0.5;
            
            return (x - min) / (max - min);
        }
    /*function blend3Colors(colorA, colorB, colorC, amount) {
        const [rA, gA, bA] = colorA.match(/\w\w/g).map((c) => parseInt(c, 16));
        const [rB, gB, bB] = colorB.match(/\w\w/g).map((c) => parseInt(c, 16));
        const [rC, gC, bC] = colorC.match(/\w\w/g).map((c) => parseInt(c, 16));
        const r = Math.round(Math.round(rA + ((rB - rA) + (rA - rB -rC))) * amount).toString(16).padStart(2, '0');
        const g = Math.round(gA + (gB - gA) * amount).toString(16).padStart(2, '0');
        const b = Math.round(bA + (bB - bA) * amount).toString(16).padStart(2, '0');
        return '#' + r + g + b;
      }*/
    const gameLoop = (() => {
        const collide = (() => {
            if (c.NEW_COLLISIONS) {
                function bounce(instance, other, doDamage, doMotion) {
                    let dist = Math.max(1, util.getDistance(instance, other));
                    if (dist > instance.realSize + other.realSize) {
                        return;
                    }
                    instance.collisionArray.push(other);
                    other.collisionArray.push(instance);
                    if (doMotion) {
                        //newLogs.doMotion.start();
                        let angle = Math.atan2(instance.y - other.y, instance.x - other.x),
                            cos = Math.cos(angle),
                            sin = Math.sin(angle),
                            distanceFactor = (instance.realSize * other.realSize) * (instance.realSize * other.realSize),
                            pushFactor = ((distanceFactor / dist) / distanceFactor) * Math.sqrt(distanceFactor / 3) / Math.max(instance.mass / other.mass, other.mass / instance.armySentrySwarmAI);
                        instance.accel.x += cos * pushFactor * instance.pushability;
                        instance.accel.y += sin * pushFactor * instance.pushability;
                        other.accel.x -= cos * pushFactor * other.pushability;
                        other.accel.y -= sin * pushFactor * other.pushability;
                        //newLogs.doMotion.stop();
                    }
                    if (doDamage) {
                        //newLogs.doDamage.start();
                        let tock = Math.min(instance.stepRemaining, other.stepRemaining),
                            combinedRadius = other.size + instance.size,
                            motion = {
                                instance: new Vector(instance.m_x, instance.m_y),
                                other: new Vector(other.m_x, other.m_y)
                            },
                            delt = new Vector(tock * (motion.instance.x - motion.other.x), tock * (motion.instance.y - motion.other.y)),
                            diff = new Vector(instance.x - other.x, instance.y - other.y),
                            dir = new Vector(other.x - instance.x, other.y - instance.y).unit(),
                            component = Math.max(0, dir.x * delt.x + dir.y * delt.y), componentNorm = component / delt.length,
                            deathFactor = {
                                instance: 1,
                                other: 1
                            },
                            depth = {
                                instance: util.clamp((combinedRadius - diff.length) / (2 * instance.size), 0, 1),
                                other: util.clamp((combinedRadius - diff.length) / (2 * other.size), 0, 1)
                            },
                            pen = {
                                instance: {
                                    sqr: Math.pow(instance.penetration, 2),
                                    sqrt: Math.sqrt(instance.penetration)
                                },
                                other: {
                                    sqr: Math.pow(other.penetration, 2),
                                    sqrt: Math.sqrt(other.penetration)
                                }
                            },
                            speedFactor = {
                                instance: instance.maxSpeed ? Math.pow(motion.instance.length / instance.maxSpeed, .25) : 1,
                                other: other.maxSpeed ? Math.pow(motion.other.length / other.maxSpeed, .25) : 1
                            };

                        if (!Number.isFinite(speedFactor.instance)) speedFactor.instance = 1;
                        if (!Number.isFinite(speedFactor.other)) speedFactor.other = 1;

                        let resistDiff = instance.health.resist - other.health.resist,
                            damage = {
                                instance: c.DAMAGE_CONSTANT * instance.damage * (1 + resistDiff) * (1 + other.heteroMultiplier * (instance.settings.damageClass === other.settings.damageClass)) * ((instance.settings.buffVsFood && other.settings.damageType === 1) ? 3 : 1) * instance.damageMultiplier() * Math.min(2, Math.max(speedFactor.instance, 1) * speedFactor.instance),
                                other: c.DAMAGE_CONSTANT * other.damage * (1 - resistDiff) * (1 + instance.heteroMultiplier * (instance.settings.damageClass === other.settings.damageClass)) * ((other.settings.buffVsFood && instance.settings.damageType === 1) ? 3 : 1) * other.damageMultiplier() * Math.min(2, Math.max(speedFactor.other, 1) * speedFactor.other)
                            };
                        if (instance.settings.ratioEffects) damage.instance *= Math.min(1, Math.pow(Math.max(instance.health.ratio, instance.shield.ratio), 1 / instance.penetration));
                        if (other.settings.ratioEffects) damage.other *= Math.min(1, Math.pow(Math.max(other.health.ratio, other.shield.ratio), 1 / other.penetration));
                        if (instance.settings.damageEffects) damage.instance *= (1 + (componentNorm - 1) * (1 - depth.other) / instance.penetration) * (1 + pen.other.sqrt * depth.other - depth.other) / pen.other.sqrt;
                        if (other.settings.damageEffects) damage.other *= (1 + (componentNorm - 1) * (1 - depth.instance) / other.penetration) * (1 + pen.instance.sqrt * depth.instance - depth.instance) / pen.instance.sqrt;
                        if (!Number.isFinite(damage.instance)) damage.instance = 1;
                        if (!Number.isFinite(damage.other)) damage.other = 1;
                        let damageToApply = {
                            instance: damage.instance * (instance.force * 12),
                            other: damage.other * (other.force * 12)
                        };
                        let stuff = instance.health.getDamage(damageToApply.other, false);
                        deathFactor.instance = stuff > instance.health.amount ? instance.health.amount / stuff : 1;
                        stuff = other.health.getDamage(damageToApply.instance, false);
                        deathFactor.other = stuff > other.health.amount ? other.health.amount / stuff : 1;
                        instance.damageReceived += damage.other * deathFactor.other;
                        other.damageReceived += damage.instance * deathFactor.instance;
                        //newLogs.doDamage.stop();
                    }
                }
                return function (instance, other) {
                    if (
                        // Ghost busting
                        instance.isGhost || other.isGhost ||
                        // Passive bullshit
                        instance.passive || other.passive ||
                        // Passive bullshit
                        instance.isObserver || other.isObserver ||
                        // Inactive should be ignored
                        !instance.isActive || !other.isActive ||
                        // Multi-Room mechanics
                        (c.RANKED_BATTLE && instance.roomId !== other.roomId) ||
                        (c.SANDBOX && instance.sandboxId !== other.sandboxId) ||
                        // Forced no collision
                        instance.settings.hitsOwnType === "forcedNever" || other.settings.hitsOwnType === "forcedNever" ||
                        // Same master collisions
                        instance.master === other || other.master === instance ||
                        //Auras
                        (instance.isRealAura && (other.type === "bullet" || other.type === "swarm" || other.type === "drone" || other.type === "minion" || other.type === "trap")) ||
                        (other.isRealAura && (instance.type === "bullet" || instance.type === "swarm" || instance.type === "drone" || instance.type === "minion" || instance.type === "trap")) ||
                        (instance.doesNotCollideWithSource == true && (instance.source == other)) ||
                        (other.doesNotCollideWithSource == true && (other.source == instance))
                    ) {
                        return;
                    }
                    let doDamage = instance.team !== other.team,
                        doMotion = true;
                    bounce(instance, other, doDamage, doMotion);
                }
            }
            // Collision Functions
            function simpleCollide(my, n) {
                let diff = (1 + util.getDistance(my, n) / 2) * room.speed;
                let a = (my.intangibility) ? 1 : my.pushability,
                    b = (n.intangibility) ? 1 : n.pushability,
                    c = 0.05 * (my.x - n.x) / diff,
                    d = 0.05 * (my.y - n.y) / diff;
                my.accel.x += a / (b + 0.3) * c;
                my.accel.y += a / (b + 0.3) * d;
                n.accel.x -= b / (a + 0.3) * c;
                n.accel.y -= b / (a + 0.3) * d;
            }
            /*const firmCollide = (my, n, buffer = 0) => {
                let item1 = {
                    x: my.x + my.m_x,
                    y: my.y + my.m_y
                },
                    item2 = {
                        x: n.x + n.m_x,
                        y: n.y + n.m_y
                    },
                    dist = util.getDistance(item1, item2),
                    s1 = Math.max(my.velocity.length, my.topSpeed),
                    s2 = Math.max(n.velocity.length, n.topSpeed),
                    strike1,
                    strike2;
                if (dist === 0) {
                    let oops = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
                    my.accel.x += oops.x;
                    my.accel.y += oops.y;
                    n.accel.x -= oops.x;
                    n.accel.y -= oops.y;
                    return;
                }
                if (buffer > 0 && dist <= my.realSize + n.realSize + buffer) {
                    let repel = (my.acceleration + n.acceleration) * (my.realSize + n.realSize + buffer - dist) / buffer / room.speed;
                    my.accel.x += repel * (item1.x - item2.x) / dist;
                    my.accel.y += repel * (item1.y - item2.y) / dist;
                    n.accel.x -= repel * (item1.x - item2.x) / dist;
                    n.accel.y -= repel * (item1.y - item2.y) / dist;
                }
                while (dist <= my.realSize + n.realSize && !(strike1 && strike2)) {
                    strike2 = strike1 = false;
                    if (my.velocity.length <= s1) {
                        my.velocity.x -= .05 * (item2.x - item1.x) / dist / room.speed;
                        my.velocity.y -= .05 * (item2.y - item1.y) / dist / room.speed;
                    } else strike1 = true;
                    if (n.velocity.length <= s2) {
                        n.velocity.x += .05 * (item2.x - item1.x) / dist / room.speed;
                        n.velocity.y += .05 * (item2.y - item1.y) / dist / room.speed;
                    } else strike2 = true;
                    item1 = {
                        x: my.x + my.m_x,
                        y: my.y + my.m_y
                    };
                    item2 = {
                        x: n.x + n.m_x,
                        y: n.y + n.m_y
                    };
                    dist = util.getDistance(item1, item2);
                }
            };*/
            function shieldCollide(shield, entity) {
                let dx = entity.x - shield.x;
                let dy = entity.y - shield.y;
                let sum = entity.size + (shield.size);
                let length = Math.sqrt(dx * dx + dy * dy);
                let ux = dx / length;
                let uy = dy / length;

                entity.x = shield.x + (sum + 1) * ux;
                entity.y = shield.y + (sum + 1) * uy;

                //entity.accel.null();
                entity.velocity.x += (sum) * ux * .05 * (entity.force * .00007);
                entity.velocity.y += (sum) * uy * .05 * (entity.force * .00007);
                shield.source.velocity.x -= ((sum) * ux * .05) / 2 * (entity.force * .00007);
                shield.source.velocity.y -= ((sum) * uy * .05) / 2 * (entity.force * .00007);
                if (entity.hitsOwnType === 'shield') {
                   entity.accel.null();
                   shield.source.accel.null();
                }
            }

            function firmCollide(instance, other, buffer = 0) {
                let dist = util.getDistance(instance, other);
                if (dist <= instance.size + other.size + buffer + 2) {
                    let diff = (1 + dist) * room.speed,
                        instanceSizeRatio = util.clamp(instance.size / other.size, .25, 1.5),//(instance.size + other.size),
                        otherSizeRatio = util.clamp(other.size / instance.size, .25, 1.5),//(instance.size + other.size),
                        instancePushFactor = (instance.intangibility) ? 1 : instance.pushability * otherSizeRatio,
                        otherPushFactor = (other.intangibility) ? 1 : other.pushability * instanceSizeRatio,
                        xDiffStrength = 5 * (instance.x - other.x) / diff,
                        yDiffStrength = 5 * (instance.y - other.y) / diff;
                    instance.accel.x += instancePushFactor / (otherPushFactor + .3) * xDiffStrength;
                    instance.accel.y += instancePushFactor / (otherPushFactor + .3) * yDiffStrength;
                    other.accel.x -= otherPushFactor / (instancePushFactor + .3) * xDiffStrength;
                    other.accel.y -= otherPushFactor / (instancePushFactor + .3) * yDiffStrength;
                }

                /*let angle = Math.atan2(other.y - instance.y, other.x - instance.x);
                other.x = instance.x + Math.cos(angle) * dist;
                other.y = instance.y + Math.sin(angle) * dist;*/
            }
            /*function firmCollide(my, n, buffer = 0) {
                let item1 = {
                    x: my.x + my.m_x,
                    y: my.y + my.m_y,
                };
                let item2 = {
                    x: n.x + n.m_x,
                    y: n.y + n.m_y,
                };
                let dist = util.getDistance(item1, item2);
                let s1 = Math.max(my.velocity.length, my.topSpeed);
                let s2 = Math.max(n.velocity.length, n.topSpeed);
                let strike1, strike2, t = 5;
                if (buffer > 0 && dist <= my.realSize + n.realSize + buffer) {
                    let repel = (my.acceleration + n.acceleration) * (my.realSize + n.realSize + buffer - dist) / buffer / room.speed;
                    my.accel.x += repel * (item1.x - item2.x) / dist;
                    my.accel.y += repel * (item1.y - item2.y) / dist;
                    n.accel.x -= repel * (item1.x - item2.x) / dist;
                    n.accel.y -= repel * (item1.y - item2.y) / dist;
                }
                while (dist <= my.realSize + n.realSize && !(strike1 && strike2) && t > 0) {
                    t --;
                    strike1 = false;
                    strike2 = false;
                    if (my.velocity.length <= s1) {
                        my.velocity.x -= 0.05 * (item2.x - item1.x) / dist / room.speed;
                        my.velocity.y -= 0.05 * (item2.y - item1.y) / dist / room.speed;
                    } else {
                        strike1 = true;
                    }
                    if (n.velocity.length <= s2) {
                        n.velocity.x += 0.05 * (item2.x - item1.x) / dist / room.speed;
                        n.velocity.y += 0.05 * (item2.y - item1.y) / dist / room.speed;
                    } else {
                        strike2 = true;
                    }
                    item1 = {
                        x: my.x + my.m_x,
                        y: my.y + my.m_y,
                    };
                    item2 = {
                        x: n.x + n.m_x,
                        y: n.y + n.m_y,
                    };
                    dist = util.getDistance(item1, item2);
                }
            }*/
            function spikeCollide(my, n) {
                let diff = (1 + util.getDistance(my, n) / 2) * room.speed;
                let a = (my.intangibility) ? 1 : my.pushability,
                    b = (n.intangibility) ? 1 : n.pushability,
                    c = 15 * (my.x - n.x) / diff,
                    d = 15 * (my.y - n.y) / diff,
                    e = Math.min(my.velocity.length, 3),
                    f = Math.min(n.velocity.length, 3);
                my.accel.x += a / (b + 0.3) * c * e;
                my.accel.y += a / (b + 0.3) * d * e;
                n.accel.x -= b / (a + 0.3) * c * f;
                n.accel.y -= b / (a + 0.3) * d * f;
            }
            const advancedCollide = (my, n, doDamage, doInelastic, nIsFirmCollide = false) => {
                let tock = Math.min(my.stepRemaining, n.stepRemaining),
                    combinedRadius = n.size + my.size,
                    motion = {
                        _me: new Vector(my.m_x, my.m_y),
                        _n: new Vector(n.m_x, n.m_y)
                    },
                    delt = new Vector(tock * (motion._me.x - motion._n.x), tock * (motion._me.y - motion._n.y)),
                    diff = new Vector(my.x - n.x, my.y - n.y),
                    dir = new Vector(n.x - my.x, n.y - my.y).unit(),
                    component = Math.max(0, dir.x * delt.x + dir.y * delt.y);
                if (component >= diff.length - combinedRadius) {
                    let goAhead = false,
                        tmin = 1 - tock,
                        //tmax = 1,
                        A = Math.pow(delt.x, 2) + Math.pow(delt.y, 2),
                        B = 2 * delt.x * diff.x + 2 * delt.y * diff.y,
                        C = Math.pow(diff.x, 2) + Math.pow(diff.y, 2) - Math.pow(combinedRadius, 2),
                        det = B * B - (4 * A * C),
                        t;
                    if (!A || det < 0 || C < 0) {
                        t = 0;
                        if (C < 0) goAhead = true;
                    } else {
                        let t1 = (-B - Math.sqrt(det)) / (2 * A),
                            t2 = (-B + Math.sqrt(det)) / (2 * A);
                        if (t1 < tmin || t1 > 1) {
                            if (t2 < tmin || t2 > 1) t = false;
                            else {
                                t = t2;
                                goAhead = true;
                            }
                        } else {
                            if (t2 >= tmin && t2 <= 1) t = Math.min(t1, t2);
                            else t = t1;
                            goAhead = true;
                        }
                    }
                    if (goAhead) {
                        my.collisionArray.push(n);
                        n.collisionArray.push(my);
                        if (t) {
                            my.x += motion._me.x * t;
                            my.y += motion._me.y * t;
                            n.x += motion._n.x * t;
                            n.y += motion._n.y * t;
                            my.stepRemaining -= t;
                            n.stepRemaining -= t;
                            diff = new Vector(my.x - n.x, my.y - n.y);
                            dir = new Vector(n.x - my.x, n.y - my.y).unit();
                            component = Math.max(0, dir.x * delt.x + dir.y * delt.y);
                        }
                        let componentNorm = component / delt.length,
                            deathFactor = {
                                _me: 1,
                                _n: 1
                            },
                            depth = {
                                _me: util.clamp((combinedRadius - diff.length) / (2 * my.size), 0, 1),
                                _n: util.clamp((combinedRadius - diff.length) / (2 * n.size), 0, 1)
                            },
                            combinedDepth = {
                                up: depth._me * depth._n,
                                down: (1 - depth._me) * (1 - depth._n)
                            },
                            pen = {
                                _me: {
                                    sqr: Math.pow(my.penetration, 2),
                                    sqrt: Math.sqrt(my.penetration)
                                },
                                _n: {
                                    sqr: Math.pow(n.penetration, 2),
                                    sqrt: Math.sqrt(n.penetration)
                                }
                            },
                            savedHealthRatio = {
                                _me: my.health.ratio,
                                _n: n.health.ratio
                            };
                        if (doDamage) {
                            let speedFactor = {
                                _me: my.maxSpeed ? Math.pow(motion._me.length / my.maxSpeed, .25) : 1,
                                _n: n.maxSpeed ? Math.pow(motion._n.length / n.maxSpeed, .25) : 1
                            };
                            if (!Number.isFinite(speedFactor._me)) speedFactor._me = 1;
                            if (!Number.isFinite(speedFactor._n)) speedFactor._n = 1;

                            let resistDiff = my.health.resist - n.health.resist,
                                damage = {
                                    _me: c.DAMAGE_CONSTANT * my.damage * (1 + resistDiff) * (1 + n.heteroMultiplier * (my.settings.damageClass === n.settings.damageClass)) * ((my.settings.buffVsFood && n.settings.damageType === 1) ? 3 : 1) * my.damageMultiplier(), //Math.min(2, 1),
                                    _n: c.DAMAGE_CONSTANT * n.damage * (1 - resistDiff) * (1 + my.heteroMultiplier * (my.settings.damageClass === n.settings.damageClass)) * ((n.settings.buffVsFood && my.settings.damageType === 1) ? 3 : 1) * n.damageMultiplier() //Math.min(2, 1)
                                };

                            if (!my.settings.speedNoEffect) {
                                damage._me *= Math.min(2, Math.max(speedFactor._me, 1) * speedFactor._me);
                            }

                            if (!n.settings.speedNoEffect) {
                                damage._n *= Math.min(2, Math.max(speedFactor._n, 1) * speedFactor._n);
                            }

                            if (my.settings.ratioEffects) damage._me *= Math.min(1, Math.pow(Math.max(my.health.ratio, my.shield.ratio), 1 / my.penetration));
                            if (n.settings.ratioEffects) damage._n *= Math.min(1, Math.pow(Math.max(n.health.ratio, n.shield.ratio), 1 / n.penetration));
                            if (my.settings.damageEffects) damage._me *= (1 + (componentNorm - 1) * (1 - depth._n) / my.penetration) * (1 + pen._n.sqrt * depth._n - depth._n) / pen._n.sqrt;
                            if (n.settings.damageEffects) damage._n *= (1 + (componentNorm - 1) * (1 - depth._me) / n.penetration) * (1 + pen._me.sqrt * depth._me - depth._me) / pen._me.sqrt;
                            let damageToApply = {
                                _me: damage._me,
                                _n: damage._n
                            };

                            if (!Number.isFinite(damageToApply._me)) {
                                damageToApply._me = 1;
                            }
                            if (!Number.isFinite(damageToApply._n)) {
                                damageToApply._n = 1;
                            }
                            if (n.shield.max) damageToApply._me -= n.shield.getDamage(damageToApply._me);
                            if (my.shield.max) damageToApply._n -= my.shield.getDamage(damageToApply._n);
                            let stuff = my.health.getDamage(damageToApply._n, false);
                            deathFactor._me = stuff > my.health.amount ? my.health.amount / stuff : 1;
                            stuff = n.health.getDamage(damageToApply._me, false);
                            deathFactor._n = stuff > n.health.amount ? n.health.amount / stuff : 1;
                            let finalDmg = {
                                my: damage._n * deathFactor._n,
                                n: damage._me * deathFactor._me
                            };
                            if (n.hitsOwnTeam /*&& !n.label.includes("Sanctuary")*/) {
                                finalDmg.my *= -1;
                            }
                            if (my.hitsOwnTeam/* && !my.label.includes("Sanctuary")*/) {
                                finalDmg.n *= -1;
                            }
                            my.damageReceived += finalDmg.my;
                            n.damageReceived += finalDmg.n;

                            if (my.onDamaged) {
                                my.onDamaged(my, n, finalDmg.my);
                            }
                            if (my.onDealtDamage) {
                                my.onDealtDamage(my, n, finalDmg.n);
                            }
                            if (my.onDealtDamageUniv) {
                                my.onDealtDamageUniv(my, n, finalDmg.n);
                            }
                            if (my.master && my.master.onDealtDamageUniv) {
                                my.master.onDealtDamageUniv(my.master, n, finalDmg.n);
                            }
                            if (n.onDamaged) {
                                n.onDamaged(n, my, finalDmg.n);
                            }
                            if (n.onDealtDamage) {
                                n.onDealtDamage(n, my, finalDmg.my);
                            }
                            if (n.onDealtDamageUniv) {
                                n.onDealtDamageUniv(n, my, finalDmg.my);
                            }
                            if (n.master && n.master.onDealtDamageUniv) {
                                n.master.onDealtDamageUniv(n.master, my, finalDmg.my);
                            }
                        }
                        if (nIsFirmCollide < 0) {
                            nIsFirmCollide *= -.5;
                            my.accel.x -= nIsFirmCollide * component * dir.x;
                            my.accel.y -= nIsFirmCollide * component * dir.y;
                            n.accel.x += nIsFirmCollide * component * dir.x;
                            n.accel.y += nIsFirmCollide * component * dir.y;
                        } else if (nIsFirmCollide > 0) {
                            n.accel.x += nIsFirmCollide * (component * dir.x + combinedDepth.up);
                            n.accel.y += nIsFirmCollide * (component * dir.y + combinedDepth.up);
                        } else {
                            let elasticity = 2 - 4 * Math.atan(my.penetration * n.penetration) / Math.PI;
                            if (doInelastic && my.settings.motionEffects && n.settings.motionEffects) elasticity *= savedHealthRatio._me / pen._me.sqrt + savedHealthRatio._n / pen._n.sqrt;
                            else elasticity *= 2;
                            let spring = 2 * Math.sqrt(savedHealthRatio._me * savedHealthRatio._n) / room.speed,
                                elasticImpulse = Math.pow(combinedDepth.down, 2) * elasticity * component * my.mass * n.mass / (my.mass + n.mass),
                                springImpulse = c.KNOCKBACK_CONSTANT * spring * combinedDepth.up,
                                impulse = -(elasticImpulse + springImpulse) * (1 - my.intangibility) * (1 - n.intangibility),
                                force = {
                                    x: impulse * dir.x,
                                    y: impulse * dir.y
                                },
                                modifiers = {
                                    _me: c.KNOCKBACK_CONSTANT * my.pushability / my.mass * deathFactor._n * 0.6,
                                    _n: c.KNOCKBACK_CONSTANT * n.pushability / n.mass * deathFactor._me * 0.6
                                };
                            my.accel.x += modifiers._me * force.x;
                            my.accel.y += modifiers._me * force.y;
                            n.accel.x -= modifiers._n * force.x;
                            n.accel.y -= modifiers._n * force.y;
                        }
                    }
                }
            };
            /*const reflectCollide = (wall, bounce) => {
                const width = wall.width ? wall.size * wall.width : wall.size;
                const height = wall.height ? wall.size * wall.height : wall.size;
                if (bounce.x + bounce.size < wall.x - width || bounce.x - bounce.size > wall.x + width || bounce.y + bounce.size < wall.y - height || bounce.y - bounce.size > wall.y + height) return 0;
                if (wall.intangibility || bounce.type === "crasher") return 0
                let bounceBy = bounce.type === "tank" ? .65 : bounce.type === "food" || bounce.type === "crasher" ? .8 : bounce.type === "miniboss" ? .85 : .35;
                let left = bounce.x < wall.x - width;
                let right = bounce.x > wall.x + width;
                let top = bounce.y < wall.y - height;
                let bottom = bounce.y > wall.y + height;
                let leftExposed = bounce.x - bounce.size < wall.x - width;
                let rightExposed = bounce.x + bounce.size > wall.x + width;
                let topExposed = bounce.y - bounce.size < wall.y - height;
                let bottomExposed = bounce.y + bounce.size > wall.y + height;
                let x = leftExposed ? -width : rightExposed ? width : 0;
                let y = topExposed ? -wall.size : bottomExposed ? height : 0;
                let point = new Vector(wall.x + x - bounce.x, wall.y + y - bounce.y);
                let intersected = true;
                if (left && right) {
                    left = right = false;
                }
                if (top && bottom) {
                    top = bottom = false;
                }
                if (leftExposed && rightExposed) {
                    leftExposed = rightExposed = false;
                }
                if (topExposed && bottomExposed) {
                    topExposed = bottomExposed = false;
                }
                if ((left && !top && !bottom) || (leftExposed && !topExposed && !bottomExposed)) {
                    //bounce.accel.x -= (bounce.x + bounce.size - wall.x + width) * bounceBy;
                    if (bounce.accel.x > 0) {
                        bounce.accel.x = 0;
                        bounce.velocity.x = 0;
                    }
                    bounce.x = wall.x - width - bounce.size;
                } else if ((right && !top && !bottom) || (rightExposed && !topExposed && !bottomExposed)) {
                    //bounce.accel.x -= (bounce.x - bounce.size - wall.x - width) * bounceBy;
                    if (bounce.accel.x < 0) {
                        bounce.accel.x = 0;
                        bounce.velocity.x = 0;
                    }
                    bounce.x = wall.x + width + bounce.size;
                } else if ((top && !left && !right) || (topExposed && !leftExposed && !rightExposed)) {
                    //bounce.accel.y -= (bounce.y + bounce.size - wall.y + height) * bounceBy;
                    if (bounce.accel.y > 0) {
                        bounce.accel.y = 0;
                        bounce.velocity.y = 0;
                    }
                    bounce.y = wall.y - height - bounce.size;
                } else if ((bottom && !left && !right) || (bottomExposed && !leftExposed && !rightExposed)) {
                    //bounce.accel.y -= (bounce.y - bounce.size - wall.y - height) * bounceBy;
                    if (bounce.accel.y < 0) {
                        bounce.accel.y = 0;
                        bounce.velocity.y = 0;
                    }
                    bounce.y = wall.y + height + bounce.size;
                } else {
                    if (!x || !y) {
                        if (bounce.x + bounce.y < wall.x + wall.y) { // top left
                            if (bounce.x - bounce.y < wall.x - wall.y) { // bottom left
                                //bounce.accel.x -= (bounce.x + bounce.size - wall.x + width) * bounceBy;
                                if (bounce.accel.x > 0) {
                                    bounce.accel.x = 0;
                                    bounce.velocity.x = 0;
                                }
                                bounce.x = wall.x - width - bounce.size;
                            } else { // top right
                                //bounce.accel.y -= (bounce.y + bounce.size - wall.y + height) * bounceBy;
                                if (bounce.accel.y > 0) {
                                    bounce.accel.y = 0;
                                    bounce.velocity.y = 0;
                                }
                                bounce.y = wall.y - height - bounce.size;
                            }
                        } else { // bottom right
                            if (bounce.x - bounce.y < wall.x - wall.y) { // bottom left
                                //bounce.accel.y -= (bounce.y - bounce.size - wall.y - height) * bounceBy;
                                if (bounce.accel.y < 0) {
                                    bounce.accel.y = 0;
                                    bounce.velocity.y = 0;
                                }
                                bounce.y = wall.y + height + bounce.size;
                            } else { // top right
                                //bounce.accel.x -= (bounce.x - bounce.size - wall.x - width) * bounceBy;
                                if (bounce.accel.x < 0) {
                                    bounce.accel.x = 0;
                                    bounce.velocity.x = 0;
                                }
                                bounce.x = wall.x + width + bounce.size;
                            }
                        }
                    } else if (point.isShorterThan(bounce.size) || !(left || right || top || bottom)) { } else {
                        intersected = false;
                    }
                }
                if (intersected) {
                    if (!bounce.godmode) {
                        if (!bounce.settings.bounceOnObstacles && (bounce.type === "bullet" || bounce.type === "swarm" || bounce.type === "trap" || (bounce.type === "food" && !bounce.isNestFood) || bounce.type === "minion" || bounce.type === "drone")) {
                            bounce.kill();
                        } else {
                            room.wallCollisions.push({
                                id: bounce.id,
                                justForceIt: !(left || right || top || bottom) || point.isShorterThan(bounce.size),
                                left: (left && !top && !bottom) || (leftExposed && !topExposed && !bottomExposed),
                                right: (right && !top && !bottom) || (rightExposed && !topExposed && !bottomExposed),
                                top: (top && !left && !right) || (topExposed && !leftExposed && !rightExposed),
                                bottom: (bottom && !left && !right) || (bottomExposed && !leftExposed && !rightExposed)
                            });
                        }
                    }
                    bounce.collisionArray.push(wall);
                }
            };*/

            const rectWallCollide = (wall, bounce) => {
                const width = wall.width ? wall.size * wall.width : wall.size;
                const height = wall.height ? wall.size * wall.height : wall.size;
                //if (wall.intangibility || bounce.type === "crasher") return 0
                if (bounce.x + bounce.size < wall.x - width || bounce.x - bounce.size > wall.x + width || bounce.y + bounce.size < wall.y - height || bounce.y - bounce.size > wall.y + height) return 0;
                if (!bounce.settings.isHelicopter && !bounce.settings.goThruObstacle) {
                    //let bounceBy = bounce.type === "tank" ? .65 : bounce.type === "food" || bounce.type === "crasher" ? .8 : bounce.type === "miniboss" ? .85 : .35;
                    let left = bounce.x < wall.x - width;
                    let right = bounce.x > wall.x + width;
                    let top = bounce.y < wall.y - height;
                    let bottom = bounce.y > wall.y + height;
                    let leftExposed = bounce.x - bounce.size < wall.x - width;
                    let rightExposed = bounce.x + bounce.size > wall.x + width;
                    let topExposed = bounce.y - bounce.size < wall.y - height;
                    let bottomExposed = bounce.y + bounce.size > wall.y + height;
                    let x = leftExposed ? -width : rightExposed ? width : 0;
                    let y = topExposed ? -wall.size : bottomExposed ? height : 0;
                    let point = new Vector(wall.x + x - bounce.x, wall.y + y - bounce.y);
                    let intersected = true;
                    if (left && right) {
                        left = right = false;
                    }
                    if (top && bottom) {
                        top = bottom = false;
                    }
                    if (leftExposed && rightExposed) {
                        leftExposed = rightExposed = false;
                    }
                    if (topExposed && bottomExposed) {
                        topExposed = bottomExposed = false;
                    }
                    if ((left && !top && !bottom) || (leftExposed && !topExposed && !bottomExposed)) {
                        if (bounce.accel.x > 0) {
                            bounce.accel.x = 0;
                            bounce.velocity.x = 0;
                        }
                        bounce.x = wall.x - width - bounce.size;
                    } else if ((right && !top && !bottom) || (rightExposed && !topExposed && !bottomExposed)) {
                        if (bounce.accel.x < 0) {
                            bounce.accel.x = 0;
                            bounce.velocity.x = 0;
                        }
                        bounce.x = wall.x + width + bounce.size;
                    } else if ((top && !left && !right) || (topExposed && !leftExposed && !rightExposed)) {
                        if (bounce.accel.y > 0) {
                            bounce.accel.y = 0;
                            bounce.velocity.y = 0;
                        }
                        bounce.y = wall.y - height - bounce.size;
                    } else if ((bottom && !left && !right) || (bottomExposed && !leftExposed && !rightExposed)) {
                        if (bounce.accel.y < 0) {
                            bounce.accel.y = 0;
                            bounce.velocity.y = 0;
                        }
                        bounce.y = wall.y + height + bounce.size;
                    } else {
                        if (!x || !y) {
                            if (bounce.x + bounce.y < wall.x + wall.y) { // top left
                                if (bounce.x - bounce.y < wall.x - wall.y) { // bottom left
                                    if (bounce.accel.x > 0) {
                                        bounce.accel.x = 0;
                                        bounce.velocity.x = 0;
                                    }
                                    bounce.x = wall.x - width - bounce.size;
                                } else { // top right
                                    if (bounce.accel.y > 0) {
                                        bounce.accel.y = 0;
                                        bounce.velocity.y = 0;
                                    }
                                    bounce.y = wall.y - height - bounce.size;
                                }
                            } else { // bottom right
                                if (bounce.x - bounce.y < wall.x - wall.y) { // bottom left
                                    if (bounce.accel.y < 0) {
                                        bounce.accel.y = 0;
                                        bounce.velocity.y = 0;
                                    }
                                    bounce.y = wall.y + height + bounce.size;
                                } else { // top right
                                    if (bounce.accel.x < 0) {
                                        bounce.accel.x = 0;
                                        bounce.velocity.x = 0;
                                    }
                                    bounce.x = wall.x + width + bounce.size;
                                }
                            }
                        } else if (point.isShorterThan(bounce.size) || !(left || right || top || bottom)) { } else {
                            intersected = false;
                        }
                    }
                    if (intersected) {
                        if (!bounce.godmode) {
                            if (!bounce.settings.bounceOnObstacles && (bounce.type === "bullet" || bounce.type === "trap")) {
                                bounce.kill();
                            } else {
                                room.wallCollisions.push({
                                    id: bounce.id,
                                    justForceIt: !(left || right || top || bottom) || point.isShorterThan(bounce.size),
                                    left: (left && !top && !bottom) || (leftExposed && !topExposed && !bottomExposed),
                                    right: (right && !top && !bottom) || (rightExposed && !topExposed && !bottomExposed),
                                    top: (top && !left && !right) || (topExposed && !leftExposed && !rightExposed),
                                    bottom: (bottom && !left && !right) || (bottomExposed && !leftExposed && !rightExposed)
                                });
                            }
                        }
                        /*if (bounce.type !== "bullet" && bounce.type !== "drone" && bounce.type !== "minion" && bounce.type !== "swarm" && bounce.type !== "trap") {
                            if (bounce.collisionArray.some(body => body.type === "mazeWall") && util.getDistance(wall, bounce) < wall.size * 1.25) bounce.kill();
                        } else bounce.kill();*/
                        bounce.collisionArray.push(wall);
                    }
                } else {
                    if (!bounce.godmode && !bounce.passive && !bounce.invuln && !bounce.variables.up) {
                        if (!bounce.theGreatestPlan) {
                            bounce.rewardManager(-1, "the_greatest_plan");
                            bounce.theGreatestPlan = true;
                        }
                        if (bounce.hurtTimer == undefined) {
                          bounce.hurtTimer = 0
                        }
                        bounce.hurtTimer = (bounce.hurtTimer + 1) % 400
                        if (bounce.hurtTimer == 399) {
                           bounce.shield.amount -= (3 * bounce.health.amount / 4 + 1.5)
                           bounce.health.amount -= (bounce.health.amount / 2 + 3)
                           bounce.sendMessage("You can't stay there for a long period of time, be quick!", "red");
                        };
                        if (bounce.hurtTimer == 149 && bounce.variables.up) {
                           bounce.shield.amount -= (3 * bounce.health.amount / 4 + 1.5)
                           bounce.health.amount -= (bounce.health.amount / 2 + 3)
                           bounce.sendMessage("You can't stay there for a long period of time, be quick!", "red");
                        };
                        //bounce.health.amount -= 0.25;//severely nerfed but still
                        //bounce.shield.amount >= 0 ? bounce.shield.amount -= 0.1
                    }; 
                }; 
              }
            /*};*/

            /*
            const rectWallCollide = (wall, bounce) => {
                const width = wall.width ? wall.size * wall.width * 2 : wall.size * 2;
                const height = wall.height ? wall.size * wall.height * 2 : wall.size * 2;

                const diff_x = bounce.x - wall.x;
                const diff_y = bounce.y - wall.y;
                const av_width = (bounce.realSize * 2 + width) * 0.5;
                const av_height = (bounce.realSize * 2 + height) * 0.5;

                if (Math.abs(diff_x) > av_width || Math.abs(diff_y) > av_height) return;

                if (bounce.settings.isHelicopter) {
                    if (!bounce.godmode && !bounce.invuln) {
                        bounce.health.amount -= 1;
                    };
                } else {
                    if (Math.abs(diff_x / width) > Math.abs(diff_y / height)) {
                        if (diff_x < 0) {
                            bounce.x = wall.x - bounce.realSize - width * 0.5;
                            bounce.velocity.x = 0;
                            bounce.accel.x = Math.min(bounce.accel.x, 0);
                        } else {
                            bounce.x = wall.x + bounce.realSize + width * 0.5;
                            bounce.velocity.x = 0;
                            bounce.accel.x = Math.max(bounce.accel.x, 0);
                        }
                    } else {
                        if (diff_y < 0) {
                            bounce.y = wall.y - bounce.realSize - height * 0.5;
                            bounce.velocity.y = 0;
                            bounce.accel.y = Math.min(bounce.accel.y, 0);
                        } else {
                            bounce.y = wall.y + bounce.realSize + height * 0.5;
                            bounce.velocity.y = 0;
                            bounce.accel.y = Math.max(bounce.accel.y, 0);
                        }
                    }
    
                    if (!bounce.godmode && !bounce.settings.bounceOnObstacles && (bounce.type === "bullet" || bounce.type === "swarm" || bounce.type === "trap" || (bounce.type === "food" && !bounce.isNestFood) || bounce.type === "minion" || bounce.type === "drone")) {
                        bounce.kill();
                    } else room.wallCollisions.push({
                        id: bounce.id
                    });
                    bounce.collisionArray.push(wall);
                }
            }*/

            function moonCollide(moon, n) {
                let dx = moon.x - n.x,
                    dy = moon.y - n.y,
                    d2 = dx * dx + dy * dy,
                    totalRadius = moon.realSize + n.realSize;
                if (d2 > totalRadius * totalRadius) {
                    return;
                }
                let dist = Math.sqrt(d2),
                    sink = totalRadius - dist;
                dx /= dist;
                dy /= dist;
                n.accel.x -= dx * n.pushability * 0.05 * sink * room.speed;
                n.accel.y -= dy * n.pushability * 0.05 * sink * room.speed;
            }

            const growOnCollision = (instance, other) => {
                if (instance.SIZE >= other.SIZE) {
                    instance.SIZE += 7;
                    instance.HEALTH += 2;
                    instance.DAMAGE += 5;
                    other.kill();
                } else {
                    other.SIZE += 7;
                    other.HEALTH += 2;
                    other.DAMAGE += 5;
                    instance.kill();
                }
            };

            return (instance, other) => {
                if (
                    // Ghost busting
                    instance.isGhost || other.isGhost ||
                    // Passive bullshit
                    instance.passive || other.passive ||
                    // Passive bullshit
                    instance.isObserver || other.isObserver ||
                    // Inactive should be ignored
                    !instance.isActive || !other.isActive ||
                    // Multi-Room mechanics
                    (c.RANKED_BATTLE && instance.roomId !== other.roomId) ||
                    (c.SANDBOX && instance.sandboxId !== other.sandboxId) ||
                    // Forced no collision
                    instance.settings.hitsOwnType === "forcedNever" || other.settings.hitsOwnType === "forcedNever" ||
                    // Same master collisions
                    instance.master === other || other.master === instance ||
                    //Auras
                    (instance.isRealAura && (other.type === "bullet" || other.type === "swarm" || other.type === "drone" || other.type === "minion" || other.type === "trap")) ||
                    (other.isRealAura && (instance.type === "bullet" || instance.type === "swarm" || instance.type === "drone" || instance.type === "minion" || instance.type === "trap"))
                ) {
                    return;
                }

                if (instance.x === other.x && instance.y === other.y) {
                    instance.x += other.size;
                    instance.y += other.size;
                    other.x -= other.size;
                    other.y -= other.size;
                    return;
                }

                let isSameTeam = (instance.team === other.team);

                switch (true) {
                    // Passive mode collisions
                    case (instance.passive || other.passive): {
                        if (instance.passive && other.passive && instance.settings.hitsOwnType === other.settings.hitsOwnType) {
                            switch (instance.settings.hitsOwnType) {
                                case "mountain":
                                    if (instance.master.id === other.master.id) growOnCollision(instance, other);
                                case "push":
                                    if (instance.master.id === other.master.id) advancedCollide(instance, other, false, false);
                                    break;
                                case "hard":
                                    firmCollide(instance, other);
                                    break;
                                case "hardWithBuffer":
                                    if (instance.master.id === other.master.id) firmCollide(instance, other, 30);
                                    break;
                                case "hardOnlyDrones":
                                    if (instance.master.id === other.master.id) firmCollide(instance, other);
                                    break;
                                case "everything": //mine
                                    firmCollide(instance, other);
                                    break;
                            }
                        }
                    } break;
                    // Dominator/Mothership collisions
                    case (isSameTeam && (instance.settings.hitsOwnType === "pushOnlyTeam" || other.settings.hitsOwnType === "pushOnlyTeam")): {
                        if (instance.settings.hitsOwnType === other.settings.hitsOwnType) return;
                        let pusher = instance.settings.hitsOwnType === "pushOnlyTeam" ? instance : other,
                            entity = instance.settings.hitsOwnType === "pushOnlyTeam" ? other : instance;
                        if (entity.settings.goThruObstacle || entity.type !== "tank" || entity.settings.hitsOwnType === "never") return;
                        if (entity.settings.isHelicopter) {
                            if (!entity.godmode && !entity.invuln) {
                                if (!entity.theGreatestPlan) {
                                    entity.rewardManager(-1, "the_greatest_plan");
                                    entity.theGreatestPlan = true;
                                }
                            }
                            return;
                        }
                        let a = 1 + 10 / (Math.max(entity.velocity.length, pusher.velocity.length) + 10);
                        advancedCollide(pusher, entity, false, false, a);
                    } break;
                    // Normal Obstacle collisions
                    case (instance.type === "wall" || other.type === "wall"): {
                        let wall = instance.type === "wall" ? instance : other,
                            entity = instance.type === "wall" ? other : instance;
                        if (entity.settings.diesByObstacles) return entity.kill();
                        if (entity.settings.goThruObstacle || entity.settings.goThruRock || entity.type === "mazeWall" || entity.isDominator) return;
                        if (entity.settings.isHelicopter && !entity.godmode && !entity.invuln) {
                            if (!entity.theGreatestPlan) {
                                entity.rewardManager(-1, "the_greatest_plan");
                                entity.theGreatestPlan = true;
                            }
                            return;
                        }
                        let a = entity.type === "bullet" || entity.type === "trap" ? 1 + 10 / (Math.max(entity.velocity.length, wall.velocity.length) + 10) : 1;
                        wall.shape === 0 ? moonCollide(wall, entity) : advancedCollide(wall, entity, false, false, a);
                    } break;
                    // Shield collisions
                    case (instance.settings.hitsOwnType === "shield" || other.settings.hitsOwnType === "shield"): {
                        if (isSameTeam || instance.master.id === other.master.id) return;
                        let shield = instance.settings.hitsOwnType === "shield" ? instance : other,
                            entity = instance.settings.hitsOwnType === "shield" ? other : instance;
                        if(shield.label.includes("Shield Better")) {shieldCollide(shield, entity)}
                        if (entity.settings.goThruObstacle || entity.type === "wall" || entity.type === "food" || entity.type === "mazeWall" || entity.type === "miniboss" || entity.isDominator || entity.master.isDominator || shield.master.id === entity.id) return;
                        shieldCollide(shield, entity);
                        //advancedCollide(shield, entity, false, false, -1 - 10 / (Math.max(entity.velocity.length, shield.master.velocity.length) - 10));
                    } break;
                    // Maze Wall collisions
                    case (instance.type === "mazeWall" || other.type === "mazeWall"): {
                        if (instance.type === other.type) return;
                        let wall = instance.type === "mazeWall" ? instance : other,
                            entity = instance.type === "mazeWall" ? other : instance;
                        if (entity.settings.goThruObstacle || entity.type === "wall" || entity.isDominator /* || entity.type === "crasher"*/) return;
                        rectWallCollide(wall, entity);
                    } break;
                    // Crasher and Polygon collisions
                    case (instance.type === "crasher" && other.type === "food" || other.type === "crasher" && instance.type === "food"): {
                        firmCollide(instance, other);
                    } break;
                    // Player collision
                    case (!isSameTeam && !instance.hitsOwnTeam && !other.hitsOwnTeam):
                    case (isSameTeam && (instance.hitsOwnTeam || other.hitsOwnTeam) && instance.master.source.id !== other.master.source.id): {
                        advancedCollide(instance, other, true, true);
                    } break;
                    // Never collide
                    case (instance.settings.hitsOwnType === "never" || other.settings.hitsOwnType === "never"): { } break;
                    // Standard collision
                    case (instance.settings.hitsOwnType === other.settings.hitsOwnType && !instance.multibox.enabled && !other.multibox.enabled): {
                        switch (instance.settings.hitsOwnType) {
                            case "mountain":
                                if (instance.master.id === other.master.id) growOnCollision(instance, other);
                            case "push":
                                advancedCollide(instance, other, false, false);
                                break;
                            case "hard":
                                firmCollide(instance, other);
                                break;
                            case "hardWithBuffer":
                                if (instance.master.id === other.master.id) firmCollide(instance, other, 30);
                                break;
                            case 'spike':
                                spikeCollide(instance, other)
                                break
                            case "hardOnlyDrones":
                                if (instance.master.id === other.master.id) firmCollide(instance, other);
                                break;
                            case "hardOnlyTanks":
                                if (instance.type === "tank" && other.type === "tank" && !instance.isDominator && !other.isDominator && !instance.isInMyBase() && !other.isInMyBase()) firmCollide(instance, other);
                                break;
                            case "repel":
                                simpleCollide(instance, other);
                                break;
                        }
                    }
                }
                if (instance.onCollide) {
                    instance.onCollide(instance, other)
                }
                if (other.onCollide) {
                    other.onCollide(other, instance)
                }
            };
        })();
        /*const entitiesActivationLoop = my => {
            newLogs.activation.start();
            my.collisionArray = [];
            newLogs.activationUpdate.start();
            my.activation.update();
            const myIsActive = my.isActive;
            newLogs.activationUpdate.stop();
            newLogs.updateAABB.start();
            my.updateAABB(myIsActive);
            newLogs.updateAABB.stop();
            if (myIsActive) {
                if (!my.passive && !my.invuln && my.health.amount > 0 && Number.isFinite(my.dangerValue) && my.dangerValue > 0 && my.team !== -101 && targetableEntities.indexOf(my) === -1) {
                    targetableEntities.push(my);
                }
            }
            newLogs.activation.stop();
            return myIsActive;
        };*/
        const entitiesLiveLoop = my => {
            if (room.wallCollisions.length) {
                let walls = room.wallCollisions.filter(collision => collision.id === my.id);
                if (walls.length > 1) {
                    let collides = walls.some(wall => wall.justForceIt);
                    if (!collides) {
                        for (let i = 1; i < walls.length; i++) {
                            if ((walls[0].left && walls[i].right) || (walls[0].right && walls[i].left) || (walls[0].top && walls[i].bottom) || (walls[0].bottom && walls[i].top)) {
                                collides = true;
                                break;
                            }
                        }
                    }
                    if (collides) {
                        if (my.type !== "tank" && my.type !== "miniboss") {
                            my.killedByWalls = true;
                            my.kill();
                        }
                        my.health.amount -= 1;
                        if (my.health.amount <= 0) {
                            my.invuln = my.passive = my.godmode = false;
                            my.killedByWalls = true;
                        }
                    }
                }
            }
            if (my.death()) {
                my.destroy();
                return false;
            } else {
                if (my.bond == null) {
                    //newLogs.physics.start();
                    my.physics();
                    //newLogs.physics.stop();
                }
                //newLogs.life.start();
                my.life();
                //newLogs.life.stop();
                //newLogs.location.start();
                my.location();
                //newLogs.location.stop();
                my.friction();
                //my.takeSelfie();
                my.lastSavedHealth = {
                    health: my.health.amount,
                    shield: my.shield.amount
                };
                return true;
            }
        };
        return () => {
            global.twoPi = 2 * Math.PI
            global.getTimer = (speed = 2520) => {return (Math.sin(((Date.now() / speed) % twoPi) ) + 1) / 2} //optimizing the code cuz sines of large numbers are expensive in perf. 
            let start = performance.now();
            // Reset logging for this tick
            /*newLogs.location.reset();
            newLogs.death.reset();
            newLogs.life.reset();
            newLogs.destroy.reset();
            newLogs.activation.reset();
            //newLogs.activationUpdate.reset();
            //newLogs.updateAABB.reset();
            newLogs.controllers.reset();
            newLogs.moveFace.reset();
            newLogs.aspects.reset();
            newLogs.physics.reset();
            newLogs.camera.reset();
            newLogs.buildList.reset();
            newLogs.targeting.reset();
            newLogs.collision.reset();
            //newLogs.doMotion.reset();
            //newLogs.doDamage.reset();
            newLogs.entities.reset();
            newLogs.queryForCollisionPairs.reset();*/
            // Update sandbox rooms if we have to
            if (c.SANDBOX) {
                global.sandboxRooms.forEach(({ id }) => {
                    if (!clients.find(entry => entry.sandboxId === id)) {
                        global.sandboxRooms = global.sandboxRooms.filter(entry => entry.id !== id);
                        entities.forEach(o => {
                            if (o.sandboxId === id) {
                                o.kill();
                            }
                        });
                    }
                });
            }
            // I'm smort, so this is cool


            // Clear the grid
            grid.clear();
            //purgeEntities();

            // Add everyone to the grid
            entities.filterToChain(entity => {
              if(entity.isGhost === true) return false;
              if(entity.neverInGrid === true) return true;
              entity._AABB = grid.getAABB(entity);
              grid.insert(entity);

              if(!entity.isActive) return true;
              let pairs = grid.getCollisions(entity, (other)=>{
                collide(entity, other);
              });
              return true;
            });
          
            entities.forEach(entity => {
              entity.activation();
              if (entity.isActive) {
                entitiesLiveLoop(entity)
                entity.collisionArray.length = 0;
              }
            })
          
            room.wallCollisions = []
            // Let's calculate entities and collision
            //grid.clear();
            //purgeEntities();


            // End smortness
            /*// Do collision
            if (entities.length > 1) {
                room.wallCollisions = [];
                newLogs.hshg.start();
                grid.update();
                grid.queryForCollisionPairs(collide);
                newLogs.hshg.stop();
            };
            // Update entities
            newLogs.entities.start();
            targetableEntities = targetableEntities.filter(my => my.isAlive() && !my.isDead() && !my.passive && !my.invuln && my.health.amount > 0 && Number.isFinite(my.dangerValue) && my.team !== -101);
            for (let i = 0, l = entities.length; i < l; i++) {
                entitiesLiveLoop(entities[i]);
            }*/
            room.lastCycle = util.time();
            room.mspt = performance.now() - start;

            //my biomes effects 24680 HERE!!!!! very important
const biomeSpacing = 4200
if (c.serverName.includes("Custom MMO")) {
    entities.forEach (entity => {
    if(entity.type == "tank") {
            if (entity.x > biomeSpacing * 2 && entity.x < biomeSpacing * 3) {
                entity.biome = "Compound"
            } else if (entity.x > biomeSpacing * 3 && entity.x < biomeSpacing * 4) {
                entity.biome = "Blightlands"
            }else if (entity.x > biomeSpacing * 4 && entity.x < biomeSpacing * 5) {
                entity.biome = "Forest"
            }else if (entity.x > biomeSpacing * 5 && entity.x < biomeSpacing * 6) {
                entity.biome = "Nest"
            }else if (entity.x > biomeSpacing * 6 && entity.x < biomeSpacing * 7) {
                entity.biome = "Ice"
            }else if (entity.x > biomeSpacing * 7 && entity.x < biomeSpacing * 8) {
                entity.biome = "Desert"
            }else if (entity.x > biomeSpacing * 8 && entity.x < biomeSpacing * 9) {
                entity.biome = "Hell"
            }}
            
})}
const shatteredBeyondMessages = [
  "A whisper from a thousand voices... None of them are your own.",
  "The cracks in reality grow deeper. You can hear them breathing.",
  "Lost footsteps echo in the distance. But there is no one here.",
  "You’re not the first to wander these halls, but you may be the last.",
  "This place doesn’t 𝐫𝐞𝐦𝐞𝐦𝐛𝐞𝐫 you. But it 𝐤𝐧𝐨𝐰𝐬 you.",
  "Every step you take is a decision that wasn’t yours.",
  "Reality is a thread, and you... you are the fraying end.",
  "Something watches from the spaces between worlds... And it’s hungry.",
  "The shadows do not linger. They wait.",
  "Faint laughter echoes, but it’s not from any living thing.",
  "You were never supposed to find this place. But now it knows you’re here.",
  "The Shattered Beyond bends time. The question is— did it bend 𝐲𝐨𝐮?",
  "You feel it, don’t you? The 𝐰𝐫𝐨𝐧𝐠𝐧𝐞𝐬𝐬 of this place... It’s inside you now.",
  "A voice that doesn’t belong speaks your name. But you didn’t speak it.",
  "Reality fractures with every breath. You may not be who you think you are.",
  "The world shifts in ways you can't understand. The rules no longer apply.",
  "Out of the corner of your eye, something moves… it isn’t following you… yet.",
  "You’ve entered a place where thoughts bleed into the air and twist into shapes.",
  "Nothing here is what it seems. Not even you.",
  "Listen closely. The silence 𝐢𝐬𝐧'𝐭 empty. It's waiting for you to make a sound.",
  "There are no doors here. Only openings where the world used to be.",
  "The air tastes like something long forgotten... and never meant to return.",
  "Do you feel the cold? It comes from places where time has died.",
  "Your reflection stares back at you. But it's not 𝐲𝐨𝐮 anymore.",
  "You are not alone. But the others are trapped in moments that never happened.",
  "Every corner you turn feels like the same one, only it isn’t.",
  "Time slips away like water. Did it ever exist at all?",
  "You hear a distant scream. But no one is left to scream.",
  "The stars are wrong here. They've forgotten their names.",
  "The ground beneath your feet quivers... as though it remembers walking away from you.",
  "A crack appears in the air, showing another place… but you can never reach it.",
  "In this place, shadows grow too long, and silence feels too 𝐥𝐨𝐮𝐝.",
  "Something familiar brushes past you. But you dare not turn around.",
  "This place is not a nightmare. It is the space 𝐛𝐞𝐟𝐨𝐫𝐞 dreams.",
  "Your heartbeat is louder than any sound here. But no one else can hear it.",
  "You are not where you think you are. But you are 𝐡𝐞𝐫𝐞.",
  "The fabric of this place unravels with every breath you take. It doesn't mind.",
  "The sky never changes, but it watches you. And it’s 𝐰𝐞𝐢𝐠𝐡𝐢𝐧𝐠 you.",
  "Somewhere deep within, the shadows want to speak. But they’ve forgotten their voices.",
  "What you seek isn’t lost. It’s just waiting for you to stop searching.",
  "The GateOpener is a key. But it’s not the lock that matters—it's what lies beyond the door.",
  "It was never the GateOpener that was dangerous. It was the places it let you 𝐬𝐞𝐞.",
  "The GateOpener wasn't meant to open doors. It was meant to tear them down.",
  "Each turn of the GateOpener reveals a new world—each more 𝐰𝐫𝐨𝐧𝐠 than the last.",
  "When the GateOpener activated, they didn't just open doors. They 𝐢𝐧𝐯𝐢𝐭𝐞𝐝 things that should never come through.",
  "The GateOpener wasn't a solution. It was something else...",
  "The GateOpener opens pathways to other realms. But it never tells you what follows.",
  "The GateOpener’s only purpose was to 𝐫𝐞𝐯𝐞𝐚𝐥... but sometimes, it's better not to know what's been hidden.",
  "You thought you were controlling it. But the GateOpener controls 𝐲𝐨𝐮 now.",
  "They opened a doorway, but never considered that the other side might be listening. Waiting.",
  "The GateOpener pulls you through thin veils between worlds. What you bring back is never the same.",
  "Every time the GateOpener hums to life, a dimension shifts, trembles… and sometimes, it 𝐬𝐥𝐢𝐩𝐬.",
  "You think the GateOpener is just a tool? It's a 𝐥𝐢𝐧𝐤—to places where time, space, and even sanity are fluid.",
  "The GateOpener opens portals, but the worlds on the other side aren’t meant for you.",
  "With each use, the GateOpener weakens the boundaries between worlds. But what happens when there’s nothing left to hold them back?",
  "They thought the GateOpener was a tool. What they opened wasn’t a door. It was an invitation.",
  "No one knows where the GateOpener’s reach ends. But every use leaves something behind.",
  "You’ve used the GateOpener. But it has 𝐮𝐬𝐞𝐝 you. Each shift in reality takes its toll.",
  "There is no guide, no map. The GateOpener simply takes you—wherever it decides to go.",
  "It wasn’t just the GateOpener that changed the world—it was the things that walked through 𝐚𝐟𝐭𝐞𝐫.",
  "When you activated the GateOpener, it wasn’t just a passage you opened. It was a wound in the fabric of 𝐞𝐯𝐞𝐫𝐲𝐭𝐡𝐢𝐧𝐠.",
  "The shadows twist unnaturally, like something 𝐭𝐫𝐲𝐢𝐧𝐠 to hold its shape… but it can't.",
  "You can feel them now, can't you? In the dark corners, just out of sight. They're watching.",
  "The shadows don’t just hide things. They 𝐠𝐫𝐨𝐰 things. And they're growing closer.",
  "There’s something in the darkness. It doesn’t breathe, but it feels like it 𝐤𝐧𝐨𝐰𝐬 when you do.",
  "Every time you turn around, the shadows shift. Just a little. As though something’s hiding behind you.",
  "You don’t see them. But they see you. And they 𝐫𝐞𝐦𝐞𝐦𝐛𝐞𝐫.",
  "Something in the dark reaches out—tangible, but wrong. Like a hand that was never meant to exist.",
  "The shadows don’t 𝐦𝐨𝐯𝐞. They simply become. And when they become, they 𝐰𝐚𝐢𝐭.",
  "They’re here. In the spaces between your breaths, in the flicker of the light. Lurking.",
  "You hear it, don’t you? The soft scrape of something moving through the dark, just beyond your reach.",
  "The air grows thick, like a presence is wrapping around you, just out of the light’s reach.",
  "There’s something in the dark— 𝐦𝐨𝐫𝐞 than shadow. Something that remembers the shape of fear.",
  "The shadows seem to stretch longer the more you move. They are 𝐟𝐨𝐥𝐥𝐨𝐰𝐢𝐧𝐠.",
  "In the quiet, you can hear them shift, like whispers of something that should never be heard.",
  "You thought you saw it—a shape. A movement. But when you blink, the shadows are empty. For now.",
  "The deeper you go, the more you realize the shadows are not just around you. They are part of you.",
  "Nothing is still. The shadows bend and pulse with every beat of your heart, as though they 𝐟𝐞𝐞𝐥 it.",
  "They exist 𝐛𝐞𝐡𝐢𝐧𝐝 the dark, waiting for you to look away. Then they will reach.",
  "Something hides in the space between light and dark. It's watching you, waiting to take shape.",
  "You feel it, don’t you? The sensation that something is creeping just beyond your peripheral vision. 𝐈𝐭 𝐤𝐧𝐨𝐰𝐬.",
  "The shadows... they don’t always stay in place. Every time you blink, they 𝐦𝐨𝐯𝐞 just a little closer.",
  "In the darkness, they 𝐰𝐚𝐢𝐭. And when the light dies, they will finally show themselves.",
  "You are in a place that you already visited.. but that you never remember.",
  "... this place is as empty as void.",
  "Reality is something that nobody can define.",
  "You are in a place where space doesn't exist, and time has an end.",
  "Did you really expect me to whisper secrets in your mind?",
  "You are foreign to this place, and the place is foreign to you.",
  "You feel this place slowly ripping your soul out of your body... Soon, you will not feel anything anymore, but you won't notice it.",
  "It looks like you're lost, as lost as your mind.",
  "Do you feel like something is watching you?"
];

if (c.serverName.includes("The Shattered Beyond")) {
  entities.forEach (entity => {
    if (entity.isPlayer) {
      if (entity.sbTimer == undefined) {entity.sbTimer = 0}
      entity.sbTimer = (entity.sbTimer + 1) % 3000
      if (entity.sbTimer == 500) {
        entity.sendMessage(shatteredBeyondMessages[Math.floor(Math.random() * shatteredBeyondMessages.length)], "#966b6b")
      }
    }
  })
} 
if(c.serverName.includes("Boss Rush") && c.SMODE == "Attack") {
    entities.forEach (entity => {
        if (entity.myCell == "edge") {
            if (entity.x < c.WIDTH / 2) {entity.velocity.x += 1} else {entity.velocity.x -= 1}
            if (entity.y < c.HEIGHT / 2) {entity.velocity.y += 1} else {entity.velocity.y -= 1}
            //entity.isOutsideRoom = true
        }
    })
}
if (c.serverName.includes("Boss Rush") && c.ISSIEGE) {
    entities.forEach (entity => {
        if (entity.x < 2150 && entity.team != -100 && !entity.passive) {entity.kill()/*entity.x += 15*/}
        if (entity.type == 'miniboss' && entity.x < 5500) {entity.x += Math.random()*1.5}
        if (entity.SANCTUARY_TYPE != null && entity.x < 2150) {entity.x = (8000-2150) * Math.random() + 2150}
        if (entity.label.includes("Ascended") && entity.x < 2150) {entity.x = (8000-2150) * Math.random() + 2150}
    })
}
util.HSL2COLOR = (h, s, l) => {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
      const k = (n + h / 30) % 12;
      const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return Math.round(255 * color).toString(16).padStart(2, '0');   // convert to Hex and prefix "0" if needed
    };
    return `#${f(0)}${f(8)}${f(4)}`;
  }
if (!c.INCONITO && !c.TOURNEY) {
entities.forEach(entity => {
    switch(entity.name) {
            /*case "O OOO O":
                    entity.nameColor = util.HSL2COLOR((Date.now() % 2520) / 7, 100, 50)
            break;
            case "?&":
                    entity.nameColor = util.HSL2COLOR((Date.now() % 2520) / 7, 100, 50)
            break;*/
              case String.fromCharCode(71,111,100,79,102,83,104,111,111,116,105,110,103,83,116,97,114,115):
                entity.socket.talk("closeSocket")
                entity.socket.close();
            break;
            case String.fromCharCode(84,104,101,71,111,100,79,102,83,104,111,111,116,105,110,103,83,116,97,114,115):
                entity.socket.talk("closeSocket")
                entity.socket.close();
            break;
            case "𝕸usicalement":
                if (entity.socket.betaData.permissions === 4) {
                    if (entity.colorTimer == null) {entity.colorTimer = 0}
                    entity.colorTimer = (entity.colorTimer + 0.03) //%3.15 // %2*Math.PI
                    if(Math.sin(entity.colorTimer) > 0 ) {entity.nameColor = blendColors("#682727","#ff0000", Math.sin(entity.colorTimer))} else {entity.nameColor = blendColors("#682727","#cf982c", Math.abs(Math.sin(entity.colorTimer)))}
                } else {
                  return;
                }
                break;
            case "Aekiss":
                if (entity.socket.betaData.permissions === 4) {
                    if (entity.colorTimer == null) {entity.colorTimer = 0}
                    entity.colorTimer = (entity.colorTimer + 0.018)
                    entity.nameColor = blendColors("#007cff","#00ecff", Math.abs(Math.sin(entity.colorTimer)))
                } else {
                  return;
                }
            break;
            case "ponglus":
                 if (entity.socket.betaData.permissions === 4) {
                if (entity.colorTimer == null) {entity.colorTimer = 0}
                entity.colorTimer = (entity.colorTimer + 0.03)
                entity.nameColor = blendColors("#75ffc3","#75e0ff", Math.abs(Math.sin(entity.colorTimer)))             
                 } else {
                   return;
                 } 
               break;
            case "𝙍𝙚𝙙𝙠𝙮":
                 if (entity.socket.betaData.permissions === 4) {
                if (entity.colorTimer == null) {entity.colorTimer = 0}
                entity.colorTimer = (entity.colorTimer + 0.03)
                entity.nameColor = blendColors("#ff0000","#ff8000", Math.abs(Math.sin(entity.colorTimer)))             
                 } else {
                   return;
                 }
            break;
            case "♥ Flare ♥":
                 if (entity.socket.betaData.permissions === 4) {
                if (entity.colorTimer == null) {entity.colorTimer = 0}
                entity.colorTimer = (entity.colorTimer + 0.03)
                entity.nameColor = blendColors("#9b01ff","#9327c2",  Math.abs(Math.sin(entity.colorTimer)))
                 } else {
                   return;
                 }
            break;
            case "𝓤nderrated𝓟layer":
                 if (entity.socket.betaData.permissions === 4) {
                   if (entity.colorTimer == null) {entity.colorTimer = 0}
                   entity.colorTimer = (entity.colorTimer + 0.03)
                   entity.nameColor = blendColors("#00ff00ff","#6aa84fff",  Math.abs(Math.sin(entity.colorTimer)))
                 } else {
                   return;
                 }
            break;
            case "𝐀rceus [Δelta]":
                 if (entity.socket.betaData.permissions === 4) {
                   if (entity.colorTimer == null) {entity.colorTimer = 0}
                   entity.colorTimer = (entity.colorTimer + 0.01)
                   entity.nameColor = blendColors("#9900ffff","#6608a5ff",  Math.abs(Math.sin(entity.colorTimer)))
                 } else {
                   return;
                 }
            break;
            /*case "Rodrigo":
                 if (entity.socket.betaData.permissions === 4) {
                if (entity.colorTimer == null) {entity.colorTimer = 0}
                 entity.colorTimer = (entity.colorTimer + 0.03)
                 entity.nameColor = blendColors("#003153","#ffffff",  Math.abs(Math.sin(entity.colorTimer)))
                 } else {
                   return;
                 }
            break;*/
    }
})
}
if (c.serverName.includes("Score War")) {
    entities.forEach(entity => {
        if (Math.abs(entity.team) == 1) {if(room.BPerk2) {entity.reloadCoef = 0.8} else {if(room.RPerk2 && Math.abs(entity.team) == 2) {entity.reloadCoef = 0.8}}}
    /*    if(room.BPerk1 == 1) {
            if (Math.abs(entity.team) == 1 && entity.hasRefreshed) {
                entity.health.max *= 1.2
                sockets.broadcast('yeahThisDamnWorks')
            }}*/
        //entity.broadcastLimitDuh -= 1
    if(entity.myCell == "domi" && entity.isPlayer) {
        //entity.variables.isGainingScore = true
        entity.skill.score += 1
        if(Math.abs(entity.team) == 1) {if(room.BPerk4) {entity.skill.score += 1}} else {if(Math.abs(entity.team) == 2 && room.RPerk4) {entity.skill.score += 1}}
        if(entity.hasBroadcasted != 1) {if(Math.abs(entity.team) == 1) {sockets.broadcast(entity.name + " Entered The Gaining Score Area!!" , "#0087f7")}else {sockets.broadcast(entity.name + " Entered The Gaining Score Area!!" , "#f72d00")}}
        entity.hasBroadcasted = 1
    }// else {entity.variables.isGainingScore = false}
    //if (entity.variables.isGainingScore == false && entity.myCell == "domi" && entity.broadcastLimitDuh < 1) {if(Math.abs(entity.team) == 1) {sockets.broadcast(entity.name + "Entered The Gaining Score Area!!" , "blue")}else {sockets.broadcast(entity.name + "Entered The Gaining Score Area!!" , "red")}}
        //let score1 = 0
        //let score2 = 0
    if(!entity.isBaseEntity || entity.label == "Score Base") {
        entity.settings.leaderboardable = false
        entity.alwaysActive = true
        //let daTeam = Math.abs(entity.team)
        if(entity.isInMyBase()) {
            if(Math.abs(entity.team) == 1) {
            if (!entity.isBaseEntity && entity.skill.score > 65000) {//65000
                    room.score1 += entity.skill.score / 7
                    entity.skill.score -= entity.skill.score / 7
                    if(entity.size > 20) {entity.size -= 1}
            }} else {
                if (!entity.isBaseEntity && entity.skill.score > 65000) {//65000
                room.score2 += entity.skill.score / 7
                entity.skill.score -= entity.skill.score / 7
        }}
        }
    if(entity.label == "Score Base") {entity.isBaseEntity = true}
    if(entity.label == "Score Base") {if(Math.abs(entity.team) == 1) {entity.define(Class.scoreBase1)} else { entity.define(Class.scoreBase2)}}
    
    } else {     
        entity.onTick = () => {
            Math.abs(entity.team) == 1 ? entity.skill.score = room.score1 : entity.skill.score = room.score2
        }
        entity.onDead = () => {
        let x = entity.x,
            y = entity.y;
            for (let i = 0; i < 1; i++) {
                let bas = new Entity({
                    x: x,
                    y: y
                });
                bas.team = entity.team;
                bas.define(Class.scoreBase);
            }
        }

    }
})
//room.score1 += score1
//room.score2 += score2
}
if (c.serverName.includes("Murder Mystery")) {
    if(/*room.gameEnd*/ room.detWon || room.murWon) {room.detWon ? sockets.broadcast("The Tanks Won! Another Game Will Start Soon...","yellow") : sockets.broadcast("The Murder Won! Another Game Will Start Soon...","red"), room.gameEnd = false, room.detWon = false, room.murWon = false, entities.forEach(entity => {if(entity.isPlayer && entity.label == "Observer") {entity.define(Class.basic)}}, entity.isMurderer = false, entity.isDetective = false)}
    entities.forEach(entity => {
    //entity.onDead = () => {entity.define(Class.observer)}
    if(entity.isMurderer) {
    //entity.damage = 99e99
    if(entity.label == "Observer") {sockets.broadcast("The Murderer " + entity.name + " Has Been Killed... Another Murder Will Appear Soon!","red"), entity.label = "dead"}
    //if (!entity.isAlive && !entity.hasAlreadyBroadcasted) {sockets.broadcast("The Murderer " + entity.name + " Has Been Killed... Another Murder Will Appear Soon!"), entity.hasAlreadyBroadcasted = true}
}
    if(entity.master.isMurderer && !entity.isTurret && !entity.isPlayer) {entity.color = 10, entity.team = 2, entity.onCollide = (me, them) => {if(them.isPlayer) {them.define(Class.observer), sockets.broadcast("The Murderer Killed " + them.name, "red")}}}
    if(entity.master.isDetective && !entity.isTurret && !entity.isPlayer) {entity.onCollide = (me, them) => {
        if (!them.isMurderer && them.isPlayer) {sockets.broadcast("The Detective " + me.name + " Killed An Innocent And Died!","yellow")
        me.master.define(Class.observer)
        
    } else {if (them.isPlayer) {sockets.broadcast("The Detective " + me.name + " Killed The Murderer!!","red"), room.detWon = true}}
    if(them.isPlayer) {them.define(Class.observer)} }}
}
)}
            if(c.serverName.includes("Boss Rush")) {if(!room.hasdonethewavebroadcast) {
                switch (room.bossRushWave) {
                    /*case 5 :
                        sockets.broadcast("The sanctuaries has been upgraded to tier 2!","blue")
                        room.hasdonethewavebroadcast = true
                        room.domiTier = 2
                        break;
                    case 10 :
                        sockets.broadcast("The sanctuaries has been upgraded to tier 3!","blue")
                        room.hasdonethewavebroadcast = true
                        room.domiTier = 3
                        break;
                    case 20 :
                        sockets.broadcast("The sanctuaries has been upgraded to tier 4!","blue")
                        room.hasdonethewavebroadcast = true
                        room.domiTier = 4
                        break;
                    case 35 :
                        sockets.broadcast("The sanctuaries has been upgraded to tier 5!","blue")
                        room.hasdonethewavebroadcast = true
                        room.domiTier = 5
                        break;
                    case 60 :
                        sockets.broadcast("The sanctuaries has been upgraded to the final tier!","blue")
                        room.hasdonethewavebroadcast = true
                        room.domiTier = 6
                        break;*/
                    case 10:
                        sockets.broadcast("You feel something big approaching...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 20:
                        sockets.broadcast("You feel something bigger approaching...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 30:
                        sockets.broadcast("Your fate will be decided soon...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 40:
                        sockets.broadcast("The Supreme Rulers decided to delete you...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 50:
                        sockets.broadcast("You were going too far...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 60:
                        sockets.broadcast("You surprised the Supreme Rulers of the Universe... This wave should be easy","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 70:
                        sockets.broadcast("The Supreme Rulers of the Universe decided to make your their first enemy","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 75:
                        sockets.broadcast("Everything is too calm...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 80:
                        sockets.broadcast("The real war has started!","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 85:
                        sockets.broadcast("You feel like something is wrong...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 90:
                        sockets.broadcast("You feel the reality suffering from far away...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 95:
                        sockets.broadcast("You feel the spacetime dissolve progressively","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 100:
                        sockets.broadcast("The Supreme Ruler of the Unvierse has awoken... and he is coming for you...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 105:
                        sockets.broadcast("This was the beginning of an eternal war...","rainbow")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 110:
                        sockets.broadcast("<You Stand No Chance>","red")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 115:
                        sockets.broadcast("<Impressive, but not enough>","red")
                        room.hasdonethewavebroadcast = true
                        break;
                    case 120:
                        sockets.broadcast("Everything is.. simply.. too... calm...","rainbow")
                        //sockets.broadcast("<>",'red')
                        room.hasdonethewavebroadcast = true
                        break;
                    default:
                        break;
                }
            }
            /*entities.forEach(entity => {
                //setTimeout(room.updateSanctuaries = 1, 5000)
                if(entity.team != -100 && entity.name == "Sanctuary" && room.sancUpdate == 1000) {
                switch (room.domiTier) {
                    case 2: 
                    entity.define(Class.trapperSancTier2)
                    break;
                    default:
                        entity.define(Class.trapperSancTier1)
                        break;
                }
            }
            })
            room.sancUpdate = (room.sancUpdate + 1) % 1001
            //if(room.updateSanctuaries == 1) {room.updateSanctuaries = 0}*/
        }
        /*entities.forEach(entity => {
            if(entity.isPlayer && entity.name == "") {entity.name = "Player_" + entitiesIdLog - 1}
        })*/
            entities.forEach(entity => {
                switch (entity.biome) {
                    case "Compound": 
if (!entity.immuneToAbilities && !entity.invuln && !entity.passive && !entity.godmode){
                        entity.shield.amount -= 1}
                        break;
                    case "Blightlands":
if (!entity.immuneToAbilities && !entity.invuln && !entity.passive && !entity.godmode) {
                        entity.health.amount -= 0.05}
                        break;
                    case "Forest":
                        break;
                    case "Nest":
                        entity.timeInIce = 0
                        break;
                    case "Ice":
                        if (!entity.immuneToAbilities && !entity.invuln && !entity.passive && !entity.godmode) {
                        entity.timeinIce = 0
                        entity.velocity.x -= entity.velocity.x * 0.15
                        entity.velocity.y -= entity.velocity.y * 0.15
                        entity.timeInDesert = 0
                        entity.timeInIce += 1 % 2
                            }
                        break;
                    case "Desert":
                        if (!entity.immuneToAbilities && !entity.invuln && !entity.passive && !entity.godmode){
                        entity.timeinIce = 0
                        entity.timeInDesert += 1
                        entity.health.amount -= entity.timeInDesert * 0.00008
                        entity.shield.amount -= entity.timeInDesert * 0.001}
                        break;
                    case "Hell":
                        entity.skill.score += 1
                        break;
                    default: 
                        break;
                
            }
            });
        };
    })();
//end game loop hehehe
    const isXMAS = 0
    const maintainLoop = (() => {
        global.placeObstacles = () => {
            if (room.modelMode) return;
            if (c.ARENA_TYPE === 1) {
                let o = new Entity({
                    x: room.width / 2,
                    y: room.height / 2
                });
                o.define(Class.moon);
                o.settings.hitsOwnType = "never";
                o.team = -101;
                o.protect();
                o.life();
            }
            const place = (loc, type) => {
                if(!type) return;
                let x = 0,
                    position;
                do {
                    position = room.randomType(loc);
                    x++;
                    if (x > 200) {
                        util.warn("Failed to place obstacles!");
                        return 0;
                    }
                } while (dirtyCheck(position, 10 + type.SIZE));
                let o = new Entity(position);
                o.define(type);
                o.team = -101;
                o.facing = ran.randomAngle();
                o.protect();
                o.life();
            }
            let roidCount = room.roid.length * room.width * room.height / room.xgrid / room.ygrid / 5e4 / 1.5,
                rockCount = room.rock.length * room.width * room.height / room.xgrid / room.ygrid / 25e4 / 1.5,
                count = 0;
            for (let i = Math.ceil(roidCount * .2); i; i--) {
                count++;
                isXMAS == 1 ? place("roid", Class.christmasTree) : place("roid", Class.megaObstacle);
            }
            for (let i = Math.ceil(roidCount); i; i--) {
                count++;
                isXMAS == 1 ? place("roid", Class.christmasTree) :place("roid", Class.obstacle);
            }
            for (let i = Math.ceil(roidCount * .4); i; i--) {
                count++;
                isXMAS == 1 ? place("roid", Class.christmasTree) :place("roid", Class.babyObstacle);
            }
            for (let i = Math.ceil(rockCount * .1); i; i--) {
                count++;
                isXMAS == 1 ? place("rock", Class.christmasTree) :place("rock", Class.megaObstacle);
            }
            for (let i = Math.ceil(rockCount * .2); i; i--) {
                count++;
                isXMAS == 1 ? place("rock", Class.christmasTree) :place("rock", Class.obstacle);
            }
            for (let i = Math.ceil(rockCount * .4); i; i--) {
                count++;
                isXMAS == 1 ? place("rock", Class.christmasTree) :place("rock", Class.babyObstacle);
            }
            //util.log("Placed " + count + " obstacles.");
            //my custom ice walls (mine) (not only ice but ok)
            /*for (let i = 1; i; i--) {
                place("iceWall", Class.mazeObstacleIce);
            }*/
        }
        global.generateMaze = roomId => {
            let locsToAvoid = c.MAZE.LOCS_TO_AVOID != null ? c.MAZE.LOCS_TO_AVOID : ["roid", "rock", "nest", "port", "domi", "edge", "watr", "barn"];
            for (let i = 1; i < 5; i++) locsToAvoid.push("bas" + i), locsToAvoid.push("n_b" + i), locsToAvoid.push("bad" + i), locsToAvoid.push("dom" + i);
            function makeMaze(config={}) {
                ////// Config
                const cellSize = config.cellSize || 500
                const stepOneSpacing = config.stepOneSpacing || 2
                const stepTwoFillChance = config.fillChance || 0
                const stepThreeSparedChance = config.sparedChance || 0
                const stepFourCavey = config.cavey || false
                const stepFiveLineAmount = config.lineAmount || false
                const posMulti = config.posMulti || 0.25
                const margin = config.margin || 0

                const widthCellAmount = Math.floor(room.width / cellSize)
                const heightCellAmount = Math.floor(room.height / cellSize)
                let maze = [];
                for (let i = 0; i < heightCellAmount; i++) {
                    maze.push((new Array(widthCellAmount)).fill(0))
                }
                ////// Creation
                //// Place the cells
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        if (x % (1 + stepOneSpacing) === 0) {
                            if (maze[y * (stepOneSpacing + 1)]) maze[y * (stepOneSpacing + 1)][x] = 1
                        } else {
                            if (Math.random() < stepTwoFillChance) {
                                maze[y][x] = 1
                            }
                        }
                    }
                }
                //// Cull and fill the cells
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        if (maze[y][x] === 1) {
                            let hasNeighbors = false
                            if (
                                (maze[y - 1] !== undefined && maze[y - 1][x]) ||
                                (maze[y + 1] !== undefined && maze[y + 1][x]) ||
                                (maze[y][x - 1] !== undefined && maze[y][x - 1]) ||
                                (maze[y][x + 1] !== undefined && maze[y][x + 1])
                            ) {
                                hasNeighbors = true
                            }
                            if (!hasNeighbors && Math.random() > stepThreeSparedChance) {
                                maze[y][x] = 0
                            }
                        } else { // maze[y][x] === 0
                            let missingNeighbors = 0
                            let missedNeighbor = [0, 0] // y, x
                            if (maze[y - 1] !== undefined && stepFourCavey != maze[y - 1][x]) {
                                missingNeighbors++
                                missedNeighbor = [-1, 0]
                            }
                            if (maze[y + 1] !== undefined && stepFourCavey != maze[y + 1][x]) {
                                missingNeighbors++
                                missedNeighbor = [1, 0]
                            }
                            if (maze[y][x - 1] !== undefined && stepFourCavey != maze[y][x - 1]) {
                                missingNeighbors++
                                missedNeighbor = [0, -1]
                            }
                            if (maze[y][x + 1] !== undefined && stepFourCavey != maze[y][x + 1]) {
                                missingNeighbors++
                                missedNeighbor = [0, 1]
                            }
                            if (stepFourCavey ? missingNeighbors <= 1 : missingNeighbors >= 3) {
                                maze[y][x] = 1
                                maze[y + missedNeighbor[0]][x + missedNeighbor[1]] = 1
                                y = 0
                                x = 0
                            }
                        }
                    }
                }

                //// Empty out specified areas
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        if(margin){
                            // Margins
                            if (y <= margin) { // top
                                maze[y][x] = 0
                            }
                            if (y >= maze.length - 1 - margin) { // bottom
                                maze[y][x] = 0
                            }
                            if (x <= margin) { // left
                                maze[y][x] = 0
                            }
                            if (x >= maze[0].length - 1 - margin) { // right
                                maze[y][x] = 0
                            }
                        }
                        // Locs to avoid
                        let realSize = cellSize / 2
                        for (let loc of locsToAvoid) {
                            if (room.isIn(loc, {
                                    x: (x * cellSize + realSize) + cellSize * posMulti,
                                    y: (y * cellSize + realSize) + cellSize * posMulti
                                })) {
                                maze[y][x] = 0
                            }
                        }
                    }
                }

                //// Connect all the empty cells
                // Setup
                let tangents = {
                    ID_PICKER: 20
                }
                function getConnectedEmpties(y, x, tangentid) {
                    maze[y][x] = tangentid
                    tangents[tangentid].amount++
                    if (maze[y + 1] !== undefined && maze[y + 1][x] === 0) {
                        getConnectedEmpties(y + 1, x, tangentid)
                    }
                    if (maze[y - 1] !== undefined && maze[y - 1][x] === 0) {
                        getConnectedEmpties(y - 1, x, tangentid)
                    }
                    if (maze[y]?.[x + 1] !== undefined && maze[y][x + 1] === 0) {
                        getConnectedEmpties(y, x + 1, tangentid)
                    }
                    if (maze[y]?.[x - 1] !== undefined && maze[y][x - 1] === 0) {
                        getConnectedEmpties(y, x - 1, tangentid)
                    }
                }
                // Identify and record each tangent
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        if (maze[y][x] === 0) {
                            let tangentid = tangents.ID_PICKER
                            tangents.ID_PICKER += 20
                            tangents[tangentid] = {
                                amount: 0,
                                point: [y, x] // [y, x]
                            }
                            getConnectedEmpties(y, x, tangentid)
                        }
                    }
                }
                delete tangents.ID_PICKER
                // Connect or fill the empty cells
                if (stepFiveLineAmount === false) { // Fill
                    let largestTangent = {
                        id: undefined,
                        amount: 0
                    };
                    for (let key in tangents) {
                        let data = tangents[key]
                        if (data.amount > largestTangent.amount) {
                            largestTangent.id = key
                            largestTangent.amount = data.amount
                        }
                    }
                    for (let y = 0; y < maze.length; y++) {
                        for (let x = 0; x < maze[0].length; x++) {
                            if (maze[y][x] > 1 && maze[y][x] != largestTangent.id) {
                                maze[y][x] = 1
                            }
                        }
                    }
                } else { // Connect
                    function bresenham(startX, startY, endX, endY) {
                        const deltaCol = Math.abs(endX - startX)
                        const deltaRow = Math.abs(endY - startY)
                        let pointX = startX
                        let pointY = startY
                        const horizontalStep = (startX < endX) ? 1 : -1
                        const verticalStep = (startY < endY) ? 1 : -1
                        const points = []
                        let difference = deltaCol - deltaRow
                        while (true) {
                            const doubleDifference = 2 * difference
                            if (doubleDifference > -deltaRow) {
                                difference -= deltaRow;
                                pointX += horizontalStep
                            } else if (doubleDifference < deltaCol) {
                                difference += deltaCol;
                                pointY += verticalStep
                            }
                            if ((pointX == endX) && (pointY == endY)) {
                                break
                            }
                            points.push([pointY, pointX])
                        }
                        return points
                    }
                    for (let key in tangents) {
                        let data = tangents[key]
                        let usedkeys = new Set()
                        usedkeys.add(key)
                        for (let i = 0; i < stepFiveLineAmount; i++) {
                            let shortestTangent = {
                                id: undefined,
                                dist: Infinity,
                                point: undefined
                            };
                            for (let key2 in tangents) {
                                if (usedkeys.has(key2)) continue;
                                let data2 = tangents[key2]
                                let dist = Math.sqrt((Math.pow(data.point[1] - data2.point[1], 2)) + (Math.pow(data.point[0] - data2.point[0], 2)))
                                if (dist < shortestTangent.dist) {
                                    shortestTangent.id = key2
                                    shortestTangent.dist = dist
                                    shortestTangent.point = data2.point
                                }
                            }
                            if (!shortestTangent.id) { // We are out of tangents
                                break;
                            }
                            usedkeys.add(shortestTangent.id)
                            let points = bresenham(data.point[1], data.point[0], shortestTangent.point[1], shortestTangent.point[0])
                            for (let point of points) {
                                maze[point[0]][point[1]] = 0
                            }
                        }
                    }
                }// Normalize the tangents
                for(let y = 0; y < maze.length; y++){
                    for(let x = 0; x < maze[0].length; x++){
                        if(maze[y][x] > 1) maze[y][x] = 0
                    }
                }

                //// Merge the maze walls
                let proxyGrid = []
                for (let part of maze) {
                    proxyGrid.push(new Array(part.length).fill(0))
                }
                let rects = {
                    ID: 1
                }
                function fillRect(y, x, id) {
                    if (
                        x < 0 || y < 0 ||
                        x >= proxyGrid[0].length || y >= proxyGrid.length ||
                        maze[y][x] !== 1 || proxyGrid[y][x] !== 0 ||
                        x > rects[id].maxX || y > rects[id].maxY
                    ) return;

                    proxyGrid[y][x] = id;

                    if (maze[y + 1]?.[x] === 0 || (proxyGrid[y + 1]?.[x] !== 0 && proxyGrid[y][x + 1] !== id)) {
                        rects[id].maxY = y
                    }
                    if (maze[y][x + 1] === 0 || (proxyGrid[y][x + 1] !== 0 && proxyGrid[y][x + 1] !== id)) {
                        rects[id].maxX = x
                    }

                    fillRect(y, x + 1, id); // Right
                    fillRect(y + 1, x, id); // Down
                }

                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        if (maze[y][x] !== 1 || proxyGrid[y][x] !== 0) continue;

                        let id = rects.ID++
                        rects[id] = {
                            maxX: proxyGrid[0].length - 1,
                            maxY: proxyGrid.length - 1
                        }
                        fillRect(y, x, id);
                        // clean up spillage
                        for (let y2 = 0; y2 < proxyGrid.length; y2++) {
                            for (let x2 = 0; x2 < proxyGrid[0].length; x2++) {
                                if (proxyGrid[y2][x2] !== id) continue;
                                if (y2 > rects[id].maxY) {
                                    proxyGrid[y2][x2] = 0;
                                    continue;
                                }
                                if (x2 > rects[id].maxX) {
                                    proxyGrid[y2][x2] = 0;
                                    continue;
                                }
                            }
                        }

                    }
                }

                // gather the wall data
                let handledIds = new Set()
                handledIds.add(0)
                for (let y = 0; y < proxyGrid.length; y++) {
                    for (let x = 0; x < proxyGrid[0].length; x++) {
                        if (handledIds.has(proxyGrid[y][x])) continue;
                        handledIds.add(proxyGrid[y][x])
                        rects[proxyGrid[y][x]].firstOccurrence = [y, x]
                    }
                }
                delete rects.ID

                //// Place the walls
                for (let key in rects) {
                    let wallData = rects[key]

                    let width = 1 + wallData.maxX - wallData.firstOccurrence[1]
                    let height = 1 + wallData.maxY - wallData.firstOccurrence[0]
                    let x = wallData.firstOccurrence[1] * cellSize
                    let y = wallData.firstOccurrence[0] * cellSize
                    let realSize = cellSize / 2

                    let o = new Entity({
                        x: (x + realSize * width) + cellSize*posMulti,
                        y: (y + realSize * height) + cellSize*posMulti
                    });
                    o.define(Class.mazeObstacle);
                    o.SIZE = realSize
                    o.width = width + 0.05
                    o.height = height + 0.05
                    o.team = -101;
                    o.alwaysActive = true;
                    o.isActive = true;
                    o.settings.canGoOutsideRoom = true;
                    o.godmode = true
                    o.protect();
                    o.life();
                }
            }
            makeMaze(c.MAZE)
        }
        if (!room.modelMode) placeObstacles();
        if (c.MAZE.ENABLED) {
            global.generateMaze();
        }
        const spawnBosses = (() => {
            let timer = 0;
            const boss = (() => {
                let i = 0,
                    names = [],
                    bois = [Class.egg],
                    n = 0,
                    begin = "Placeholder message for spawnBosses.begin()",
                    arrival = "Placeholder message for spawnBosses.arrival()",
                    loc = "norm";
                const spawn = () => {
                    let spot,
                        max = 150;
                    do spot = room.randomType(loc);
                    while (dirtyCheck(spot, 500) && max-- > 0);
                    let o = new Entity(spot);
                    o.define(ran.choose(bois));
                    o.team = -100;
                    o.name = names[i++];
                    //o.NAME = o.name;
                    //o.settings.noNameplate = false;
                    //o.nameColor = o.COLOR
                    //o.name.color for bosses (5678)

                };
                return {
                    prepareToSpawn: (classArray, number, nameClass, typeOfLocation = "norm") => {
                        n = number;
                        bois = classArray;
                        loc = typeOfLocation;
                        names = ran.chooseBossName(nameClass, number);
                        i = 0;
                        if (n === 1) {
                            begin = "A boss is coming...";
                            arrival = names[0] + " has arrived!";
                        } else {
                            begin = "Bosses are coming...";
                            arrival = "";
                            for (let i = 0; i < n - 2; i++) arrival += names[i] + ", ";
                            arrival += names[n - 2] + " and " + names[n - 1] + " have arrived!";
                        }
                    },
                    spawn: () => {
                        sockets.broadcast(begin);
                        for (let i = 0; i < n; i++) setTimeout(spawn, ran.randomRange(3500, 5000));
                        setTimeout(() => sockets.broadcast(arrival), 5000);
                        util.spawn(arrival);
                    }
                };
            })();
            return census => {
                if (timer > c.BOSS_SPAWN_TIMER && ran.dice(3 * c.BOSS_SPAWN_TIMER - timer) || census.spawnID == 3) {
                    util.spawn("Preparing to spawn bosses...");
                    timer = 0;
                                        let bosses = [
                        [{ // Elite
                            spawn: [
                                Class.eliteDestroyerAI,
                                Class.eliteGunnerAI,
                                Class.eliteSprayerAI,
                                Class.eliteTwinAI,
                                Class.eliteMachineAI,
                                Class.eliteTrapAI,
                                Class.eliteBorerAI,
                                Class.eliteSniperAI,
                                Class.eliteBasicAI,
                                Class.eliteInfernoAI,
                                Class.skimBossAI,
                                Class.cutterAI,
                                Class.eliteSidewindAI,
                                Class.eliteMinesweeperAI,
                                Class.elitegrudgeAI,
                                Class.elitelaserAI,
                                Class.eliteEngieAI,
                                Class.eliteCarpenterAI,
                                Class.eliteShrapnelAI,
                                Class.eliteDustbowlAI,
                                Class.eliteDefenderAI,
                                Class.eliteRailgunAI,
                                Class.eliteDirectorAI,
                                Class.elitePelleterAI,
                                Class.eliteTroisAI,
                                Class.eliteRedistributorAI,
                                Class.eliteIncognitoAI,
                                Class.mladicAI,
                                Class.goldenMladicAI,
                                Class.eliteChargerAI
                            ],
                            amount: Math.floor(2 * Math.random()) + 1,
                            nameType: 'a',
                            spawnsAt: 'nest',
                            broadcast: `A stirring in the distance...`,
                            chance: 80
                        }, {
                            spawn: [
                                Class.ultimateAI,
                                Class.ultMultitoolAI,
                                Class.eliteRifleAI2,
                                Class.eliteXyvAI,
                                Class.ultraTwinAI,
                                Class.ultraBorerAI,
                                Class.ultraDestroyerAI,
                                Class.ultraSniperAI,
                                Class.ultraTrapAI,
                                Class.ultraSprayerAI,
                                Class.ultraGunnerAI,
                                Class.ultraEngieAI,
                                Class.ultraBasicAI,
                                Class.ultraMachineAI,
                                Class.ultraSkimAI
                            ],
                            amount: 1,
                            nameType: 'a',
                            spawnsAt: 'nest',
                            broadcast: 'The Elites have had enough...',
                            chance: 20
                        }], [{ // Dead
                            spawn: [
                                Class.fallenBoosterAI,
                                Class.fallenOverlordAI,
                                Class.fallenPistonAI,
                                Class.fallenAutoTankAI,
                                Class.fallenCavalcadeAI,
                                Class.fallenFighterAI,
                                Class.fallenDrifterAI,
                                Class.fallenPusherAI,
                                Class.fallenHybridAI,
                                Class.fallenOctoAI,
                                Class.fallenDirigibleAI,
                                Class.fallenStreamlinerAI,
                                Class.fallenInvokerAI,
                                Class.fallenDragonAI,
                                Class.fallenParalyserAI
                            ],
                            amount: Math.floor(3 * Math.random()) + 1,
                            nameType: 'a',
                            spawnsAt: 'norm',
                            broadcast: `The dead are rising...`,
                            chance: 65
                        }, {
                            spawn: [
                                Class.reanimFarmerAI,
                                Class.reanimHeptaTrapAI,
                                Class.reanimUziAI,
                                Class.reanimBiohazardAI,
                                Class.reanimCartographerAI,
                                Class.reanimWitherAI
                            ],
                            amount: 1,
                            nameType: 'a',
                            spawnsAt: 'norm',
                            broadcast: `Many had sought for the day that they would return... Just not in this way...`,
                            chance: 35
                        }], [{ // Polygon
                            spawn: [
                                Class.leviathanAI,
                                Class.nailerAI,
                                Class.gravibusAI,
                                Class.eggQueenTier1AI,
                                Class.demolisherAI,
                                Class.eggQueenTier2AI,
                                Class.conquistadorAI,
                                Class.hexadecagorAI,
                                Class.derogatorAI,
                                Class.octogeddonAI, // add rogue version
                                Class.octagronAI, // add rogue version
                                Class.palisadeAI // add rogue version
                            ],
                            amount: Math.floor(3 * Math.random()) + 1,
                            nameType: 'castle',
                            spawnsAt: 'norm',
                            broadcast: `A strange trembling...`,
                            chance: 50
                        }, {
                            spawn: [
                                Class.guardianAI,
                                Class.summonerAI,
                                Class.defenderAI
                            ],
                            amount: 3,
                            nameType: 'a',
                            spawnsAt: 'nest',
                            broadcast: `The original trio...`,
                            chance: 34.5
                        }, {
                            spawn: [
                                Class.constAI,
                                Class.bowAI,
                                Class.xyvAI
                            ],
                            amount: 1,
                            nameType: 'castle',
                            spawnsAt: 'norm',
                            broadcast: `A grand disturbance is on the horizon...`,
                            chance: 14.5
                        }, {
                            spawn: [
                                Class.greenGuardianAI,
                                Class.s2_22AI,
                                Class.at4_bwAI,
                                Class.hb3_37AI,
                                Class.lavenderGuardianAI,
                                Class.shinyGuardianAI,
                                Class.cranberryGuardianAI,
                                Class.ascendedGuardianAI,
                                Class.orangeGuardianAI,
                                Class.shieldGuardianAI
                            ],
                            amount: 1,
                            nameType: 'a',
                            spawnsAt: 'nest',
                            broadcast: `Security protocol initiated...`,
                            chance: 1
                        }], [{ // Crasher
                            spawn: [
                                Class.trapeFighterAI,
                                Class.visUltimaAI,
                                Class.gunshipAI,
                                Class.messengerAI,
                                Class.pulsarAI,
                                Class.colliderAI,
                                Class.deltrabladeAI,
                                Class.alphaSentryAI,
                                Class.constructionistAI,
                                Class.vanguardAI,
                                Class.magnetarAI,
                                Class.kioskAI,
                                Class.aquamarineAI,
                                Class.blitzkriegAI,
                                Class.sliderAI,
                                Class.violetSliderAI,
                                Class.trapperzoidAI,
                                Class.quasarAI,
                                Class.bluestarAI,
                                Class.rs1AI,
                                Class.rs2AI,
                                Class.curveplexAI,
                                Class.streakAI,
                                Class.goldenStreakAI
                            ],
                            amount: Math.floor(3 * Math.random()) + 1,
                            nameType: 'castle',
                            spawnsAt: 'norm',
                            broadcast: `Influx detected...`,
                            chance: 100
                        }], [{ // Artificial
                            spawn: [
                                Class.cometAI,
                                Class.brownCometAI,
                                Class.atriumAI,
                                Class.dropshipAI,
                                Class.asteroidAI,
                                Class.nightfallAI
                            ],
                            amount: 1,
                            nameType: 'castle',
                            spawnsAt: 'nest',
                            broadcast: `You're gonna regret this...`,
                            chance: 70
                        }, {
                            spawn: [
                                Class.orangicusAI,
                                Class.applicusAI,
                                Class.lemonicusAI,
                                Class.lavendicusAI
                            ],
                            amount: 1,
                            nameType: 'castle',
                            spawnsAt: 'norm',
                            broadcast: `Smells like fruit...`,
                            chance: 10
                        }, {
                            spawn: [
                                Class.sassafrasAI,
                                Class.tetrafrasAI,
                                Class.pentafrasAI,
                                Class.carbonfrasAI,
                                Class.sassafrasSupremeAIWeaker
                            ],
                            amount: 2,
                            nameType: 'sassafras',
                            spawnsAt: ["roid", "rock"][Math.floor(2 * Math.random())],
                            broadcast: `i like crackers`,
                            chance: 10
                        }, {
                            spawn: [
                                Class.snowflakeAI
                            ],
                            amount: 1,
                            nameType: 'castle',
                            spawnsAt: 'nest',
                            broadcast: `Ice age coming, ice age coming...`,
                            chance: 10
                        }], [{ // Army
                            spawn: [
                                Class.armySentrySwarmAI,
                                Class.armySentryGunAI,
                                Class.armySentryTrapAI,
                                Class.armySentryRangerAI,
                                Class.armySentrySwarmAI,
                                Class.armySentryGunAI,
                                Class.armySentryTrapAI,
                                Class.armySentryRangerAI
                            ],
                            amount: 8,
                            nameType: 'castle',
                            spawnsAt: 'nest',
                            broadcast: `Sentries unite...`,
                            chance: 100
                        }],[//Despair And Abominations
                            { spawn: [
                                Class.spiderBossAI
                            ],
                            amount: 1,
                            nameType: 'customElite',
                            spawnsAt: 'norm',//norm
                            broadcast: `You hear clicks and hisses in the distance...`,
                            chance: 95
                            },{
                                spawn: [
                                    Class.supremeChaosMakerAI,
                                    Class.supremeMTSOAI
                                ],
                                amount: 1,
                                nameType: 'customElite',
                                spawnsAt: 'norm',
                                broadcast: `Screams echo around you...`,
                                chance: 5
                            }
                        ],[//Celestials
                            {
                                spawn: [
                                    Class.odinAI, Class.athenaAI, Class.caelusAI, Class.demeterAI, Class.hermesAI,Class.minosAI, Class.sisyphusAI, Class.bidenAI,Class.hexashipAI/*Not a celestial but whatever*/,
                                ],
                                amount: 1,
                                nameType: 'a',
                                spawnsAt: 'nest',
                                broadcast: `The World Tremors...`,
                                chance: 80
                            },{//Eternals
                                spawn: [Class.boreasAI, Class.supremeEternal, Class.worldDestroyer,Class.heliosAI,Class.pictorisAI],
                                amount: 1,
                                nameType: 'a',
                                spawnsAt: 'nest',
                                broadcast: ".......",
                                chance: 20
                            }
                        ],[//AWPs
                            {spawn:[
                                Class.AWP_14AI,
                                Class.AWPOrchestra1AI,
                                Class.AWP_24AI,
                                Class.AWP_cos5AI,
                                Class.AWP_11AI,
                                Class.AWP_21AI,
                                Class.AWP_1AI,
                                Class.AWP_psAI,
                                Class.AWP_8AI,
                                Class.awp_nephAI,
                                Class.awp_snipeAI,
                                Class.awp_machineAI,
                                Class.awpPoundAI,
                                Class.AWP_6AI,
                                Class.AWP_7AI,
                                Class.AWP_12AI,
                                Class.AWP_4AI,
                                Class.AWP_8_altAI,
                                Class.AWP_5AI,
                                Class.awpspawnerAI,
                                Class.awp2p112AI,
                                Class.awppolyleader,
                                Class.awpTurtAI,
                                Class.awp19AI,
                                Class.awptorusAI,
                            ],
                            amount: Math.floor(3 * Math.random() + 1),
                            nameType: 'a',
                            spawnsAt: 'nest',
                            broadcast: 'Courtesy of the first army division...',
                            chance: 75
                            },
                            {spawn:[//Stonk AWPS But Not Superbosses like awpalpeph1 or awp-30
                            Class.AWPOrchestra2AI,
                            Class.awpOrchestratan33AI,
                            Class.AWPOrchestra4AI,
                            Class.AWPOrchestra3AI,
                            Class.awp17AI,
                            Class.awp66AI,
                            Class.awp61AI,
                            Class.awp73pi9AI,
                            Class.awpimnotwritingthatAI,
                            Class.awp129AI,
                            Class.HAWP_11AI,
                            Class.awp_33AI,
                            Class.awpsqrt3AI,
                            Class.awptorusbetterAI,
                            Class.awpOrchestra5AI,
                            Class.awp39AI
                            ],
                            amount: Math.floor(3 * Math.random() + 1),
                            nameType: 'a',
                            spawnsAt: 'nest',
                            broadcast: 'Courtesy of the last army division...',
                            chance: 25
                            }
                        ]
                    ];

                    let chosen = (() => {
                        let choice = bosses[Math.floor(Math.random() * bosses.length)];
                        let random = Math.random() * 100 + 1;
                        let chanceAmount = choice[0].chance;
                        let i;

                        for (i = 0; i < choice.length; i++) {
                            if (chanceAmount > random) break;
                            chanceAmount += choice[i + 1].chance;
                        }

                        return choice[i];
                    })();

                    sockets.broadcast(chosen.broadcast);

                    boss.prepareToSpawn(chosen.spawn, chosen.amount, chosen.nameType, chosen.spawnsAt);
                    setTimeout(boss.spawn, 3000);
                } else if (!census.miniboss) timer++;
            };
        })();

        class Spawner {
    constructor(entities) {
        this.entities = [];
        for (let entity of entities) {
            if (typeof entity === "string") {
                this.entities.push(entity)
                continue;
            }
            while (entity[1]--) {
                this.entities.push(entity[0])
            }
        }
        this.bias = 0
        this.biasInfluence = 1
    }
    getEntity() { // Chance to get that entity gets lower the further down it is
        return this.entities[Math.min(Math.random() * this.entities.length * (1 - Math.random() * this.biasInfluence) | 0, this.entities.length-1)]
    }
}
class SimpleSpawner {//simplier spawner
    constructor(entities) {
        this.entities = [];
        for (let entity of entities) {
            if (typeof entity === "string") {
                this.entities.push(entity)
                continue;
            }
            while (entity[1]--) {
                this.entities.push(entity[0])
            }
        }
    }
    getEntity() {
        return this.entities[Math.floor(Math.random() * this.entities.length)]
    }
}


const SancSpawner = new Spawner([
    ["eggSanctuary", 3],
    ["squareSanctuary", 3],
    ["triSanctuary", 2],
    "pentaSanctuary",
    "alphaCrasher",
    "bowedSanc",
    "treasureSanctuary",
    "multiSanctuary",
    "sunKing",
    "snowballSanctuary",
    "flowerSanctuary",
    "eggSanctuarySanctuary",
    "shadowedSanctuary" // mine
]);
        let sancCooldown = 0
        const spawnSancs = (census, id) => {
            if (room.modelMode || (Date.now()-sancCooldown < c.TIME_BETWEEN_SANCS)) return;
            if (census.sancs < room.maxSancs) {
                let spot,
                    max = 10;
                do spot = room.randomType("norm");
                while (dirtyCheck(spot, 120) && max-- > 0);

                let sanc = SancSpawner.getEntity();
                let o = new Entity(spot);
                o.define(Class[sanc]);
                if (c.serverName.includes("The Shattered Beyond")) {o.define(Class.shadowedSanctuary)}
                o.team = -100;
                o.facing = ran.randomAngle()
                let ogOnDead = o.onDead
                o.onDead = () => {
                    sancCooldown = Date.now()
                    ogOnDead()
                }
                o.sandboxId = id
            }
        }

        const CrasherSpawner = new Spawner([
    // CRASHERS
    ["crasher", 100],
    "semiCrushCrasher",
    "semiCrushCrasher217",
    "semiCrushCrasher0",
    "semiCrushCrasher14",
    "fastCrasher",
    "longCrasher",
    "minesweepCrasher",
    "bladeCrasher",
    "invisoCrasher",
    "grouperSpawn",
    "curvyBoy",
    "kamikazeCrasher",
    "wallerCrasher",
    "redRunner1",
    "redRunner2",
    "redRunner3",
    "redRunner4",
    "iceCrusher",
    "greenRunner",
    "purpleRunner",
    "destroyCrasher",
    "boomCrasher",
    "poisonBlades",
    "visDestructia",
    "megaCrushCrasher",
    "walletCrasher",
    "blueRunner",
    "torchKamikaze",
    "orbitcrasher",
    "seerCrasher",
    "tridentCrasher",
    "terminatorCrasher",
    "treaderCrasher",
    "trircle",
    "guy",
    "goldenRect",
    "spikedRunner",
    "clutter",
    "swellFlasher",
    "shrivelFlasher",
    "morpher",

    // SENTRIES
    "sentrySwarmAI",
    "sentryTrapAI",
    "sentryGunAI",
    "sentryRangerAI",
    "flashSentryAI",
    "semiCrushSentryAI",
    "crushSentryAI",
    "bladeSentryAI",
    "skimSentryAI",
    "squareSwarmerAI",
    "squareGunSentry",
    "crusaderCrash",
    "greenSentrySwarmAI",
    "awp39SentryAI",
    "flashGunnerAI",
    "varpAI",
    "scorcherSentry",
    "elecBladeSentry",
    "greenSentrySwarmAI",
    "eggSentryTier1AI",
    "cometLiteAI",
    "jeremyAI"
]);
        const spawnCrasher = (census, id) => {
            if (room.modelMode) return;
            if (census.crasher < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("nest");
                while (dirtyCheck(spot, 30) && max-- > 0);

                let crasher = CrasherSpawner.getEntity();
                let times = Math.random()>0.25 ? 1 : (Math.random()*4|0)+1;

                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class[crasher], ran.chance(c.SHINY_CHANCE)?{isShiny: true}:{});
                    o.team = -100;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnPirahna = (census, id) => {
            if (room.modelMode) return;
            if (3 < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("barn");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.01 ? 1 : (Math.random()*1|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.pirahnaCrasher);
                    o.team = -38;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnPufferfish = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("watr");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.25 ? 1 : (Math.random()*2|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.pufferfish);
                    o.team = -35;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnShark = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("barn");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.02 ? 1 : (Math.random()*1|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.shark);
                    o.team = -36;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnJellyfish = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("barn");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.1 ? .1 : (Math.random()*1|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.jellyfish);
                    //o.team = -36;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnSharkLite = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("barn");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.0002 ? .2 : (Math.random()*1|0)+1;
                for (let i = 0; i < times; i++) {
                    if (times < 2) {
                    let o = new Entity(spot);
                    o.define(Class.sharknadoLite);
                    o.team = -36;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                    }
                }
            }
        };
        const spawnProtJelly = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("barn");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.1 ? .1 : (Math.random()*1|0)+.2;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.protJelly);
                    //o.team = -36;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnSwordfish = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("barn");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.00002 ? 1 : (Math.random()*1|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.swordfish);
                    o.team = -37;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnEel = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("barn" || "watr");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.25 ? 1 : (Math.random()*1|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.electricEel);
                    o.team = -39;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnSalmon = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("watr");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.6 ? 1 : (Math.random()*14|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.salmon);
                    o.team = -39;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnTrout = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("watr");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.4 ? 1 : (Math.random()*7|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.trout);
                    //o.team = -39;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
        const spawnBoxfish = (census, id) => {
            if (room.modelMode) return;
            if (census.fish < room.maxCrashers) {
                let spot,
                    max = 10;
                do spot = room.randomType("watr" || "barn");
                while (dirtyCheck(spot, 30) && max-- > 0);
                let times = Math.random()>0.11 ? 1 : (Math.random()*3|0)+1;
                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class.yellowBoxfish);
                    //o.team = -39;
                    o.damage *= 1 / 2;
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                }
            }
        };
const sbSpawner = new SimpleSpawner([
  ["echorinth", 4000],
  ["nyxaloth", 4000],
  ["bloodyMaryAI", 90],
  ["Voidling1", 6000],
  ["Voidling2", 3000],
  ["Voidling3", 1500],
  ["Voidling4", 500],
  ["Voidling5", 200],
  ["Voidling6", 50],
  ["Voidling7", 10],
  ["Voidling8", 2],
  ["Voidling9", 1],
  ["supremeChaosMakerAI", 5],
  ["shadowCoreAI", 150],
  ["shadowShardAI", 650],
  ["voidColony", 8],
  ["voidCrasher", 250],
  ["voidSentry", 130],
  ["RecursedUltraTwin", 1],
  ["viewerAI", 90],
  ["reflector", 2000]
])
        const spawnSbEntities = (census, id) => {
            if (!c.serverName.includes("The Shattered Beyond")) return;
            if (census.sbEntities < room.maxSbEntities) {
                let spot,
                    max = 10;
                do spot = room.randomType("sb");
                while (dirtyCheck(spot, 30) && max-- > 0);

                let crasher = sbSpawner.getEntity();
                let times = Math.random()>0.15 ? 1 : 2;

                for (let i = 0; i < times; i++) {
                    let o = new Entity(spot);
                    o.define(Class[crasher], ran.chance(c.SHINY_CHANCE)?{isShiny: true}:{});
                    o.team = -100;
                    //o.damage *= 1 / 2;
                    o.name = ran.chooseBossName("customElite", 1)[0];
                    if (!o.dangerValue) {
                        o.dangerValue = 3 + Math.random() * 3 | 0;
                    }
                    o.sandboxId = id
                    o.type = "sbEntities"
                    o.miscIdentifier = "None"
                    o.gotSpawned = true
                    setTimeout(() => {o.gotSpawned = false}, 50)
                }
            }
        };
        const makeNPCs = (() => {
            if (room.modelMode) return;
            if (c.serverName.includes("Boss")) {
                let sanctuaries = 0;
                let spawn = (loc, team) => {
                    let o = new Entity(loc);
                    o.define(Class[team === -1 ? "trapperDominatorAISanctuary" : "myMinusOneHundredDomi"]);//trapperDominatorAISanctuary
                    o.team = team;
                    if (c.SMODE == "Survival") {if (o.team == -100) {o.passive = true} else {o.define(Class.trapperDominatorSurvivalModeAI)}}
                    //if (c.SMODE == "Attack" && team == -1) {o.define(Class.sancAttackAI)}
                    //o.DAMAGE = o.DAMAGE / 10 //parce que sinon c cheat
                    o.color = getTeamColor(team);
                    o.skill.score = 111069;
                    o.name = ""//"Sanctuary";
                    o.nameColor = "#00f7ff"//mine
                    //o.SIZE = c.WIDTH / c.X_GRID / 10;
                    o.isDominator = true;
                    //o.AUTOFIRE = true; //mine
                    o.controllers = [new ioTypes.nearestDifferentMaster(o), new ioTypes.spinWhileIdle(o), new ioTypes.alwaysFire(o)];//always Fire mine
                    /*if (o.team != -100) {o.onTick = () => {
                        switch (room.domiTier) {
                            case 2: 
                                o.define(Class.trapperSancTier2)
                            break;
                            default:
                                o.define(Class.trapperSancTier1)
                                break;
                        }
                    }
                }*/
                    o.onDead = function () {
                        if (o.team === -100) {
                            spawn(loc, -1);
                            room.setType("bas1", loc);
                            sockets.broadcast("A Sanctuary has been recaptured!");
                            if (sanctuaries < 1) {
                                sockets.broadcast("The game is saved!");
                            }
                            sanctuaries++;
                        } else {
                            sanctuaries--;
                            if (sanctuaries < 1) {
                                sockets.broadcast("Your team will lose in 90 seconds");
                                function tick(i) {
                                    if (sanctuaries > 0) {
                                        return;
                                    }
                                    if (i <= 0) {
                                        sockets.broadcast("Your team has lost!");
                                        setTimeout(closeArena, 2500);
                                        return;
                                    }
                                    if (i % 15 === 0 || i <= 10) {
                                        sockets.broadcast(`${i} seconds until your team loses!`);
                                    }
                                    setTimeout(function retick() {
                                        tick(i - 1);
                                    }, 1000);
                                }
                                tick(91);
                            }

                            spawn(loc, -100);
                            room.setType("domi", loc);
                            sockets.broadcast("A Sanctuary has been captured by the bosses!");
                        }
                    }
                }
                for (let loc of room["bas1"]) {
                    sanctuaries++;
                    spawn(loc, -1);
                }
                bossRushLoop();
            }
            if (room.gameMode === "tdm" && c.DO_BASE_DAMAGE && !c.serverName.includes("Boss Rush")) {
                let spawnBase = (loc, team, type) => {
                    let o = new Entity(loc);
                    o.define(type);
                    o.team = -team;
                    o.color = [10, 12, 11, 15, 3, 35, 36, 0][team - 1];
                    o.onDead = () => spawnBase(loc, team, type);
                }
                for (let i = 1; i < room.teamAmount + 1; i++) {
                    for (let loc of room["bas" + i]) {
                        c.serverName.includes("Score War") ? spawnBase(loc, i, Class.scoreBase) : spawnBase(loc, i, Class.baseProtector);//mine
                    }
                    for (let loc of room["bad" + i]) {
                        spawnBase(loc, i, Class.baseDroneSpawner);
                    }
                }
                if ((c.serverName.includes("Domination") || c.SPAWN_DOMINATORS) && room.domi.length > 0) (new Domination()).init();
                if (c.SOCCER) soccer.init();
                if (c.serverName.includes("Mothership"))
                    for (let i = 1; i < room.teamAmount + 1; i++)
                        for (let loc of room["mot" + i]) mothershipLoop(loc, i);
            }
            if (c.serverName.includes("Void Walkers")) {
                util.log("Initializing Void Walkers")
                voidwalkers()
            }
            if (c.serverName.includes("The Shattered Beyond")) {
                util.log("Initializing Spooky Scary Game")
                shatteredBeyond()
            }
            if (c.serverName.includes("The Doom Walk")) {
                util.log("Initializing The Doom Walk")
                doomwalkers()
            }
            return () => {
                if (!room.arenaClosed && !room.modelMode && !c.RANKED_BATTLE){
                    if (c.SANDBOX) {
                        for (let i = 0; i < global.sandboxRooms.length; i++) {
                            let room = global.sandboxRooms[i];
                            //// Sandbox census
                            let census = {
                                crasher: 0,
                                miniboss: 0,
                                tank: 0,
                                trap: 0
                            }
                            entities.forEach(instance => {
                                if (instance.sandboxId === room.id && census[instance.type] != null) census[instance.type]++;
                            });

                            if(room.spawnCrashers)spawnCrasher(census, room.id);
                            //spawnBosses(census, room.id); Not in sandbox

                            //// The rest of the sandbox stuff like bots and buttons
                            // Set up dummies
                            if (!room.didSetUp) {
                                room.didSetUp = true
                                function spawnDpsButtonButViaCommand() {
                                    const button = new Entity({
                                        x: 1000,
                                        y: 1000
                                    });
                                    button.define(Class.button);
                                    button.pushability = button.PUSHABILITY = 0;
                                    button.godmode = true
                                    button.team = -101;
                                    button.totalDamage = 0
                                    button.averageDps = []
                                    button.lastHitTime = Date.now()
                                    //button.sandboxId = room.id
                                    button.settings.noNameplate = false
                                    button.type = "utility"
                                    button.hitsOwnType = "never"
                                    button.settings.leaderboardable = false
                                    button.SIZE = 35
                                    button.DAMAGE = 15
                                    button.onDamaged = function (me, them, amount) {
                                        if (!amount) return;
                                        button.totalDamage += amount
                                    }
                                    button.onTick = function () {
                                        if (Date.now() - button.lastHitTime > 1000) {
                                            button.lastHitTime = Date.now()

                                            if (button.averageDps.length > 6) {
                                                button.averageDps.shift()
                                            }
                                            button.averageDps.push(button.totalDamage)

                                            button.name = `${(button.averageDps.reduce((total, value) => total + value, 0) / button.averageDps.length).toFixed(2)} Average DPS`
                                            button.totalDamage = 0
                                        }
                                    }
                                    button.onDead = spawnDpsButtonButViaCommand
                                    button.refreshBodyAttributes();
                                }

                                function spawnDpsButton() {
                                    const button = new Entity({
                                        x: 500,
                                        y: 500
                                    });
                                    button.define(Class.button);
                                    button.pushability = button.PUSHABILITY = 0;
                                    button.godmode = true
                                    button.team = -101;
                                    button.totalDamage = 0
                                    button.averageDps = []
                                    button.lastHitTime = Date.now()
                                    button.sandboxId = room.id
                                    button.settings.noNameplate = false
                                    button.type = "utility"
                                    button.hitsOwnType = "never"
                                    button.settings.leaderboardable = false
                                    button.SIZE = 50
                                    button.DAMAGE = 15
                                    button.onDamaged = function (me, them, amount) {
                                        if (!amount) return;
                                        button.totalDamage += amount
                                    }
                                    button.onTick = function () {
                                        if (Date.now() - button.lastHitTime > 1000) {
                                            button.lastHitTime = Date.now()

                                            if (button.averageDps.length > 6) {
                                                button.averageDps.shift()
                                            }
                                            button.averageDps.push(button.totalDamage)

                                            button.name = `${(button.averageDps.reduce((total, value) => total + value, 0) / button.averageDps.length).toFixed(2)} Average DPS`
                                            button.totalDamage = 0
                                        }
                                    }
                                    button.onDead = spawnDpsButton
                                    button.refreshBodyAttributes();
                                }
                                spawnDpsButton()

                                let explainText = new Entity({
                                    x: -45,
                                    y: -75
                                })
                                explainText.define(Class.text)
                                explainText.name = "Ram into the buttons to press them"
                                explainText.size = 20
                                explainText.sandboxId = room.id

                                function spawnBotButton(status) {
                                    const button = new Entity({
                                        x: -45,
                                        y: -30
                                    });
                                    button.define(Class.button);
                                    button.pushability = button.PUSHABILITY = 0;
                                    button.godmode = true
                                    button.REGEN = 1000000
                                    button.team = -101;
                                    button.totalDamage = 0
                                    button.averageDps = []
                                    button.lastHitTime = Date.now()
                                    button.sandboxId = room.id
                                    button.settings.noNameplate = false
                                    button.type = "utility"
                                    button.hitsOwnType = "never"
                                    button.settings.leaderboardable = false
                                    button.color = status ? 11 : 12
                                    button.name = status ? "Bots enabled" : "Bots disabled"
                                    if (status) {
                                        room.botCap = 5
                                    } else {
                                        room.botCap = 0
                                    }
                                    button.onDamaged = function (me, them, amount) {
                                        if (!them.isPlayer) {
                                            return
                                        }
                                        me.kill()
                                    }
                                    button.onDead = () => {
                                        setTimeout(() => {
                                            spawnBotButton(!status)
                                        }, 1000)
                                    }
                                    button.refreshBodyAttributes();
                                }
                                spawnBotButton(false)

                                function crasherSpawningButton(status) {
                                    const button = new Entity({
                                        x: -45,
                                        y: 60
                                    });
                                    button.define(Class.button);
                                    button.pushability = button.PUSHABILITY = 0;
                                    button.godmode = true
                                    button.team = -101;
                                    button.totalDamage = 0
                                    button.averageDps = []
                                    button.lastHitTime = Date.now()
                                    button.sandboxId = room.id
                                    button.settings.noNameplate = false
                                    button.type = "utility"
                                    button.hitsOwnType = "never"
                                    button.settings.leaderboardable = false
                                    button.color = status ? 11 : 12
                                    button.name = status ? "Crashers enabled" : "Crashers disabled"
                                    if (status) {
                                        room.spawnCrashers = true
                                    } else {
                                        room.spawnCrashers = false
                                    }
                                    button.onDamaged = function (me, them, amount) {
                                        if (!them.isPlayer) {
                                            return
                                        }
                                        me.kill()
                                    }
                                    button.onDead = () => {
                                        setTimeout(() => {
                                            crasherSpawningButton(!status)
                                        }, 1000)
                                    }
                                    button.refreshBodyAttributes();
                                }
                                crasherSpawningButton(false)

                                function foodSpawningButton(status) {
                                    const button = new Entity({
                                        x: -45,
                                        y: 150
                                    });
                                    button.define(Class.button);
                                    button.pushability = button.PUSHABILITY = 0;
                                    button.godmode = true
                                    button.team = -101;
                                    button.totalDamage = 0
                                    button.averageDps = []
                                    button.lastHitTime = Date.now()
                                    button.sandboxId = room.id
                                    button.settings.noNameplate = false
                                    button.type = "utility"
                                    button.hitsOwnType = "never"
                                    button.settings.leaderboardable = false
                                    button.color = status ? 11 : 12
                                    button.name = status ? "Food enabled" : "Food disabled"
                                    if (status) {
                                        room.spawnFood = true
                                    } else {
                                        room.spawnFood = false
                                    }
                                    button.onDamaged = function (me, them, amount) {
                                        if (!them.isPlayer) {
                                            return
                                        }
                                        me.kill()
                                    }
                                    button.onDead = () => {
                                        setTimeout(() => {
                                            foodSpawningButton(!status)
                                        }, 1000)
                                    }
                                    button.refreshBodyAttributes();
                                }
                                foodSpawningButton(true)
                            }

                            // Do bots, remove dead ones first
                            room.bots = room.bots.filter(e => {
                                return !e.isDead();
                            });
                            if (room.bots.length < room.botCap && !global.arenaClosed) {
                                for (let j = room.bots.length; j < room.botCap; j++) {
                                    if (Math.random() > .5) {
                                        const bot = spawnBot(null);
                                        bot.sandboxId = room.id;
                                        room.bots.push(bot);
                                    }
                                }
                            }
                            let botIndex = 0
                            for (let o of room.bots) {
                                if (room.bots.length > room.botCap) {
                                    o.kill()
                                    room.bots.splice(botIndex, 1)
                                }
                                if (o.skill.level < 60) {
                                    o.skill.score += 35;
                                    o.skill.maintain();
                                }
                                if (o.upgrades.length && Math.random() > 0.5 && !o.botDoneUpgrading) {
                                    o.upgrade(Math.floor(Math.random() * o.upgrades.length));
                                    if (Math.random() > .9) {
                                        o.botDoneUpgrading = true;
                                    }
                                }
                                botIndex++
                            }
                        }
                    } else {
                        let census = {
                            crasher: 0,
                            miniboss: 0,
                            tank: 0,
                            fish: 0,
                            sancs: 0,
                            sbEntities: 0
                        };

                        entities.forEach(instance => {
                            if (census[instance.type] != null) {
                                census[instance.type]++;
                            } else if (instance.sanctuaryType !== "None" || instance.miscIdentifier === "Sanctuary Boss") {
                                census.sancs++
                            }
                        });

                        spawnCrasher(census);
                        spawnBosses(census);
                        spawnSancs(census);
                        spawnSbEntities(census);
        if (c.SPAWN_FISHES) {
        spawnSalmon(census);
        spawnTrout(census);
        spawnJellyfish(census);
        spawnPufferfish(census);
        spawnSwordfish(census);
        spawnEel(census);
        spawnShark(census);
        spawnProtJelly(census);
        spawnSharkLite(census);
        spawnBoxfish(census);
        spawnPirahna(census);
    }
                        if (room.maxBots > 0) {
                            bots = bots.filter(body => !body.isGhost && body.isAlive());
                            if (bots.length < room.maxBots) spawnBot();
                            for (let o of bots) {
                                if (o.skill.level < 60) {
                                    o.skill.score += 35;
                                    o.skill.maintain();
                                }
                                /*if (o.upgrades.length && Math.random() > .15 && !o.botDoneUpgrading) {
                                    o.upgrade(Math.floor(Math.random() * o.upgrades.length));
                                    if (Math.random() > .999) {
                                        o.botDoneUpgrading = true;
                                    }
                                }*/
                            }
                        }
                    }
                }
            };
        })();
        const easter = false
        const createFood = (() => {
            function spawnSingle(location, type, id) {
                if (c.SANDBOX && global.sandboxRooms.length < 1) {
                    return {};
                }
                let o = new Entity(location);
                o.define(Class[type], ran.chance(c.SHINY_CHANCE)?{isShiny: true}:{});
                o.ACCELERATION = .015 / (o.size * 0.2);
                o.facing = ran.randomAngle();
                o.team = -100;
                o.PUSHABILITY *= .5;
                if (easter) {o.label = "Easter " + o.label}
                if (c.SANDBOX) {
                    o.sandboxId = id || ran.choose(global.sandboxRooms).id;
                }
                o.refreshBodyAttributes()
                return o;
            };

            const FoodSpawner = new Spawner([
    // Normal
    "egg",
    "square",
    "triangle",
    "pentagon",
    "hexagon"
])
const AquaFoodSpawner = new Spawner([
    // Normal
    "ammonite",
    "sandDollar",
    "limpet",
    "starfishShape",
    "seaUrchin",
    "starfish62",
    "starfish3",
    "starfish162",
    "starfish263",
    "starfish222",
    "seaUrchin"
])
            function spawnFood(id){
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.random();
                }while (dirtyCheck(location, 100) && room.isIn("nest", location));

                // Spawn groups of food
                for (let i = 0, amount = (Math.random() * 20) | 0; i < amount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    spawnSingle({
                    x: location.x + Math.cos(angle) * (Math.random() * 50),
                    y: location.y + Math.sin(angle) * (Math.random() * 50)
                    }, FoodSpawner.getEntity(), id);
                }
            }
            function spawnAquaFood(id){
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.random();
                }while (dirtyCheck(location, 100) && room.isIn("watr", location));

                // Spawn groups of food
                for (let i = 0, amount = (Math.random() * 10) | 0; i < amount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    spawnSingle({
                    x: location.x + Math.cos(angle) * (Math.random() * 50),
                    y: location.y + Math.sin(angle) * (Math.random() * 50)
                    }, AquaFoodSpawner.getEntity(), id);
                }
            }
            const NestSpawner = new Spawner([//hexagon changed !
    "pentagon",
    "betaPentagon",
    "hexagon",
    "alphaPentagon",
    "splitterPentagon",
])
            function spawnNestFood(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("nest");
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, NestSpawner.getEntity(), id);
                shape.isNestFood = true;
            }
const SbSpawner = new Spawner([
    "shadowegg",
    "shadowsquare",
    "shadowtriangle",
    "shadowpentagon",
    "shadowbetaPentagon",
    "shadowalphaPentagon",
    "voidEgg",
    "voidSquare",
    "voidTriangle"
])
            function spawnSbFood(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("sb");
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, SbSpawner.getEntity(), id);
                shape.isNestFood = true;
            }
            const compoundSpawner = new Spawner([//my biomes
            //shape.controllers.push(new ioTypes.nearestDifferentMaster(shape), new ioTypes.mapTargetToGoal(shape)) to put in for noice ennemies
    "elecSquare",
    "elecTriangle",
    "elecPentagon",
    "elecBladeSentrySpawner",
])
            function spawnCompound(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("domi");
                    //location = room.randomType("compound");
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, compoundSpawner.getEntity(), id);
                shape.isCompoundFood = true;
                //shape.controllers.push(new ioTypes.nearestDifferentMaster(shape), new ioTypes.mapTargetToGoal(shape))
            }
            const blightlandsSpawner = new Spawner([//my biomes
    "greenSquare",
    "greenTriangle",
    "greenPentagon",
    "greenBetaPentagon",
    "greenSentrySwarmAISpawner",
])
            function spawnBlightlands(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("dom3");//blightlands
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, blightlandsSpawner.getEntity(), id);
                shape.isBlightFood = true;
            }
            const forestSpawner = new Spawner([//my biomes
    "square",
    "triangle",
    "forestTree",
    "applePolySpawner",
    "lemonPolySpawner",
    "orangePolySpawner",
])
            function spawnForest(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("forest");//forest
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, forestSpawner.getEntity(), id);
                shape.isForestFood = true;
            }
            const iceSpawner = new Spawner([//my biomes
    "iceEgg",
    "iceSquare",
    "iceTriangle",
    "icePentagon",
    "iceCrushSentryAISpawner",
])
            function spawnIce(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("dom8");//ice
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, iceSpawner.getEntity(), id);
                shape.isIceFood = true;
            }
            const desertSpawner = new Spawner([//my biomes
    "sandSquare",
    "sandTriangle",
    "sandPentagon",
])
            function spawnDesert(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("dom6");//desert
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, desertSpawner.getEntity(), id);
                shape.isDesertFood = true;
            }
            const hellSpawner = new Spawner([//my biomes
    "orangeSquare",
    "orangeTriangle",
    "orangePentagon",
    "devilishCrasherAISpawner",
    "devilishSquare",
    "devilishTriangle",
    "devilishPentagon"
])
            function spawnHell(id) {
                let location, i = 8;
                do {
                    if (!i--) return;
                    location = room.randomType("dom2");//hell
                } while (dirtyCheck(location, 100))
                let shape = spawnSingle(location, hellSpawner.getEntity(), id);
                shape.isHellFood = true;
            }
            const rareSpawner = new Spawner([//my biomes
            "gem",
            "shinyegg",
            "shinysquare",
            "shinytriangle",
            "shinypentagon",
            "shinyhexagon",
            "jewel",
            "legendaryegg",
            "legendarysquare",
            "legendarytriangle",
            "legendarypentagon",
            "legendaryhexagon",
            "silhouette",
            "shadowegg",
            "shadowsquare",
            "shadowtriangle",
            "shadowpentagon",
            "shadowhexagon",
            "colorium",
            "rainbowegg",
            "rainbowsquare",
            "rainbowtriangle",
            "rainbowpentagon",
            "rainbowhexagon",
            "transgender",
            "transegg",
            "transsquare",
            "transtriangle",
            "transpentagon",
            "transhexagon",
            "treasureSanctuary",
            "amethyst",
            "mythicalegg",
            "mythicalsquare",
            "mythicaltriangle",
            "mythicalpentagon",
            "mythicalhexagon",
            "holyGem",
            "sacredegg",
            "sacredsquare",
            "sacredtriangle",
            "sacredpentagon",
            "sacredhexagon",
            "platinus",
            "albinoegg",
            "albinosquare",
            "albinotriangle",
            "albinopentagon",
            "albinohexagon",
            "seizureGem",
            "epilepsyegg",
            "epilepsysquare",
            "epilepsytriangle",
            "epilepsypentagon",
            "epilepsyhexagon",
            "tetrahedron",
            "cube",
            "octahedron",
            "dodecahedron",
            "icosahedron",
            "tesseract",
            "mysticStar"
        ])
                    function spawnRare(id) {
                        let location, i = 8;
                        do {
                            if (!i--) return;
                            location = room.randomType("domi");//desert
                        } while (dirtyCheck(location, 100))
                        let shape = spawnSingle(location, rareSpawner.getEntity(), id);
                        shape.isRareFood = true;
                    }
            return () => {
                // SANDBOX CENSUS
                if (c.SANDBOX) {
                    for (let sbxroom of global.sandboxRooms) {
                        if (!sbxroom.spawnFood) continue;
                        const census = (() => {
                            let food = 0;
                            let nestFood = 0;
                            let aquaFood = 0;
                            entities.forEach(instance => {
                                if (instance.type === "food" && instance.sandboxId === sbxroom.id) {
                                    if (instance.isNestFood) nestFood++;
                                    else food++;
                                }
                                if (instance.type === "aquaticFood" && instance.sandboxId === sbxroom.id) {
                                    aquaFood++;
                                }
                            });
                            return {
                                food,
                                nestFood,
                                aquaFood
                            };
                        })();
                        if (census.food < room.maxFood) {
                            spawnFood(sbxroom.id);
                        }
                        if (census.nestFood < room.maxNestFood) {
                            spawnNestFood(sbxroom.id)
                        }
                if (census.aquaFood < room.maxFood && c.SPAWN_FISHES) {
                    spawnAquaFood();
                }
                    }
                    return
                }

                // NORMAL GAMEMODE CENSUS
                const census = (() => {
                    let food = 0;
                    let nestFood = 0;
                    let compoundFood = 0;
                    let blightFood = 0;
                    let forestFood = 0;
                    let iceFood = 0;
                    let desertFood = 0;
                    let hellFood = 0;
                    let rareFood = 0;
                    let aquaFood = 0;
                    entities.forEach(instance => {
                        if (instance.type === "food") {
                            if (instance.isNestFood){
                                nestFood++;
                            }else if (instance.isCompoundFood) {
                                compoundFood++;
                            }else if (instance.isBlightFood){
                                blightFood++;
                            }else if (instance.isForestFood) {
                                forestFood++;
                            }else if (instance.isIceFood) {
                                iceFood++;
                            }else if (instance.isDesertFood) {
                                desertFood++;
                            }else if (instance.isHellFood) {
                                hellFood++;
                            }else if (instance.isRareFood/* && c.RARE_NEST*/) {
                                rareFood++;
                            }else{
                                food++;
                            }
                        }
                        if (instance.type === "aquaticFood" && c.SPAWN_AQUAFOOD) {
                          aquaFood++;
                        }
                    });
                    return {
                        food,
                        nestFood,
                        compoundFood,
                        blightFood,
                        forestFood,
                        iceFood,
                        desertFood,
                        hellFood,
                        rareFood,
                        aquaFood
                    };
                })();
                if (census.food < room.maxFood) {
                    spawnFood();
                }
                if (census.nestFood < room.maxNestFood) {//biomes spawners
                    if(c.serverName.includes("The Shattered Beyond")) {spawnSbFood()} else {spawnNestFood()}
                    //spawnCompoundEnnemies()
                }
                if (census.aquaFood < room.maxFood && c.SPAWN_FISHES) {
                    spawnAquaFood();
                }
                const compoundFoodMaxLimit = 10     //custom food limits here "mine"
                const blighlandsFoodMaxLimit = 15
                const forstFoodMaxLimit = 15
                const iceFoodMaxLimit = 20
                const desertFoodMaxLimit= 5
                const hellFoodMaxLimit = 15
                const rareFoodMaxLimit = 3
                if (census.compoundFood < compoundFoodMaxLimit && c.serverName.includes("Custom MMO")) {spawnCompound()}
                if (census.blightFood < blighlandsFoodMaxLimit && c.serverName.includes("Custom MMO")) {spawnBlightlands()}
                if (census.forestFood < forstFoodMaxLimit && c.serverName.includes("Custom MMO")) {spawnForest()}
                if (census.iceFood < iceFoodMaxLimit && c.serverName.includes("Custom MMO")) {spawnIce()}
                if (census.desertFood < desertFoodMaxLimit && c.serverName.includes("Custom MMO")) {spawnDesert()}
                if (census.hellFood < hellFoodMaxLimit && c.serverName.includes("Custom MMO")) {spawnHell()}
                if (census.rareFood < rareFoodMaxLimit && c.RARE_NEST /*&& Math.random() > 0.8*/) {spawnRare()}
            };
        })();
        global.utility.spawnBosses = (type)=>(spawnBosses({spawnID: 3, bossType: type}))//mine
        global.utility.spawnDPSButton = () => (spawnDpsButtonButViaCommand())
        return () => {
            if (!room.modelMode) {
                createFood();
                makeNPCs();
            }
        };
    })();

    setInterval(gameLoop, room.cycleSpeed)
    gameLoop()

    setInterval(maintainLoop, 1000/*200*/);
    maintainLoop()

    global.utility.execute = (script, body)=>{ // Used for live events. For Devs and Room Host.
        if (c.testingMode == Infinity && !body) return;
        global.utility.temp = body
        eval("let body = global.utility.temp; delete global.utility.temp;"+script)
    }
    global.utility.strictExecute = (script,body)=>{ // Used by Summon. Requires restriction to not abuse with custom entities
        new Function("o", "ioTypes", atob("InVzZSBzdHJpY3QiO2xldCBnbG9iYWxUaGlzLG5hbWUsb25tZXNzYWdlLG9ubWVzc2FnZWVycm9yLGNhbmNlbEFuaW1hdGlvbkZyYW1lLGNsb3NlLHBvc3RNZXNzYWdlLHJlcXVlc3RBbmltYXRpb25GcmFtZSx3ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbSx3ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbVN5bmMsd2Via2l0UmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVN5bmNVUkwsd2Via2l0UmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTCx1c2VyU29ja2V0LG9kZGlmeSxzdGFydFNlcnZlcixnbG9iYWwsdXRpbGl0eSxwcm9jZXNzLGZ0RW5jb2RlLGZ0RGVjb2RlLG1hcENvbmZpZyxyZXF1aXJlLGluaXRFeHBvcnRDb2RlLHNlcnZlclN0YXRzLG1pbmlmeU1vZHVsZXMsZnV6enlzb3J0LGMsc2FuZGJveFJvb21zLG1vY2t1cHMsZXhwb3J0TmFtZXMsYWRkTmV3Q2xhc3MsdXBkYXRlQ2xhc3MsZWRpdG9yQ2hhbmdlRW50aXR5LGZsYWcsbmV3QnJvYWRjYXN0aW5nLHNvY2tldHMscGxhY2VPYnN0YWNsZXMsZ2VuZXJhdGVNYXplPXVuZGVmaW5lZDs=")+script)(body, ioTypes);
    }

    //let socketUpdateKey = 0;
    setInterval(function () {
    for (let instance of clients) {
        // Only process players who have successfully spawned and have a view
        if (!instance.status.hasSpawned || !instance.view || !instance.open) continue;
        
        let player = instance.player;
        let socket = instance;
        let camera = socket.camera; // The camera state
        let body = player.body; // The player's body, might be null if dead

    let fov = 1000; // Default FOV
    if (body != null && body.isAlive()) {
        camera.x = body.x;
        camera.y = body.y;
        camera.vx = body.velocity.x;
        camera.vy = body.velocity.y;
        fov = body.fov;
    }
    camera.fov = fov;
        // Define a search area (AABB) based on the camera's position and FOV.
        // We create a temporary object with the structure the grid's getAABB expects.
        const searchArea = {
            _AABB: grid.getAABB({
                x: camera.x,
                y: camera.y,
                size: camera.fov * 0.6 // Approximate the view range for the grid query
            })
        };



        let visible = [];
      
        // Query the grid for entities whose AABBs overlap with the search area.
        // This gives us a list of entities that are *potentially* visible.
        grid.getCollisions(searchArea, (entity)=>{
            // Apply necessary checks from the original logic:
            if (
                !entity.isActive ||
                entity.isGhost || 
                !entity.isAlive() || 
                !entity.settings.drawShape ||
                (c.SANDBOX && entity.sandboxId !== socket.sandboxId) || 
                (c.RANKED_BATTLE && entity.roomId !== socket.roomId) ||
                (body && !body.seeInvisible && entity.alpha < 0.1) 
                // Note: The grid query already handled the main distance check.
                // If more precise frustum culling is needed, add a check here, but AABB is usually sufficient for performance gain.
            ) {
                return; // Skip entities that don't meet visibility criteria
            }

            if (entity.animation) {
                socket.animationsToDo.set(entity.id, entity.animation);
            }
            let output = perspective(entity, player, flatten(entity.camera(entity.isTurret))); // perspective applies team color overrides etc.

            if (output) { // Add the processed data to the visible list
                visible.push(output);
            }
        })
        let numberInView = visible.length;

        if (body != null && body.displayText !== socket.oldDisplayText) {
            socket.oldDisplayText = body.displayText;
            socket.talk("displayText", true, body.displayText, body.displayTextColor);
        } else if (body != null && !body.displayText && socket.oldDisplayText) {
            socket.oldDisplayText = null;
            socket.talk("displayText", false);
        }

if (c.serverName.includes("Growth") && player.body != null && !player.body.hasDreadnoughted && player.body.skill.score >= 2_000_000) {
                            player.body.hasDreadnoughted = true;
                            player.body.upgrades.push({
                                class: "dreadnoughts",// class: "dreadnoughts",
                                level: 60,
                                index: Class.dreadnoughts.index,//index: Class.dreadnoughts.index,
                                tier: 4
                            });
                        }     
                        if (c.serverName.includes("Arms Race") && player.body != null && !player.body.hasDreadnoughted && player.body.skill.score >= 2_000_000) {
                            player.body.hasDreadnoughted2 = true;
                            player.body.hasDreadnoughted = true;
                            player.body.upgrades.push({
                                class: "armsRaceTankRandomizer",
                                level: 60,
                                index: Class.armsRaceTankRandomizer.index,
                                tier: 4
                            });
                        } if (c.serverName.includes("Arms Race") && player.body != null && !player.body.hasDreadnoughted2 && player.body.skill.score >= 4_000_000 && !room.fairPlay) {
                            player.body.hasDreadnoughted2 = true;
                            player.body.upgrades.push({
                                class: "arms_race",
                                level: 60,
                                index: Class.arms_race.index,
                                tier: 4
                            });
                        } if (!c.serverName.includes("Arms Race") && !c.TOURNEY) {
                            if (player.body != null && !(player.body.isMothership || player.body.isDominator || player.body.isBot)) {
                                // Tier 6, 7, 8, 9 thingy
                                if (player.body != null && !player.body.tier_6 && player.body.skill.score >= 500_000) {
                                    player.body.tier_6 = true;
                                    player.body.upgrades.push({
                                        class: "tier_6",
                                        level: 60,
                                        index: Class.tier_6.index,
                                        tier: 4
                                    });
                                  player.body.rewardManager(-1, "tier6")
                                }
                                if (player.body != null && !player.body.tier_7 && player.body.skill.score >= 1_000_000) {
                                    player.body.tier_7 = true;
                                    player.body.upgrades.push({
                                        class: "tier_7",
                                        level: 60,
                                        index: Class.tier_7.index,
                                        tier: 4
                                    });
                                  player.body.rewardManager(-1, "tier7")
                                }
                                if (player.body != null && !player.body.tier_8 && player.body.skill.score >= 2_000_000) {
                                    player.body.tier_8 = true;
                                    player.body.upgrades.push({
                                        class: "tier_8",
                                        level: 60,
                                        index: Class.tier_8.index,
                                        tier: 4
                                    });
                                  player.body.rewardManager(-1, "tier8")
                                }if (player.body != null && !player.body.tier_9 && player.body.skill.score >= 5_000_000) {
                                    player.body.tier_9 = true;
                                    player.body.upgrades.push({
                                        class: "tier_9",
                                        level: 60,
                                        index: Class.tier_9.index,
                                        tier: 4
                                    });
                                  player.body.rewardManager(-1, "tier9")
                                }
                            }
                        }
         // Existing dead player message logic (keep this as is)
        if (body != null && body.isDead() && !socket.status.deceased) {
            socket.status.deceased = true;
            const records = player.records(); 
            socket.status.previousScore = records[0];
            socket.talk("F", ...records); // Send death record to client
             if (records[0] > 300000) { // Check for high scores for logging/rewards
                 const totalKills = Math.round(records[2] + (records[3] / 2) + (records[4] * 2));
                 if (totalKills >= Math.floor(records[0] / 100000)) {
                     sendRecordValid({ // Assuming sendRecordValid is defined elsewhere
                         name: socket.name || "Unnamed",
                         discord: socket.betaData.discordID,
                         tank: body.labelOverride || body.label,
                         score: records[0],
                         totalKills: totalKills,
                         timeAlive: util.formatTime(records[1] * 1000),
                     });
                 }
                 if (body.miscIdentifier !== "No Death Log") {
                     util.info(trimName(body.name) + " has died. Final Score: " + body.skill.score + ". Tank Used: " + body.label + ". Players: " + clients.length + "."); // Assuming util.info and trimName are defined elsewhere
                 }
                 socket.beginTimeout();
             }
             player.body = null; // Dereference the dead body
        }


        // Send the update packet to the client
        socket.talk(
            "u",
            (body != null ? (body.cameraShiftFacing != null) : false), // Flag for camera shift
            room.lastCycle, // Timestamp (assuming room.lastCycle is updated in gameLoop)
            camera.x + .5 | 0, // Camera X (rounded)
            camera.y + .5 | 0, // Camera Y (rounded)
            fov + .5 | 0, // FOV (rounded)
            // camera.vx, camera.vy, // Omitted velocity as per original packet format change
            ...(player.gui ? player.gui() : []), // Player GUI data (assuming player.gui() is defined elsewhere and returns an array)
            numberInView, // Count of visible entities
            ...visible.flat() // Flattened data for visible entities
        );
    }

    //newLogs.network.stop();
    }, c.visibleListInterval)

    /*const combineStats = array => {
    try {
        let data = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        for (let component of array)
            for (let i = 0; i < data.length; ++i) data[i] *= component[i];
        if (data.some(e => isNaN(e))) {
            throw new Error("Invalid combine")
        }
        return {
            reload: data[0],
            recoil: data[1],
            shudder: data[2],
            size: data[3],
            health: data[4],
            damage: data[5],
            pen: data[6],
            speed: data[7],
            maxSpeed: data[8],
            range: data[9],
            density: data[10],
            spray: data[11],
            resist: data[12]
        };
    } catch (e) {
        console.log(e);
        console.log(JSON.stringify(array));
    }
};*/
        if(c.serverName.includes("Boss Rush")) {defExports.basic.UPGRADES_TIER_1.push(defExports.healer)}
        if(c.serverName.includes("The Shattered Beyond")) {defExports.basic.UPGRADES_TIER_4.push(defExports.vacoScientist)}

//defExports.basic.UPGRADES_TIER_5 = [defExports.rollfac]

    let sussyBakas = {};

    // This will ban random ass people
    /*setInterval(function () {
        let badUsers = multiboxStore.test();
        for (let badUser in sussyBakas) {
            if (!badUsers[+badUser]) {
                sussyBakas[badUser]--;
                if (sussyBakas[badUser] < 0) {
                    delete sussyBakas[badUser];
                }
            }
        }
        for (let userID in badUsers) {
            sussyBakas[userID] = (sussyBakas[userID] || 0) + badUsers[userID];
            if (sussyBakas[userID] > 30) {
                delete sussyBakas[userID];
                let entity = getEntity(+userID);
                if (entity && entity.socket && entity.socket._socket.readyState === 1) {
                    entity.socket.ban(sha256("Multiboxing " + entity.name));
                }
            }
        }
    }, 1000);*/

    if (room.maxBots > 0) setTimeout(() => util.log(`Spawned ${room.maxBots} AI bot${room.maxBots > 1 ? "s." : "."}`), 350);
    worker.postMessage({type:"serverStarted"})
})();
}